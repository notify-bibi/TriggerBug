<!DOCTYPE html>
<!-- saved from url=(0245)https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=0,27,1022,79,115,5771,2476,73,72,54,4775,4510,5014,4932,0,468,6161,6162,2629,127,152,3862,79,6177,6174,6171,6169,18,100&techs=MMX,SSE,SSE2,SSE3,SSSE3,SSE4_1,SSE4_2,AVX,AVX2,FMA -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<meta http-equiv="X-UA-Compatible" content="IE=9; IE=8; IE=7; IE=EDGE">
		<title>Intel® Intrinsics Guide</title>
		<link rel="shortcut icon" href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/files/favicon.ico">
		<link type="text/css" rel="stylesheet" href="./Intel® Intrinsics Guide_files/style.min.css">
		<script type="text/javascript" async="" src="./Intel® Intrinsics Guide_files/dc.js.下载"></script><script type="text/javascript" src="./Intel® Intrinsics Guide_files/jquery-1.10.2.min.js.下载"></script>
		<link href="./Intel® Intrinsics Guide_files/css" rel="stylesheet" type="text/css">
		<meta name="fragment" content="!">
		<meta name="Description" content="The Intel Intrinsics Guide is an interactive reference tool for Intel intrinsic instructions, which are C style functions that provide access to many Intel instructions - including Intel® SSE, AVX, AVX-512, and more - without the need to write assembly code.">
		<script type="text/javascript">
		  var _gaq = _gaq || [];
		  _gaq.push(['_setAccount', 'UA-17890616-1']);
		  _gaq.push(['_setDomainName', 'intel.com']);
		  _gaq.push(['_trackPageview']);
		  (function() {
		    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
		    ga.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'stats.g.doubleclick.net/dc.js';
		    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		  })();
		</script>
	</head>

	<body style="">
		
		<div id="container">
			
			<div id="left">
				
				<div>
					<img id="logo" src="./Intel® Intrinsics Guide_files/intel.png" alt="Intel">
					<div id="title"><b>Intrinsics Guide</b></div>
					<div style="clear:both;"></div>
				</div><br>
				
				<div><b>Technologies</b></div>
				<div id="techs">
					<div class="MMX tech"><input type="checkbox"> MMX</div>
					<div class="SSE tech"><input type="checkbox"> SSE</div>
					<div class="SSE2 tech"><input type="checkbox"> SSE2</div>
					<div class="SSE3 tech"><input type="checkbox"> SSE3</div>
					<div class="SSSE3 tech"><input type="checkbox"> SSSE3</div>
					<div class="SSE4_1 tech"><input type="checkbox"> SSE4.1</div>
					<div class="SSE4_2 tech"><input type="checkbox"> SSE4.2</div>
					<div class="AVX tech"><input type="checkbox"> AVX</div>
					<div class="AVX2 tech"><input type="checkbox"> AVX2</div>
					<div class="FMA tech"><input type="checkbox"> FMA</div>
					<div class="AVX_512 tech"><input type="checkbox"> AVX-512</div>
					<div id="avx512_techs" style="display: none;">
						<div class="AVX512F avx512tech"><input type="checkbox"> AVX-512F</div>
						<div class="AVX512BW avx512tech"><input type="checkbox"> AVX-512BW</div>
						<div class="AVX512CD avx512tech"><input type="checkbox"> AVX-512CD</div>
						<div class="AVX512DQ avx512tech"><input type="checkbox"> AVX-512DQ</div>
						<div class="AVX512ER avx512tech"><input type="checkbox"> AVX-512ER</div>
						<div class="AVX512IFMA52 avx512tech"><input type="checkbox"> AVX-512IFMA52</div>
						<div class="AVX512PF avx512tech"><input type="checkbox"> AVX-512PF</div>
						<div class="AVX512VL avx512tech"><input type="checkbox"> AVX-512VL</div>
						<div class="AVX512VPOPCNTDQ avx512tech"><input type="checkbox"> AVX-512VPOPCNTDQ</div>
						<div class="AVX512_4FMAPS avx512tech"><input type="checkbox"> AVX-512_4FMAPS</div>
						<div class="AVX512_4VNNIW avx512tech"><input type="checkbox"> AVX-512_4VNNIW</div>
						<div class="AVX512_BF16 avx512tech"><input type="checkbox"> AVX-512_BF16</div>
						<div class="AVX512_BITALG avx512tech"><input type="checkbox"> AVX-512_BITALG</div>
						<div class="AVX512_VBMI avx512tech"><input type="checkbox"> AVX-512_VBMI</div>
						<div class="AVX512_VBMI2 avx512tech"><input type="checkbox"> AVX-512_VBMI2</div>
						<div class="AVX512_VNNI avx512tech"><input type="checkbox"> AVX-512_VNNI</div>
					</div>
					<div class="KNC tech"><input type="checkbox"> KNC</div>
					<div class="SVML tech"><input type="checkbox"> SVML</div>
					<div class="Other tech"><input type="checkbox"> Other</div>
					<div id="other_techs" style="display: none;"><div class="ADX othertech"><input type="checkbox"> ADX</div><div class="AES othertech"><input type="checkbox"> AES</div><div class="BMI1 othertech"><input type="checkbox"> BMI1</div><div class="BMI2 othertech"><input type="checkbox"> BMI2</div><div class="CLDEMOTE othertech"><input type="checkbox"> CLDEMOTE</div><div class="CLFLUSHOPT othertech"><input type="checkbox"> CLFLUSHOPT</div><div class="CLWB othertech"><input type="checkbox"> CLWB</div><div class="FP16C othertech"><input type="checkbox"> FP16C</div><div class="FSGSBASE othertech"><input type="checkbox"> FSGSBASE</div><div class="FXSR othertech"><input type="checkbox"> FXSR</div><div class="GFNI othertech"><input type="checkbox"> GFNI</div><div class="INVPCID othertech"><input type="checkbox"> INVPCID</div><div class="LZCNT othertech"><input type="checkbox"> LZCNT</div><div class="MONITOR othertech"><input type="checkbox"> MONITOR</div><div class="MOVBE othertech"><input type="checkbox"> MOVBE</div><div class="MOVDIR64B othertech"><input type="checkbox"> MOVDIR64B</div><div class="MOVDIRI othertech"><input type="checkbox"> MOVDIRI</div><div class="MPX othertech"><input type="checkbox"> MPX</div><div class="PCLMULQDQ othertech"><input type="checkbox"> PCLMULQDQ</div><div class="PCONFIG othertech"><input type="checkbox"> PCONFIG</div><div class="POPCNT othertech"><input type="checkbox"> POPCNT</div><div class="PREFETCHWT1 othertech"><input type="checkbox"> PREFETCHWT1</div><div class="RDPID othertech"><input type="checkbox"> RDPID</div><div class="RDRAND othertech"><input type="checkbox"> RDRAND</div><div class="RDSEED othertech"><input type="checkbox"> RDSEED</div><div class="RDTSCP othertech"><input type="checkbox"> RDTSCP</div><div class="RTM othertech"><input type="checkbox"> RTM</div><div class="SHA othertech"><input type="checkbox"> SHA</div><div class="TSC othertech"><input type="checkbox"> TSC</div><div class="VAES othertech"><input type="checkbox"> VAES</div><div class="VPCLMULQDQ othertech"><input type="checkbox"> VPCLMULQDQ</div><div class="WAITPKG othertech"><input type="checkbox"> WAITPKG</div><div class="WBNOINVD othertech"><input type="checkbox"> WBNOINVD</div><div class="XSAVE othertech"><input type="checkbox"> XSAVE</div><div class="XSAVEC othertech"><input type="checkbox"> XSAVEC</div><div class="XSAVEOPT othertech"><input type="checkbox"> XSAVEOPT</div><div class="XSS othertech"><input type="checkbox"> XSS</div></div>
				</div><br>

				<div><b>Categories</b></div>
				<div id="categories"><div class="category"><input type="checkbox"> <span>Application-Targeted</span></div><div class="category"><input type="checkbox"> <span>Arithmetic</span></div><div class="category"><input type="checkbox"> <span>Bit Manipulation</span></div><div class="category"><input type="checkbox"> <span>Cast</span></div><div class="category"><input type="checkbox"> <span>Compare</span></div><div class="category"><input type="checkbox"> <span>Convert</span></div><div class="category"><input type="checkbox"> <span>Cryptography</span></div><div class="category"><input type="checkbox"> <span>Elementary Math Functions</span></div><div class="category"><input type="checkbox"> <span>General Support</span></div><div class="category"><input type="checkbox"> <span>Load</span></div><div class="category"><input type="checkbox"> <span>Logical</span></div><div class="category"><input type="checkbox"> <span>Mask</span></div><div class="category"><input type="checkbox"> <span>Miscellaneous</span></div><div class="category"><input type="checkbox"> <span>Move</span></div><div class="category"><input type="checkbox"> <span>OS-Targeted</span></div><div class="category"><input type="checkbox"> <span>Probability/Statistics</span></div><div class="category"><input type="checkbox"> <span>Random</span></div><div class="category"><input type="checkbox"> <span>Set</span></div><div class="category"><input type="checkbox"> <span>Shift</span></div><div class="category"><input type="checkbox"> <span>Special Math Functions</span></div><div class="category"><input type="checkbox"> <span>Store</span></div><div class="category"><input type="checkbox"> <span>String Compare</span></div><div class="category"><input type="checkbox"> <span>Swizzle</span></div><div class="category"><input type="checkbox"> <span>Trigonometry</span></div></div>

				<br><a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/files/LegalStatement.html" style="font-size:80%;">Legal Statement</a>
			</div>
			
			<div id="main">
			
				<div id="about" style="display: none;">
					The Intel Intrinsics Guide is an interactive reference tool for Intel intrinsic instructions, which are C style functions that provide access to many Intel instructions - including Intel® SSE, AVX, AVX-512, and more - without the need to write assembly code.
					<img id="close" src="./Intel® Intrinsics Guide_files/x.png" alt="Close">
				</div>
			
				<div id="info" style="color: rgb(8, 114, 197);">?</div>
				<div id="search_wrapper">
					<div id="search_tokens"></div>
					<input id="search" type="text" value="_mm_search" autocomplete="off">
					<img id="clear" src="./Intel® Intrinsics Guide_files/x.png" style="display:none;" alt="Clear">
				</div><br>
				
				<div id="intrinsics_list" style="min-height: 27378px;"><div class="intrinsic SSSE3" id="18"><div class="instruction">pabsw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_abs_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details" style="display: block;"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_abs_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: pabsw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 16-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := ABS(a[i+15:i])
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="21"><div class="instruction">vpabsw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_abs_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_abs_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsw ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 16-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := ABS(a[i+15:i])
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSSE3" id="27"><div class="instruction">pabsd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_abs_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_abs_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: pabsd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 32-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := ABS(a[i+31:i])
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="30"><div class="instruction">vpabsd</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_abs_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_abs_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsd ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 32-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := ABS(a[i+31:i])
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSSE3" id="45"><div class="instruction">pabsb</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_abs_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_abs_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: pabsb xmm, xmm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 8-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := ABS(a[i+7:i])
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="48"><div class="instruction">vpabsb</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_abs_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_abs_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsb ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 8-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := ABS(a[i+7:i])
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSSE3" id="56"><div class="instruction">pabsw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_abs_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_abs_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: pabsw mm, mm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 16-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := ABS(a[i+15:i])
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSSE3" id="57"><div class="instruction">pabsd</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_abs_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_abs_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: pabsd mm, mm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 32-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*32
	dst[i+31:i] := ABS(a[i+31:i])
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSSE3" id="58"><div class="instruction">pabsb</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_abs_pi8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_abs_pi8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: pabsb mm, mm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 8-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := ABS(a[i+7:i])
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="79"><div class="instruction">paddw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_add_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_add_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: paddw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Add packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := a[i+15:i] + b[i+15:i]
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="82"><div class="instruction">vpaddw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_add_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_add_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddw ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Add packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := a[i+15:i] + b[i+15:i]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="88"><div class="instruction">paddd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_add_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_add_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: paddd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Add packed 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := a[i+31:i] + b[i+31:i]
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="91"><div class="instruction">vpaddd</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_add_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_add_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Add packed 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := a[i+31:i] + b[i+31:i]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="97"><div class="instruction">paddq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_add_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_add_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: paddq xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Add packed 64-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := a[i+63:i] + b[i+63:i]
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="100"><div class="instruction">vpaddq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_add_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details" style="display: block;"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_add_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddq ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Add packed 64-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[i+63:i] + b[i+63:i]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="106"><div class="instruction">paddb</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_add_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_add_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: paddb xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Add packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := a[i+7:i] + b[i+7:i]
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="109"><div class="instruction">vpaddb</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_add_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_add_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddb ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Add packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := a[i+7:i] + b[i+7:i]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="115"><div class="instruction">addpd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_add_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_add_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: addpd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Add packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := a[i+63:i] + b[i+63:i]
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="118"><div class="instruction">vaddpd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_add_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_add_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddpd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Add packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[i+63:i] + b[i+63:i]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic MMX" id="124"><div class="instruction">paddw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_add_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_add_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: paddw mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Add packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := a[i+15:i] + b[i+15:i]
ENDFOR</div></div></div><div class="intrinsic MMX" id="125"><div class="instruction">paddd</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_add_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_add_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: paddd mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Add packed 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*32
	dst[i+31:i] := a[i+31:i] + b[i+31:i]
ENDFOR</div></div></div><div class="intrinsic MMX" id="126"><div class="instruction">paddb</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_add_pi8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_add_pi8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: paddb mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Add packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := a[i+7:i] + b[i+7:i]
ENDFOR</div></div></div><div class="intrinsic SSE" id="127"><div class="instruction">addps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_add_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_add_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: addps xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Add packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := a[i+31:i] + b[i+31:i]
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="130"><div class="instruction">vaddps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_add_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_add_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddps ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Add packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := a[i+31:i] + b[i+31:i]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="148"><div class="instruction">addsd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_add_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_add_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: addsd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Add the lower double-precision (64-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">dst[63:0] := a[63:0] + b[63:0]
dst[127:64] := a[127:64]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="151"><div class="instruction">paddq</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_add_si64</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_add_si64</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: paddq mm, mm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Add 64-bit integers <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := a[63:0] + b[63:0]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="152"><div class="instruction">addss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_add_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_add_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: addss xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Add the lower single-precision (32-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">dst[31:0] := a[31:0] + b[31:0]
dst[127:32] := a[127:32]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="167"><div class="instruction">paddsw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_adds_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_adds_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: paddsw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Add packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := Saturate_To_Int16( a[i+15:i] + b[i+15:i] )
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="170"><div class="instruction">vpaddsw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_adds_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_adds_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddsw ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Add packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := Saturate_To_Int16( a[i+15:i] + b[i+15:i] )
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="176"><div class="instruction">paddsb</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_adds_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_adds_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: paddsb xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Add packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := Saturate_To_Int8( a[i+7:i] + b[i+7:i] )
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="179"><div class="instruction">vpaddsb</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_adds_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_adds_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddsb ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Add packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := Saturate_To_Int8( a[i+7:i] + b[i+7:i] )
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="185"><div class="instruction">paddusw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_adds_epu16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_adds_epu16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: paddusw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Add packed unsigned 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := Saturate_To_UnsignedInt16( a[i+15:i] + b[i+15:i] )
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="188"><div class="instruction">vpaddusw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_adds_epu16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_adds_epu16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddusw ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Add packed unsigned 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := Saturate_To_UnsignedInt16( a[i+15:i] + b[i+15:i] )
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="194"><div class="instruction">paddusb</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_adds_epu8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_adds_epu8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: paddusb xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Add packed unsigned 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := Saturate_To_UnsignedInt8( a[i+7:i] + b[i+7:i] )
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="197"><div class="instruction">vpaddusb</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_adds_epu8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_adds_epu8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddusb ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Add packed unsigned 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := Saturate_To_UnsignedInt8( a[i+7:i] + b[i+7:i] )
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic MMX" id="203"><div class="instruction">paddsw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_adds_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_adds_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: paddsw mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Add packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := Saturate_To_Int16( a[i+15:i] + b[i+15:i] )
ENDFOR</div></div></div><div class="intrinsic MMX" id="204"><div class="instruction">paddsb</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_adds_pi8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_adds_pi8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: paddsb mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Add packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := Saturate_To_Int8( a[i+7:i] + b[i+7:i] )
ENDFOR</div></div></div><div class="intrinsic MMX" id="205"><div class="instruction">paddusw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_adds_pu16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_adds_pu16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: paddusw mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Add packed unsigned 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := Saturate_To_UnsignedInt16( a[i+15:i] + b[i+15:i] )
ENDFOR</div></div></div><div class="intrinsic MMX" id="206"><div class="instruction">paddusb</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_adds_pu8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_adds_pu8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: paddusb mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Add packed unsigned 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := Saturate_To_UnsignedInt8( a[i+7:i] + b[i+7:i] )
ENDFOR</div></div></div><div class="intrinsic SSE3" id="215"><div class="instruction">addsubpd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_addsub_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_addsub_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;pmmintrin.h&gt;<br>Instruction: addsubpd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE3</span></div><h1>Description</h1><div class="description">Alternatively add and subtract packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> to/from packed elements in <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	IF (j % 1 == 0)
		dst[i+63:i] := a[i+63:i] - b[i+63:i]
	ELSE
		dst[i+63:i] := a[i+63:i] + b[i+63:i]
	FI
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="216"><div class="instruction">vaddsubpd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_addsub_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_addsub_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddsubpd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Alternatively add and subtract packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> to/from packed elements in <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	IF (j % 1 == 0) 
		dst[i+63:i] := a[i+63:i] - b[i+63:i]
	ELSE
		dst[i+63:i] := a[i+63:i] + b[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE3" id="217"><div class="instruction">addsubps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_addsub_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_addsub_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;pmmintrin.h&gt;<br>Instruction: addsubps xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE3</span></div><h1>Description</h1><div class="description">Alternatively add and subtract packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> to/from packed elements in <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	IF (j % 1 == 0)
		dst[i+31:i] := a[i+31:i] - b[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i] + b[i+31:i]
	FI
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="218"><div class="instruction">vaddsubps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_addsub_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_addsub_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddsubps ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Alternatively add and subtract packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> to/from packed elements in <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	IF (j % 1 == 0) 
		dst[i+31:i] := a[i+31:i] - b[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i] + b[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSSE3" id="251"><div class="instruction">palignr</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_alignr_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_alignr_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">count</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: palignr xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Concatenate 16-byte blocks in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> into a 32-byte temporary result, shift the result right by <span class="desc_var count">count</span> bytes, and store the low 16 bytes in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">tmp[255:0] := ((a[127:0] &lt;&lt; 128) OR b[127:0]) &gt;&gt; (count[7:0]*8)
dst[127:0] := tmp[127:0]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="254"><div class="instruction">vpalignr</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_alignr_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_alignr_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">count</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpalignr ymm, ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Concatenate pairs of 16-byte blocks in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> into a 32-byte temporary result, shift the result right by <span class="desc_var count">count</span> bytes, and store the low 16 bytes in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*128
	tmp[255:0] := ((a[i+127:i] &lt;&lt; 128) OR b[i+127:i]) &gt;&gt; (count[7:0]*8)
	dst[i+127:i] := tmp[127:0]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSSE3" id="260"><div class="instruction">palignr</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_alignr_pi8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_alignr_pi8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">count</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: palignr mm, mm, imm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Concatenate 8-byte blocks in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> into a 16-byte temporary result, shift the result right by <span class="desc_var count">count</span> bytes, and store the low 16 bytes in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">tmp[127:0] := ((a[63:0] &lt;&lt; 64) OR b[63:0]) &gt;&gt; (count[7:0]*8)
dst[63:0] := tmp[63:0]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="276"><div class="instruction">andpd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_and_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_and_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: andpd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compute the bitwise AND of packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := (a[i+63:i] AND b[i+63:i])
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="279"><div class="instruction">vandpd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_and_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_and_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vandpd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compute the bitwise AND of packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := (a[i+63:i] AND b[i+63:i])
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="285"><div class="instruction">andps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_and_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_and_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: andps xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compute the bitwise AND of packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := (a[i+31:i] AND b[i+31:i])
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="288"><div class="instruction">vandps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_and_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_and_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vandps ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compute the bitwise AND of packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := (a[i+31:i] AND b[i+31:i])
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="294"><div class="instruction">pand</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_and_si128</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_and_si128</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pand xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compute the bitwise AND of 128 bits (representing integer data) in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[127:0] := (a[127:0] AND b[127:0])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.33</td></tr><tr><td>Haswell</td><td>1</td><td>0.33</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.33</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="295"><div class="instruction">vpand</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_and_si256</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_and_si256</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpand ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Compute the bitwise AND of 256 bits (representing integer data) in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[255:0] := (a[255:0] AND b[255:0])
dst[MAX:256] := 0</div></div></div><div class="intrinsic MMX" id="297"><div class="instruction">pand</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_and_si64</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_and_si64</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: pand mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Compute the bitwise AND of 64 bits (representing integer data) in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := (a[63:0] AND b[63:0])</div></div></div><div class="intrinsic SSE2" id="314"><div class="instruction">andnpd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_andnot_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_andnot_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: andnpd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compute the bitwise NOT of packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and then AND with <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := ((NOT a[i+63:i]) AND b[i+63:i])
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="317"><div class="instruction">vandnpd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_andnot_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_andnot_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vandnpd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compute the bitwise NOT of packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and then AND with <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := ((NOT a[i+63:i]) AND b[i+63:i])
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="323"><div class="instruction">andnps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_andnot_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_andnot_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: andnps xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compute the bitwise NOT of packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and then AND with <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := ((NOT a[i+31:i]) AND b[i+31:i])
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="326"><div class="instruction">vandnps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_andnot_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_andnot_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vandnps ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compute the bitwise NOT of packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and then AND with <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := ((NOT a[i+31:i]) AND b[i+31:i])
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="332"><div class="instruction">pandn</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_andnot_si128</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_andnot_si128</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pandn xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compute the bitwise NOT of 128 bits (representing integer data) in <span class="desc_var a">a</span> and then AND with <span class="desc_var b">b</span>, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[127:0] := ((NOT a[127:0]) AND b[127:0])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.33</td></tr><tr><td>Haswell</td><td>1</td><td>0.33</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.33</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="333"><div class="instruction">vpandn</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_andnot_si256</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_andnot_si256</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpandn ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Compute the bitwise NOT of 256 bits (representing integer data) in <span class="desc_var a">a</span> and then AND with <span class="desc_var b">b</span>, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[255:0] := ((NOT a[255:0]) AND b[255:0])
dst[MAX:256] := 0</div></div></div><div class="intrinsic MMX" id="335"><div class="instruction">pandn</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_andnot_si64</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_andnot_si64</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: pandn mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Compute the bitwise NOT of 64 bits (representing integer data) in <span class="desc_var a">a</span> and then AND with <span class="desc_var b">b</span>, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := ((NOT a[63:0]) AND b[63:0])</div></div></div><div class="intrinsic SSE2" id="376"><div class="instruction">pavgw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_avg_epu16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_avg_epu16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pavgw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Average packed unsigned 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := (a[i+15:i] + b[i+15:i] + 1) &gt;&gt; 1
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="379"><div class="instruction">vpavgw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_avg_epu16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_avg_epu16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpavgw ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Average packed unsigned 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := (a[i+15:i] + b[i+15:i] + 1) &gt;&gt; 1
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="385"><div class="instruction">pavgb</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_avg_epu8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_avg_epu8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pavgb xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Average packed unsigned 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := (a[i+7:i] + b[i+7:i] + 1) &gt;&gt; 1
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="388"><div class="instruction">vpavgb</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_avg_epu8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_avg_epu8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpavgb ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Average packed unsigned 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := (a[i+7:i] + b[i+7:i] + 1) &gt;&gt; 1
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="394"><div class="instruction">pavgw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_avg_pu16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_avg_pu16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: pavgw mm, mm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Average packed unsigned 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := (a[i+15:i] + b[i+15:i] + 1) &gt;&gt; 1
ENDFOR</div></div></div><div class="intrinsic SSE" id="395"><div class="instruction">pavgb</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_avg_pu8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_avg_pu8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: pavgb mm, mm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Average packed unsigned 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := (a[i+7:i] + b[i+7:i] + 1) &gt;&gt; 1
ENDFOR</div></div></div><div class="intrinsic SSE4_1" id="420"><div class="instruction">pblendw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_blend_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_blend_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: pblendw xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Blend packed 16-bit integers from <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using control mask <span class="desc_var imm8">imm8</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	IF imm8[j]
		dst[i+15:i] := b[i+15:i]
	ELSE
		dst[i+15:i] := a[i+15:i]
	FI
ENDFOR</div></div></div><div class="intrinsic AVX2" id="422"><div class="instruction">vpblendw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_blend_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_blend_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpblendw ymm, ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Blend packed 16-bit integers from <span class="desc_var a">a</span> and <span class="desc_var b">b</span> within 128-bit lanes using control mask <span class="desc_var imm8">imm8</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	IF imm8[j%8]
		dst[i+15:i] := b[i+15:i]
	ELSE
		dst[i+15:i] := a[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="425"><div class="instruction">vpblendd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_blend_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_blend_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpblendd xmm, xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Blend packed 32-bit integers from <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using control mask <span class="desc_var imm8">imm8</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	IF imm8[j]
		dst[i+31:i] := b[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.33</td></tr><tr><td>Haswell</td><td>1</td><td>0.33</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="427"><div class="instruction">vpblendd</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_blend_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_blend_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpblendd ymm, ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Blend packed 32-bit integers from <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using control mask <span class="desc_var imm8">imm8</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	IF imm8[j]
		dst[i+31:i] := b[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.33</td></tr><tr><td>Haswell</td><td>1</td><td>0.33</td></tr></tbody></table></div></div><div class="intrinsic SSE4_1" id="436"><div class="instruction">blendpd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_blend_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_blend_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: blendpd xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Blend packed double-precision (64-bit) floating-point elements from <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using control mask <span class="desc_var imm8">imm8</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	IF imm8[j]
		dst[i+63:i] := b[i+63:i]
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR</div></div></div><div class="intrinsic AVX" id="438"><div class="instruction">vblendpd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_blend_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_blend_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vblendpd ymm, ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Blend packed double-precision (64-bit) floating-point elements from <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using control mask <span class="desc_var imm8">imm8</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	IF imm8[j]
		dst[i+63:i] := b[i+63:i]
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.33</td></tr><tr><td>Haswell</td><td>1</td><td>0.33</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSE4_1" id="441"><div class="instruction">blendps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_blend_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_blend_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: blendps xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Blend packed single-precision (32-bit) floating-point elements from <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using control mask <span class="desc_var imm8">imm8</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	IF imm8[j]
		dst[i+31:i] := b[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR</div></div></div><div class="intrinsic AVX" id="443"><div class="instruction">vblendps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_blend_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_blend_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vblendps ymm, ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Blend packed single-precision (32-bit) floating-point elements from <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using control mask <span class="desc_var imm8">imm8</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	IF imm8[j]
		dst[i+31:i] := b[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.33</td></tr><tr><td>Haswell</td><td>1</td><td>0.33</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSE4_1" id="446"><div class="instruction">pblendvb</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_blendv_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">__m128i</span> <span class="param_name">mask</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_blendv_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">__m128i</span> <span class="param_name">mask</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: pblendvb xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Blend packed 8-bit integers from <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using <span class="desc_var mask">mask</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*8
	IF mask[i+7]
		dst[i+7:i] := b[i+7:i]
	ELSE
		dst[i+7:i] := a[i+7:i]
	FI
ENDFOR</div></div></div><div class="intrinsic AVX2" id="447"><div class="instruction">vpblendvb</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_blendv_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>, <span class="param_type">__m256i</span> <span class="param_name">mask</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_blendv_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>, <span class="param_type">__m256i</span> <span class="param_name">mask</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpblendvb ymm, ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Blend packed 8-bit integers from <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using <span class="desc_var mask">mask</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*8
	IF mask[i+7]
		dst[i+7:i] := b[i+7:i]
	ELSE
		dst[i+7:i] := a[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>2</td></tr><tr><td>Haswell</td><td>2</td><td>2</td></tr></tbody></table></div></div><div class="intrinsic SSE4_1" id="448"><div class="instruction">blendvpd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_blendv_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">__m128d</span> <span class="param_name">mask</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_blendv_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">__m128d</span> <span class="param_name">mask</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: blendvpd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Blend packed double-precision (64-bit) floating-point elements from <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using <span class="desc_var mask">mask</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	IF mask[i+63]
		dst[i+63:i] := b[i+63:i]
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR</div></div></div><div class="intrinsic AVX" id="449"><div class="instruction">vblendvpd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_blendv_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>, <span class="param_type">__m256d</span> <span class="param_name">mask</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_blendv_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>, <span class="param_type">__m256d</span> <span class="param_name">mask</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vblendvpd ymm, ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Blend packed double-precision (64-bit) floating-point elements from <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using <span class="desc_var mask">mask</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	IF mask[i+63]
		dst[i+63:i] := b[i+63:i]
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>2</td></tr><tr><td>Haswell</td><td>2</td><td>2</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE4_1" id="450"><div class="instruction">blendvps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_blendv_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">__m128</span> <span class="param_name">mask</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_blendv_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">__m128</span> <span class="param_name">mask</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: blendvps xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Blend packed single-precision (32-bit) floating-point elements from <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using <span class="desc_var mask">mask</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	IF mask[i+31]
		dst[i+31:i] := b[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR</div></div></div><div class="intrinsic AVX" id="451"><div class="instruction">vblendvps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_blendv_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>, <span class="param_type">__m256</span> <span class="param_name">mask</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_blendv_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>, <span class="param_type">__m256</span> <span class="param_name">mask</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vblendvps ymm, ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Blend packed single-precision (32-bit) floating-point elements from <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using <span class="desc_var mask">mask</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	IF mask[i+31]
		dst[i+31:i] := b[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>2</td></tr><tr><td>Haswell</td><td>2</td><td>2</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="519"><div class="instruction">vbroadcastf128</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_broadcast_pd</span> (<span class="param_type">__m128d const *</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_broadcast_pd</span> (<span class="param_type">__m128d const *</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vbroadcastf128 ymm, m128<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Broadcast 128 bits from memory (composed of 2 packed double-precision (64-bit) floating-point elements) to all elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">tmp[127:0] := MEM[mem_addr+127:mem_addr]
dst[127:0] := tmp[127:0]
dst[255:128] := tmp[127:0]
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX" id="520"><div class="instruction">vbroadcastf128</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_broadcast_ps</span> (<span class="param_type">__m128 const *</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_broadcast_ps</span> (<span class="param_type">__m128 const *</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vbroadcastf128 ymm, m128<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Broadcast 128 bits from memory (composed of 4 packed single-precision (32-bit) floating-point elements) to all elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">tmp[127:0] := MEM[mem_addr+127:mem_addr]
dst[127:0] := tmp[127:0]
dst[255:128] := tmp[127:0]
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX" id="521"><div class="instruction">vbroadcastsd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_broadcast_sd</span> (<span class="param_type">double const *</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_broadcast_sd</span> (<span class="param_type">double const *</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vbroadcastsd ymm, m64<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Broadcast a double-precision (64-bit) floating-point element from memory to all elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">tmp[63:0] := MEM[mem_addr+63:mem_addr]
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := tmp[63:0]
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX" id="522"><div class="instruction">vbroadcastss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_broadcast_ss</span> (<span class="param_type">float const *</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_broadcast_ss</span> (<span class="param_type">float const *</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vbroadcastss xmm, m32<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Broadcast a single-precision (32-bit) floating-point element from memory to all elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">tmp[31:0] := MEM[mem_addr+31:mem_addr]
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := tmp[31:0]
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX" id="523"><div class="instruction">vbroadcastss</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_broadcast_ss</span> (<span class="param_type">float const *</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_broadcast_ss</span> (<span class="param_type">float const *</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vbroadcastss ymm, m32<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Broadcast a single-precision (32-bit) floating-point element from memory to all elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">tmp[31:0] := MEM[mem_addr+31:mem_addr]
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := tmp[31:0]
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX2" id="524"><div class="instruction">vpbroadcastb</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_broadcastb_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_broadcastb_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpbroadcastb xmm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Broadcast the low packed 8-bit integer from <span class="desc_var a">a</span> to all elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := a[7:0]
ENDFOR
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>1</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="527"><div class="instruction">vpbroadcastb</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_broadcastb_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_broadcastb_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpbroadcastb ymm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Broadcast the low packed 8-bit integer from <span class="desc_var a">a</span> to all elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := a[7:0]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>1</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="533"><div class="instruction">vpbroadcastd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_broadcastd_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_broadcastd_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpbroadcastd xmm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Broadcast the low packed 32-bit integer from <span class="desc_var a">a</span> to all elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := a[31:0]
ENDFOR
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>1</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="536"><div class="instruction">vpbroadcastd</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_broadcastd_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_broadcastd_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpbroadcastd ymm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Broadcast the low packed 32-bit integer from <span class="desc_var a">a</span> to all elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := a[31:0]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>1</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="548"><div class="instruction">vpbroadcastq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_broadcastq_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_broadcastq_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpbroadcastq xmm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Broadcast the low packed 64-bit integer from <span class="desc_var a">a</span> to all elements of <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := a[63:0]
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX2" id="551"><div class="instruction">vpbroadcastq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_broadcastq_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_broadcastq_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpbroadcastq ymm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Broadcast the low packed 64-bit integer from <span class="desc_var a">a</span> to all elements of <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[63:0]
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX2" id="557"><div class="instruction">movddup</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_broadcastsd_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_broadcastsd_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: movddup xmm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Broadcast the low double-precision (64-bit) floating-point element from <span class="desc_var a">a</span> to all elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := a[63:0]
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX2" id="558"><div class="instruction">vbroadcastsd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_broadcastsd_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_broadcastsd_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vbroadcastsd ymm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Broadcast the low double-precision (64-bit) floating-point element from <span class="desc_var a">a</span> to all elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[63:0]
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX2" id="564"><div class="instruction">vbroadcasti128</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm_broadcastsi128_si256</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm_broadcastsi128_si256</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vbroadcasti128 ymm, m128<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Broadcast 128 bits of integer data from <span class="desc_var a">a</span> to all 128-bit lanes in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">dst[127:0] := a[127:0]
dst[255:128] := a[127:0]
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX2" id="565"><div class="instruction">vbroadcasti128</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_broadcastsi128_si256</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_broadcastsi128_si256</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vbroadcasti128 ymm, m128<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Broadcast 128 bits of integer data from <span class="desc_var a">a</span> to all 128-bit lanes in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">dst[127:0] := a[127:0]
dst[255:128] := a[127:0]
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX2" id="566"><div class="instruction">vbroadcastss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_broadcastss_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_broadcastss_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vbroadcastss xmm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Broadcast the low single-precision (32-bit) floating-point element from <span class="desc_var a">a</span> to all elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := a[31:0]
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX2" id="569"><div class="instruction">vbroadcastss</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_broadcastss_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_broadcastss_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vbroadcastss ymm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Broadcast the low single-precision (32-bit) floating-point element from <span class="desc_var a">a</span> to all elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := a[31:0]
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX2" id="575"><div class="instruction">vpbroadcastw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_broadcastw_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_broadcastw_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpbroadcastw xmm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Broadcast the low packed 16-bit integer from <span class="desc_var a">a</span> to all elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := a[15:0]
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX2" id="578"><div class="instruction">vpbroadcastw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_broadcastw_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_broadcastw_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpbroadcastw ymm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Broadcast the low packed 16-bit integer from <span class="desc_var a">a</span> to all elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := a[15:0]
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX2" id="584"><div class="instruction">vpslldq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_bslli_epi128</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_bslli_epi128</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpslldq ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shift 128-bit lanes in <span class="desc_var a">a</span> left by <span class="desc_var imm8">imm8</span> bytes while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">tmp := imm8[7:0]
IF tmp &gt; 15
	tmp := 16
FI
dst[127:0] := a[127:0] &lt;&lt; (tmp*8)
dst[255:128] := a[255:128] &lt;&lt; (tmp*8)
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="586"><div class="instruction">pslldq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_bslli_si128</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_bslli_si128</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pslldq xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Shift <span class="desc_var a">a</span> left by <span class="desc_var imm8">imm8</span> bytes while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">tmp := imm8[7:0]
IF tmp &gt; 15
	tmp := 16
FI
dst[127:0] := a[127:0] &lt;&lt; (tmp*8)</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="587"><div class="instruction">vpsrldq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_bsrli_epi128</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_bsrli_epi128</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsrldq ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shift 128-bit lanes in <span class="desc_var a">a</span> right by <span class="desc_var imm8">imm8</span> bytes while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">tmp := imm8[7:0]
IF tmp &gt; 15
	tmp := 16
FI
dst[127:0] := a[127:0] &gt;&gt; (tmp*8)
dst[255:128] := a[255:128] &gt;&gt; (tmp*8)
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="589"><div class="instruction">psrldq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_bsrli_si128</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_bsrli_si128</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: psrldq xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Shift <span class="desc_var a">a</span> right by <span class="desc_var imm8">imm8</span> bytes while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">tmp := imm8[7:0]
IF tmp &gt; 15
	tmp := 16
FI
dst[127:0] := a[127:0] &gt;&gt; (tmp*8)</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="596"><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_castpd_ps</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_castpd_ps</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Cast vector of type __m128d to type __m128. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></div></div><div class="intrinsic AVX" id="597"><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_castpd_ps</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_castpd_ps</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Cast vector of type __m256d to type __m256.
	This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></div></div><div class="intrinsic SSE2" id="599"><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_castpd_si128</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_castpd_si128</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Cast vector of type __m128d to type __m128i. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></div></div><div class="intrinsic AVX" id="600"><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_castpd_si256</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_castpd_si256</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Casts vector of type __m256d to type __m256i. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.
	</div></div></div><div class="intrinsic AVX" id="602"><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_castpd128_pd256</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_castpd128_pd256</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Casts vector of type __m128d to type __m256d; the upper 128 bits of the result are undefined. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.
	</div></div></div><div class="intrinsic AVX" id="604"><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm256_castpd256_pd128</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm256_castpd256_pd128</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Casts vector of type __m256d to type __m128d. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.
	</div></div></div><div class="intrinsic SSE2" id="608"><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_castps_pd</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_castps_pd</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Cast vector of type __m128 to type __m128d. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></div></div><div class="intrinsic AVX" id="609"><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_castps_pd</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_castps_pd</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Cast vector of type __m256 to type __m256d.
	This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></div></div><div class="intrinsic SSE2" id="611"><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_castps_si128</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_castps_si128</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Cast vector of type __m128 to type __m128i. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></div></div><div class="intrinsic AVX" id="612"><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_castps_si256</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_castps_si256</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Casts vector of type __m256 to type __m256i. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.
	</div></div></div><div class="intrinsic AVX" id="614"><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_castps128_ps256</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_castps128_ps256</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Casts vector of type __m128 to type __m256; the upper 128 bits of the result are undefined. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.
	</div></div></div><div class="intrinsic AVX" id="616"><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm256_castps256_ps128</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm256_castps256_ps128</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Casts vector of type __m256 to type __m128. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.
	</div></div></div><div class="intrinsic SSE2" id="620"><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_castsi128_pd</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_castsi128_pd</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Cast vector of type __m128i to type __m128d. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></div></div><div class="intrinsic SSE2" id="621"><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_castsi128_ps</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_castsi128_ps</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Cast vector of type __m128i to type __m128. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</div></div></div><div class="intrinsic AVX" id="622"><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_castsi128_si256</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_castsi128_si256</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Casts vector of type __m128i to type __m256i; the upper 128 bits of the result are undefined. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.
	</div></div></div><div class="intrinsic AVX" id="624"><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_castsi256_pd</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_castsi256_pd</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Casts vector of type __m256i to type __m256d. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.
	</div></div></div><div class="intrinsic AVX" id="625"><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_castsi256_ps</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_castsi256_ps</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Casts vector of type __m256i to type __m256. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.
	</div></div></div><div class="intrinsic AVX" id="626"><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm256_castsi256_si128</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm256_castsi256_si128</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Casts vector of type __m256i to type __m128i. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.
	</div></div></div><div class="intrinsic SSE4_1" id="658"><div class="instruction">roundpd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_ceil_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_ceil_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: roundpd xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Round the packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> up to an integer value, and store the results as packed double-precision floating-point elements in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := CEIL(a[i+63:i])
ENDFOR</div></div></div><div class="intrinsic AVX" id="659"><div class="instruction">vroundpd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_ceil_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_ceil_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vroundpd ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Round the packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> up to an integer value, and store the results as packed double-precision floating-point elements in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := CEIL(a[i+63:i])
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>8</td><td>1</td></tr><tr><td>Broadwell</td><td>6</td><td>2</td></tr><tr><td>Haswell</td><td>6</td><td>2</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE4_1" id="662"><div class="instruction">roundps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_ceil_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_ceil_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: roundps xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Round the packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> up to an integer value, and store the results as packed single-precision floating-point elements in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := CEIL(a[i+31:i])
ENDFOR</div></div></div><div class="intrinsic AVX" id="663"><div class="instruction">vroundps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_ceil_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_ceil_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vroundps ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Round the packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> up to an integer value, and store the results as packed single-precision floating-point elements in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := CEIL(a[i+31:i])
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>8</td><td>1</td></tr><tr><td>Broadwell</td><td>6</td><td>2</td></tr><tr><td>Haswell</td><td>6</td><td>2</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE4_1" id="666"><div class="instruction">roundsd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_ceil_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_ceil_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: roundsd xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Round the lower double-precision (64-bit) floating-point element in <span class="desc_var b">b</span> up to an integer value, store the result as a double-precision floating-point element in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := CEIL(b[63:0])
dst[127:64] := a[127:64]</div></div></div><div class="intrinsic SSE4_1" id="667"><div class="instruction">roundss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_ceil_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_ceil_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: roundss xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Round the lower single-precision (32-bit) floating-point element in <span class="desc_var b">b</span> up to an integer value, store the result as a single-precision floating-point element in the lower element of <span class="desc_var dst">dst</span>, and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := CEIL(b[31:0])
dst[127:32] := a[127:32]</div></div></div><div class="intrinsic SSE2" id="672"><div class="instruction">clflush</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_clflush</span> (<span class="param_type">void const*</span> <span class="param_name">p</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_clflush</span> (<span class="param_type">void const*</span> <span class="param_name">p</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: clflush mprefetch<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Invalidate and flush the cache line that contains <span class="desc_var p">p</span> from all levels of the cache hierarchy.</div></div></div><div class="intrinsic AVX" id="729"><div class="instruction">vcmppd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmp_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmp_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vcmppd xmm, xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compare packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> based on the comparison operand specified by <span class="desc_var imm8">imm8</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">CASE (imm8[7:0]) OF
0: OP := _CMP_EQ_OQ
1: OP := _CMP_LT_OS
2: OP := _CMP_LE_OS
3: OP := _CMP_UNORD_Q 
4: OP := _CMP_NEQ_UQ
5: OP := _CMP_NLT_US
6: OP := _CMP_NLE_US
7: OP := _CMP_ORD_Q
8: OP := _CMP_EQ_UQ
9: OP := _CMP_NGE_US
10: OP := _CMP_NGT_US
11: OP := _CMP_FALSE_OQ
12: OP := _CMP_NEQ_OQ
13: OP := _CMP_GE_OS
14: OP := _CMP_GT_OS
15: OP := _CMP_TRUE_UQ
16: OP := _CMP_EQ_OS
17: OP := _CMP_LT_OQ
18: OP := _CMP_LE_OQ
19: OP := _CMP_UNORD_S
20: OP := _CMP_NEQ_US
21: OP := _CMP_NLT_UQ
22: OP := _CMP_NLE_UQ
23: OP := _CMP_ORD_S
24: OP := _CMP_EQ_US
25: OP := _CMP_NGE_UQ 
26: OP := _CMP_NGT_UQ 
27: OP := _CMP_FALSE_OS 
28: OP := _CMP_NEQ_OS 
29: OP := _CMP_GE_OQ
30: OP := _CMP_GT_OQ
31: OP := _CMP_TRUE_US
ESAC
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := ( a[i+63:i] OP b[i+63:i] ) ? 0xFFFFFFFFFFFFFFFF : 0
ENDFOR
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="730"><div class="instruction">vcmppd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_cmp_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_cmp_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vcmppd ymm, ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compare packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> based on the comparison operand specified by <span class="desc_var imm8">imm8</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">CASE (imm8[7:0]) OF
0: OP := _CMP_EQ_OQ
1: OP := _CMP_LT_OS
2: OP := _CMP_LE_OS
3: OP := _CMP_UNORD_Q 
4: OP := _CMP_NEQ_UQ
5: OP := _CMP_NLT_US
6: OP := _CMP_NLE_US
7: OP := _CMP_ORD_Q
8: OP := _CMP_EQ_UQ
9: OP := _CMP_NGE_US
10: OP := _CMP_NGT_US
11: OP := _CMP_FALSE_OQ
12: OP := _CMP_NEQ_OQ
13: OP := _CMP_GE_OS
14: OP := _CMP_GT_OS
15: OP := _CMP_TRUE_UQ
16: OP := _CMP_EQ_OS
17: OP := _CMP_LT_OQ
18: OP := _CMP_LE_OQ
19: OP := _CMP_UNORD_S
20: OP := _CMP_NEQ_US
21: OP := _CMP_NLT_UQ
22: OP := _CMP_NLE_UQ
23: OP := _CMP_ORD_S
24: OP := _CMP_EQ_US
25: OP := _CMP_NGE_UQ 
26: OP := _CMP_NGT_UQ 
27: OP := _CMP_FALSE_OS 
28: OP := _CMP_NEQ_OS 
29: OP := _CMP_GE_OQ
30: OP := _CMP_GT_OQ
31: OP := _CMP_TRUE_US
ESAC
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := ( a[i+63:i] OP b[i+63:i] ) ? 0xFFFFFFFFFFFFFFFF : 0
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="737"><div class="instruction">vcmpps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmp_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmp_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vcmpps xmm, xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compare packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> based on the comparison operand specified by <span class="desc_var imm8">imm8</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">CASE (imm8[7:0]) OF
0: OP := _CMP_EQ_OQ
1: OP := _CMP_LT_OS
2: OP := _CMP_LE_OS
3: OP := _CMP_UNORD_Q 
4: OP := _CMP_NEQ_UQ
5: OP := _CMP_NLT_US
6: OP := _CMP_NLE_US
7: OP := _CMP_ORD_Q
8: OP := _CMP_EQ_UQ
9: OP := _CMP_NGE_US
10: OP := _CMP_NGT_US
11: OP := _CMP_FALSE_OQ
12: OP := _CMP_NEQ_OQ
13: OP := _CMP_GE_OS
14: OP := _CMP_GT_OS
15: OP := _CMP_TRUE_UQ
16: OP := _CMP_EQ_OS
17: OP := _CMP_LT_OQ
18: OP := _CMP_LE_OQ
19: OP := _CMP_UNORD_S
20: OP := _CMP_NEQ_US
21: OP := _CMP_NLT_UQ
22: OP := _CMP_NLE_UQ
23: OP := _CMP_ORD_S
24: OP := _CMP_EQ_US
25: OP := _CMP_NGE_UQ 
26: OP := _CMP_NGT_UQ 
27: OP := _CMP_FALSE_OS 
28: OP := _CMP_NEQ_OS 
29: OP := _CMP_GE_OQ
30: OP := _CMP_GT_OQ
31: OP := _CMP_TRUE_US
ESAC
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := ( a[i+31:i] OP b[i+31:i] ) ? 0xFFFFFFFF : 0
ENDFOR
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="738"><div class="instruction">vcmpps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_cmp_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_cmp_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vcmpps ymm, ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compare packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> based on the comparison operand specified by <span class="desc_var imm8">imm8</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">CASE (imm8[7:0]) OF
0: OP := _CMP_EQ_OQ
1: OP := _CMP_LT_OS
2: OP := _CMP_LE_OS
3: OP := _CMP_UNORD_Q 
4: OP := _CMP_NEQ_UQ
5: OP := _CMP_NLT_US
6: OP := _CMP_NLE_US
7: OP := _CMP_ORD_Q
8: OP := _CMP_EQ_UQ
9: OP := _CMP_NGE_US
10: OP := _CMP_NGT_US
11: OP := _CMP_FALSE_OQ
12: OP := _CMP_NEQ_OQ
13: OP := _CMP_GE_OS
14: OP := _CMP_GT_OS
15: OP := _CMP_TRUE_UQ
16: OP := _CMP_EQ_OS
17: OP := _CMP_LT_OQ
18: OP := _CMP_LE_OQ
19: OP := _CMP_UNORD_S
20: OP := _CMP_NEQ_US
21: OP := _CMP_NLT_UQ
22: OP := _CMP_NLE_UQ
23: OP := _CMP_ORD_S
24: OP := _CMP_EQ_US
25: OP := _CMP_NGE_UQ 
26: OP := _CMP_NGT_UQ 
27: OP := _CMP_FALSE_OS 
28: OP := _CMP_NEQ_OS 
29: OP := _CMP_GE_OQ
30: OP := _CMP_GT_OQ
31: OP := _CMP_TRUE_US
ESAC
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := ( a[i+31:i] OP b[i+31:i] ) ? 0xFFFFFFFF : 0
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="753"><div class="instruction">vcmpsd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmp_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmp_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vcmpsd xmm, xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compare the lower double-precision (64-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> based on the comparison operand specified by <span class="desc_var imm8">imm8</span>, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">CASE (imm8[7:0]) OF
0: OP := _CMP_EQ_OQ
1: OP := _CMP_LT_OS
2: OP := _CMP_LE_OS
3: OP := _CMP_UNORD_Q 
4: OP := _CMP_NEQ_UQ
5: OP := _CMP_NLT_US
6: OP := _CMP_NLE_US
7: OP := _CMP_ORD_Q
8: OP := _CMP_EQ_UQ
9: OP := _CMP_NGE_US
10: OP := _CMP_NGT_US
11: OP := _CMP_FALSE_OQ
12: OP := _CMP_NEQ_OQ
13: OP := _CMP_GE_OS
14: OP := _CMP_GT_OS
15: OP := _CMP_TRUE_UQ
16: OP := _CMP_EQ_OS
17: OP := _CMP_LT_OQ
18: OP := _CMP_LE_OQ
19: OP := _CMP_UNORD_S
20: OP := _CMP_NEQ_US
21: OP := _CMP_NLT_UQ
22: OP := _CMP_NLE_UQ
23: OP := _CMP_ORD_S
24: OP := _CMP_EQ_US
25: OP := _CMP_NGE_UQ 
26: OP := _CMP_NGT_UQ 
27: OP := _CMP_FALSE_OS 
28: OP := _CMP_NEQ_OS 
29: OP := _CMP_GE_OQ
30: OP := _CMP_GT_OQ
31: OP := _CMP_TRUE_US
ESAC
dst[63:0] := ( a[63:0] OP b[63:0] ) ? 0xFFFFFFFFFFFFFFFF : 0
dst[127:64] := a[127:64]
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX" id="756"><div class="instruction">vcmpss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmp_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmp_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vcmpss xmm, xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compare the lower single-precision (32-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> based on the comparison operand specified by <span class="desc_var imm8">imm8</span>, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">CASE (imm8[7:0]) OF
0: OP := _CMP_EQ_OQ
1: OP := _CMP_LT_OS
2: OP := _CMP_LE_OS
3: OP := _CMP_UNORD_Q 
4: OP := _CMP_NEQ_UQ
5: OP := _CMP_NLT_US
6: OP := _CMP_NLE_US
7: OP := _CMP_ORD_Q
8: OP := _CMP_EQ_UQ
9: OP := _CMP_NGE_US
10: OP := _CMP_NGT_US
11: OP := _CMP_FALSE_OQ
12: OP := _CMP_NEQ_OQ
13: OP := _CMP_GE_OS
14: OP := _CMP_GT_OS
15: OP := _CMP_TRUE_UQ
16: OP := _CMP_EQ_OS
17: OP := _CMP_LT_OQ
18: OP := _CMP_LE_OQ
19: OP := _CMP_UNORD_S
20: OP := _CMP_NEQ_US
21: OP := _CMP_NLT_UQ
22: OP := _CMP_NLE_UQ
23: OP := _CMP_ORD_S
24: OP := _CMP_EQ_US
25: OP := _CMP_NGE_UQ 
26: OP := _CMP_NGT_UQ 
27: OP := _CMP_FALSE_OS 
28: OP := _CMP_NEQ_OS 
29: OP := _CMP_GE_OQ
30: OP := _CMP_GT_OQ
31: OP := _CMP_TRUE_US
ESAC
dst[31:0] := ( a[31:0] OP b[31:0] ) ? 0xFFFFFFFF : 0
dst[127:32] := a[127:32]
dst[MAX:128] := 0</div></div></div><div class="intrinsic SSE2" id="759"><div class="instruction">pcmpeqw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cmpeq_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cmpeq_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pcmpeqw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for equality, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := ( a[i+15:i] == b[i+15:i] ) ? 0xFFFF : 0
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="760"><div class="instruction">vpcmpeqw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cmpeq_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cmpeq_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpcmpeqw ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Compare packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for equality, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := ( a[i+15:i] == b[i+15:i] ) ? 0xFFFF : 0
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="767"><div class="instruction">pcmpeqd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cmpeq_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cmpeq_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pcmpeqd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare packed 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for equality, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := ( a[i+31:i] == b[i+31:i] ) ? 0xFFFFFFFF : 0
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="768"><div class="instruction">vpcmpeqd</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cmpeq_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cmpeq_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpcmpeqd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Compare packed 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for equality, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := ( a[i+31:i] == b[i+31:i] ) ? 0xFFFFFFFF : 0
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSE4_1" id="775"><div class="instruction">pcmpeqq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cmpeq_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cmpeq_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: pcmpeqq xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Compare packed 64-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for equality, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := ( a[i+63:i] == b[i+63:i] ) ? 0xFFFFFFFFFFFFFFFF : 0
ENDFOR</div></div></div><div class="intrinsic AVX2" id="776"><div class="instruction">vpcmpeqq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cmpeq_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cmpeq_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpcmpeqq ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Compare packed 64-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for equality, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := ( a[i+63:i] == b[i+63:i] ) ? 0xFFFFFFFFFFFFFFFF : 0
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="783"><div class="instruction">pcmpeqb</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cmpeq_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cmpeq_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pcmpeqb xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for equality, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := ( a[i+7:i] == b[i+7:i] ) ? 0xFF : 0
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="784"><div class="instruction">vpcmpeqb</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cmpeq_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cmpeq_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpcmpeqb ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Compare packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for equality, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := ( a[i+7:i] == b[i+7:i] ) ? 0xFF : 0
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="815"><div class="instruction">cmppd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpeq_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpeq_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cmppd xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for equality, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := (a[i+63:i] == b[i+63:i]) ? 0xFFFFFFFFFFFFFFFF : 0
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic MMX" id="818"><div class="instruction">pcmpeqw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_cmpeq_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_cmpeq_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: pcmpeqw mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Compare packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for equality, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := ( a[i+15:i] == b[i+15:i] ) ? 0xFFFF : 0
ENDFOR</div></div></div><div class="intrinsic MMX" id="819"><div class="instruction">pcmpeqd</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_cmpeq_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_cmpeq_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: pcmpeqd mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Compare packed 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for equality, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*32
	dst[i+31:i] := ( a[i+31:i] == b[i+31:i] ) ? 0xFFFFFFFF : 0
ENDFOR</div></div></div><div class="intrinsic MMX" id="820"><div class="instruction">pcmpeqb</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_cmpeq_pi8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_cmpeq_pi8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: pcmpeqb mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Compare packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for equality, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := ( a[i+7:i] == b[i+7:i] ) ? 0xFF : 0
ENDFOR</div></div></div><div class="intrinsic SSE" id="821"><div class="instruction">cmpps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpeq_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpeq_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cmpps xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for equality, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := ( a[i+31:i] == b[i+31:i] ) ? 0xffffffff : 0
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="824"><div class="instruction">cmpsd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpeq_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpeq_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cmpsd xmm, xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare the lower double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for equality, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := (a[63:0] == b[63:0]) ? 0xFFFFFFFFFFFFFFFF : 0
dst[127:64] := a[127:64]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="825"><div class="instruction">cmpss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpeq_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpeq_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cmpss xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare the lower single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for equality, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := ( a[31:0] == b[31:0] ) ? 0xffffffff : 0
dst[127:32] := a[127:32]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE4_2" id="826"><div class="instruction">pcmpestri</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cmpestra</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">la</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">lb</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cmpestra</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">la</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">lb</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;nmmintrin.h&gt;<br>Instruction: pcmpestri xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.2</span></div><h1>Description</h1><div class="description">Compare packed strings in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> with lengths <span class="desc_var la">la</span> and <span class="desc_var lb">lb</span> using the control in <span class="desc_var imm8">imm8</span>, and returns 1 if <span class="desc_var b">b</span> did not contain a null character and the resulting mask was zero, and 0 otherwise.
	<br><span class="desc_var imm">imm</span> can be a combination of:<div class="desc_note">    _SIDD_UBYTE_OPS                // unsigned 8-bit characters
    _SIDD_UWORD_OPS                // unsigned 16-bit characters
    _SIDD_SBYTE_OPS                // signed 8-bit characters
    _SIDD_SWORD_OPS                // signed 16-bit characters
    _SIDD_CMP_EQUAL_ANY            // compare equal any
    _SIDD_CMP_RANGES               // compare ranges
    _SIDD_CMP_EQUAL_EACH           // compare equal each
    _SIDD_CMP_EQUAL_ORDERED        // compare equal ordered
    _SIDD_NEGATIVE_POLARITY        // negate results
    _SIDD_MASKED_NEGATIVE_POLARITY // negate results only before end of string
    _SIDD_LEAST_SIGNIFICANT        // index only: return last significant bit
    _SIDD_MOST_SIGNIFICANT         // index only: return most significant bit
    _SIDD_BIT_MASK                 // mask only: return bit mask
    _SIDD_UNIT_MASK                // mask only: return byte/word mask</div>
	</div><h1>Operation</h1><div class="operation">size := (imm8[0] ? 16 : 8) // 8 or 16-bit characters
UpperBound := (128 / size) - 1
// compare all characters
aInvalid := 0
bInvalid := 0
FOR i := 0 to UpperBound
	m := i*size
	FOR j := 0 to UpperBound
		n := j*size
		BoolRes[i][j] := (a[m+size-1:m] == b[n+size-1:n])
		
		// invalidate characters after EOS
		IF i == la
			aInvalid := 1
		FI
		IF j == lb
			bInvalid := 1
		FI
		
		// override comparisons for invalid characters
		CASE (imm8[3:2]) OF
		0:  // equal any
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			FI
		1:  // ranges
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			FI
		2:  // equal each
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 1
			FI
		3:  // equal ordered
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 1
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 1
			FI
		ESAC
	ENDFOR
ENDFOR
// aggregate results
CASE (imm8[3:2]) OF
0:  // equal any
	IntRes1 := 0
	FOR i := 0 to UpperBound
		FOR j := 0 to UpperBound
			IntRes1[i] := IntRes1[i] OR BoolRes[i][j]
		ENDFOR
	ENDFOR
1:  // ranges
	IntRes1 := 0
	FOR i := 0 to UpperBound
		FOR j := 0 to UpperBound, j += 2
			IntRes1[i] := IntRes1[i] OR (BoolRes[i][j] AND BoolRes[i][j+1])
		ENDFOR
	ENDFOR
2:  // equal each
	IntRes1 := 0
	FOR i := 0 to UpperBound
		IntRes1[i] := BoolRes[i][i]
	ENDFOR
3:  // equal ordered
	IntRes1 := (imm8[0] ? 0xFF : 0xFFFF)
	FOR i := 0 to UpperBound
		k := i
		FOR j := 0 to UpperBound-i
			IntRes1[i] := IntRes1[i] AND BoolRes[k][j]
			k := k+1
		ENDFOR
	ENDFOR
ESAC
// optionally negate results
FOR i := 0 to UpperBound
	IF imm8[4]
		IF imm8[5] // only negate valid
			IF i &gt;= lb // invalid, don't negate
				IntRes2[i] := IntRes1[i]
			ELSE // valid, negate
				IntRes2[i] := -1 XOR IntRes1[i]
			FI
		ELSE // negate all
			IntRes2[i] := -1 XOR IntRes1[i]
		FI
	ELSE // don't negate
		IntRes2[i] := IntRes1[i]
	FI
ENDFOR
// output
dst := (IntRes2 == 0) AND (lb &gt; UpperBound)</div></div></div><div class="intrinsic SSE4_2" id="827"><div class="instruction">pcmpestri</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cmpestrc</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">la</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">lb</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cmpestrc</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">la</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">lb</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;nmmintrin.h&gt;<br>Instruction: pcmpestri xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.2</span></div><h1>Description</h1><div class="description">Compare packed strings in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> with lengths <span class="desc_var la">la</span> and <span class="desc_var lb">lb</span> using the control in <span class="desc_var imm8">imm8</span>, and returns 1 if the resulting mask was non-zero, and 0 otherwise.
	<br><span class="desc_var imm">imm</span> can be a combination of:<div class="desc_note">    _SIDD_UBYTE_OPS                // unsigned 8-bit characters
    _SIDD_UWORD_OPS                // unsigned 16-bit characters
    _SIDD_SBYTE_OPS                // signed 8-bit characters
    _SIDD_SWORD_OPS                // signed 16-bit characters
    _SIDD_CMP_EQUAL_ANY            // compare equal any
    _SIDD_CMP_RANGES               // compare ranges
    _SIDD_CMP_EQUAL_EACH           // compare equal each
    _SIDD_CMP_EQUAL_ORDERED        // compare equal ordered
    _SIDD_NEGATIVE_POLARITY        // negate results
    _SIDD_MASKED_NEGATIVE_POLARITY // negate results only before end of string
    _SIDD_LEAST_SIGNIFICANT        // index only: return last significant bit
    _SIDD_MOST_SIGNIFICANT         // index only: return most significant bit
    _SIDD_BIT_MASK                 // mask only: return bit mask
    _SIDD_UNIT_MASK                // mask only: return byte/word mask</div>
	</div><h1>Operation</h1><div class="operation">size := (imm8[0] ? 16 : 8) // 8 or 16-bit characters
UpperBound := (128 / size) - 1
// compare all characters
aInvalid := 0
bInvalid := 0
FOR i := 0 to UpperBound
	m := i*size
	FOR j := 0 to UpperBound
		n := j*size
		BoolRes[i][j] := (a[m+size-1:m] == b[n+size-1:n])
		
		// invalidate characters after EOS
		IF i == la
			aInvalid := 1
		FI
		IF j == lb
			bInvalid := 1
		FI
		
		// override comparisons for invalid characters
		CASE (imm8[3:2]) OF
		0:  // equal any
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			FI
		1:  // ranges
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			FI
		2:  // equal each
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 1
			FI
		3:  // equal ordered
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 1
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 1
			FI
		ESAC
	ENDFOR
ENDFOR
// aggregate results
CASE (imm8[3:2]) OF
0:  // equal any
	IntRes1 := 0
	FOR i := 0 to UpperBound
		FOR j := 0 to UpperBound
			IntRes1[i] := IntRes1[i] OR BoolRes[i][j]
		ENDFOR
	ENDFOR
1:  // ranges
	IntRes1 := 0
	FOR i := 0 to UpperBound
		FOR j := 0 to UpperBound, j += 2
			IntRes1[i] := IntRes1[i] OR (BoolRes[i][j] AND BoolRes[i][j+1])
		ENDFOR
	ENDFOR
2:  // equal each
	IntRes1 := 0
	FOR i := 0 to UpperBound
		IntRes1[i] := BoolRes[i][i]
	ENDFOR
3:  // equal ordered
	IntRes1 := (imm8[0] ? 0xFF : 0xFFFF)
	FOR i := 0 to UpperBound
		k := i
		FOR j := 0 to UpperBound-i
			IntRes1[i] := IntRes1[i] AND BoolRes[k][j]
			k := k+1
		ENDFOR
	ENDFOR
ESAC
// optionally negate results
FOR i := 0 to UpperBound
	IF imm8[4]
		IF imm8[5] // only negate valid
			IF i &gt;= lb // invalid, don't negate
				IntRes2[i] := IntRes1[i]
			ELSE // valid, negate
				IntRes2[i] := -1 XOR IntRes1[i]
			FI
		ELSE // negate all
			IntRes2[i] := -1 XOR IntRes1[i]
		FI
	ELSE // don't negate
		IntRes2[i] := IntRes1[i]
	FI
ENDFOR
// output
dst := (IntRes2 != 0)</div></div></div><div class="intrinsic SSE4_2" id="828"><div class="instruction">pcmpestri</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cmpestri</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">la</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">lb</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cmpestri</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">la</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">lb</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;nmmintrin.h&gt;<br>Instruction: pcmpestri xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.2</span></div><h1>Description</h1><div class="description">Compare packed strings in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> with lengths <span class="desc_var la">la</span> and <span class="desc_var lb">lb</span> using the control in <span class="desc_var imm8">imm8</span>, and store the generated index in <span class="desc_var dst">dst</span>.
	<br><span class="desc_var imm">imm</span> can be a combination of:<div class="desc_note">    _SIDD_UBYTE_OPS                // unsigned 8-bit characters
    _SIDD_UWORD_OPS                // unsigned 16-bit characters
    _SIDD_SBYTE_OPS                // signed 8-bit characters
    _SIDD_SWORD_OPS                // signed 16-bit characters
    _SIDD_CMP_EQUAL_ANY            // compare equal any
    _SIDD_CMP_RANGES               // compare ranges
    _SIDD_CMP_EQUAL_EACH           // compare equal each
    _SIDD_CMP_EQUAL_ORDERED        // compare equal ordered
    _SIDD_NEGATIVE_POLARITY        // negate results
    _SIDD_MASKED_NEGATIVE_POLARITY // negate results only before end of string
    _SIDD_LEAST_SIGNIFICANT        // index only: return last significant bit
    _SIDD_MOST_SIGNIFICANT         // index only: return most significant bit
    _SIDD_BIT_MASK                 // mask only: return bit mask
    _SIDD_UNIT_MASK                // mask only: return byte/word mask</div>
	</div><h1>Operation</h1><div class="operation">size := (imm8[0] ? 16 : 8) // 8 or 16-bit characters
UpperBound := (128 / size) - 1
// compare all characters
aInvalid := 0
bInvalid := 0
FOR i := 0 to UpperBound
	m := i*size
	FOR j := 0 to UpperBound
		n := j*size
		BoolRes[i][j] := (a[m+size-1:m] == b[n+size-1:n])
		
		// invalidate characters after EOS
		IF i == la
			aInvalid := 1
		FI
		IF j == lb
			bInvalid := 1
		FI
		
		// override comparisons for invalid characters
		CASE (imm8[3:2]) OF
		0:  // equal any
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			FI
		1:  // ranges
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			FI
		2:  // equal each
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 1
			FI
		3:  // equal ordered
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 1
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 1
			FI
		ESAC
	ENDFOR
ENDFOR
// aggregate results
CASE (imm8[3:2]) OF
0:  // equal any
	IntRes1 := 0
	FOR i := 0 to UpperBound
		FOR j := 0 to UpperBound
			IntRes1[i] := IntRes1[i] OR BoolRes[i][j]
		ENDFOR
	ENDFOR
1:  // ranges
	IntRes1 := 0
	FOR i := 0 to UpperBound
		FOR j := 0 to UpperBound, j += 2
			IntRes1[i] := IntRes1[i] OR (BoolRes[i][j] AND BoolRes[i][j+1])
		ENDFOR
	ENDFOR
2:  // equal each
	IntRes1 := 0
	FOR i := 0 to UpperBound
		IntRes1[i] := BoolRes[i][i]
	ENDFOR
3:  // equal ordered
	IntRes1 := (imm8[0] ? 0xFF : 0xFFFF)
	FOR i := 0 to UpperBound
		k := i
		FOR j := 0 to UpperBound-i
			IntRes1[i] := IntRes1[i] AND BoolRes[k][j]
			k := k+1
		ENDFOR
	ENDFOR
ESAC
// optionally negate results
FOR i := 0 to UpperBound
	IF imm8[4]
		IF imm8[5] // only negate valid
			IF i &gt;= lb // invalid, don't negate
				IntRes2[i] := IntRes1[i]
			ELSE // valid, negate
				IntRes2[i] := -1 XOR IntRes1[i]
			FI
		ELSE // negate all
			IntRes2[i] := -1 XOR IntRes1[i]
		FI
	ELSE // don't negate
		IntRes2[i] := IntRes1[i]
	FI
ENDFOR
// output
IF imm8[6] // most significant bit
	tmp := UpperBound
	dst := tmp
	DO WHILE ((tmp &gt;= 0) AND a[tmp] == 0)
		tmp := tmp - 1
		dst := tmp
	OD
ELSE // least significant bit
	tmp := 0
	dst := tmp
	DO WHILE ((tmp &lt;= UpperBound) AND a[tmp] == 0)
		tmp := tmp + 1
		dst := tmp
	OD
FI</div></div></div><div class="intrinsic SSE4_2" id="829"><div class="instruction">pcmpestrm</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cmpestrm</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">la</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">lb</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cmpestrm</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">la</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">lb</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;nmmintrin.h&gt;<br>Instruction: pcmpestrm xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.2</span></div><h1>Description</h1><div class="description">Compare packed strings in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> with lengths <span class="desc_var la">la</span> and <span class="desc_var lb">lb</span> using the control in <span class="desc_var imm8">imm8</span>, and store the generated mask in <span class="desc_var dst">dst</span>.
	<br><span class="desc_var imm">imm</span> can be a combination of:<div class="desc_note">    _SIDD_UBYTE_OPS                // unsigned 8-bit characters
    _SIDD_UWORD_OPS                // unsigned 16-bit characters
    _SIDD_SBYTE_OPS                // signed 8-bit characters
    _SIDD_SWORD_OPS                // signed 16-bit characters
    _SIDD_CMP_EQUAL_ANY            // compare equal any
    _SIDD_CMP_RANGES               // compare ranges
    _SIDD_CMP_EQUAL_EACH           // compare equal each
    _SIDD_CMP_EQUAL_ORDERED        // compare equal ordered
    _SIDD_NEGATIVE_POLARITY        // negate results
    _SIDD_MASKED_NEGATIVE_POLARITY // negate results only before end of string
    _SIDD_LEAST_SIGNIFICANT        // index only: return last significant bit
    _SIDD_MOST_SIGNIFICANT         // index only: return most significant bit
    _SIDD_BIT_MASK                 // mask only: return bit mask
    _SIDD_UNIT_MASK                // mask only: return byte/word mask</div>
	</div><h1>Operation</h1><div class="operation">size := (imm8[0] ? 16 : 8) // 8 or 16-bit characters
UpperBound := (128 / size) - 1
// compare all characters
aInvalid := 0
bInvalid := 0
FOR i := 0 to UpperBound
	m := i*size
	FOR j := 0 to UpperBound
		n := j*size
		BoolRes[i][j] := (a[m+size-1:m] == b[n+size-1:n])
		
		// invalidate characters after EOS
		IF i == la
			aInvalid := 1
		FI
		IF j == lb
			bInvalid := 1
		FI
		
		// override comparisons for invalid characters
		CASE (imm8[3:2]) OF
		0:  // equal any
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			FI
		1:  // ranges
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			FI
		2:  // equal each
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 1
			FI
		3:  // equal ordered
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 1
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 1
			FI
		ESAC
	ENDFOR
ENDFOR
// aggregate results
CASE (imm8[3:2]) OF
0:  // equal any
	IntRes1 := 0
	FOR i := 0 to UpperBound
		FOR j := 0 to UpperBound
			IntRes1[i] := IntRes1[i] OR BoolRes[i][j]
		ENDFOR
	ENDFOR
1:  // ranges
	IntRes1 := 0
	FOR i := 0 to UpperBound
		FOR j := 0 to UpperBound, j += 2
			IntRes1[i] := IntRes1[i] OR (BoolRes[i][j] AND BoolRes[i][j+1])
		ENDFOR
	ENDFOR
2:  // equal each
	IntRes1 := 0
	FOR i := 0 to UpperBound
		IntRes1[i] := BoolRes[i][i]
	ENDFOR
3:  // equal ordered
	IntRes1 := (imm8[0] ? 0xFF : 0xFFFF)
	FOR i := 0 to UpperBound
		k := i
		FOR j := 0 to UpperBound-i
			IntRes1[i] := IntRes1[i] AND BoolRes[k][j]
			k := k+1
		ENDFOR
	ENDFOR
ESAC
// optionally negate results
FOR i := 0 to UpperBound
	IF imm8[4]
		IF imm8[5] // only negate valid
			IF i &gt;= lb // invalid, don't negate
				IntRes2[i] := IntRes1[i]
			ELSE // valid, negate
				IntRes2[i] := -1 XOR IntRes1[i]
			FI
		ELSE // negate all
			IntRes2[i] := -1 XOR IntRes1[i]
		FI
	ELSE // don't negate
		IntRes2[i] := IntRes1[i]
	FI
ENDFOR
// output
IF imm8[6] // byte / word mask
	FOR i := 0 to UpperBound
		j := i*size
		IF IntRes2[i]
			dst[j+size-1:j] := (imm8[0] ? 0xFF : 0xFFFF)
		ELSE
			dst[j+size-1:j] := 0
		FI
	ENDFOR
ELSE // bit mask
	dst[UpperBound:0] := IntRes2[UpperBound:0]
	dst[127:UpperBound+1] := 0
FI</div></div></div><div class="intrinsic SSE4_2" id="830"><div class="instruction">pcmpestri</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cmpestro</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">la</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">lb</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cmpestro</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">la</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">lb</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;nmmintrin.h&gt;<br>Instruction: pcmpestri xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.2</span></div><h1>Description</h1><div class="description">Compare packed strings in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> with lengths <span class="desc_var la">la</span> and <span class="desc_var lb">lb</span> using the control in <span class="desc_var imm8">imm8</span>, and returns bit 0 of the resulting bit mask.
	<br><span class="desc_var imm">imm</span> can be a combination of:<div class="desc_note">    _SIDD_UBYTE_OPS                // unsigned 8-bit characters
    _SIDD_UWORD_OPS                // unsigned 16-bit characters
    _SIDD_SBYTE_OPS                // signed 8-bit characters
    _SIDD_SWORD_OPS                // signed 16-bit characters
    _SIDD_CMP_EQUAL_ANY            // compare equal any
    _SIDD_CMP_RANGES               // compare ranges
    _SIDD_CMP_EQUAL_EACH           // compare equal each
    _SIDD_CMP_EQUAL_ORDERED        // compare equal ordered
    _SIDD_NEGATIVE_POLARITY        // negate results
    _SIDD_MASKED_NEGATIVE_POLARITY // negate results only before end of string
    _SIDD_LEAST_SIGNIFICANT        // index only: return last significant bit
    _SIDD_MOST_SIGNIFICANT         // index only: return most significant bit
    _SIDD_BIT_MASK                 // mask only: return bit mask
    _SIDD_UNIT_MASK                // mask only: return byte/word mask</div>
	</div><h1>Operation</h1><div class="operation">size := (imm8[0] ? 16 : 8) // 8 or 16-bit characters
UpperBound := (128 / size) - 1
// compare all characters
aInvalid := 0
bInvalid := 0
FOR i := 0 to UpperBound
	m := i*size
	FOR j := 0 to UpperBound
		n := j*size
		BoolRes[i][j] := (a[m+size-1:m] == b[n+size-1:n])
		
		// invalidate characters after EOS
		IF i == la
			aInvalid := 1
		FI
		IF j == lb
			bInvalid := 1
		FI
		
		// override comparisons for invalid characters
		CASE (imm8[3:2]) OF
		0:  // equal any
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			FI
		1:  // ranges
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			FI
		2:  // equal each
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 1
			FI
		3:  // equal ordered
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 1
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 1
			FI
		ESAC
	ENDFOR
ENDFOR
// aggregate results
CASE (imm8[3:2]) OF
0:  // equal any
	IntRes1 := 0
	FOR i := 0 to UpperBound
		FOR j := 0 to UpperBound
			IntRes1[i] := IntRes1[i] OR BoolRes[i][j]
		ENDFOR
	ENDFOR
1:  // ranges
	IntRes1 := 0
	FOR i := 0 to UpperBound
		FOR j := 0 to UpperBound, j += 2
			IntRes1[i] := IntRes1[i] OR (BoolRes[i][j] AND BoolRes[i][j+1])
		ENDFOR
	ENDFOR
2:  // equal each
	IntRes1 := 0
	FOR i := 0 to UpperBound
		IntRes1[i] := BoolRes[i][i]
	ENDFOR
3:  // equal ordered
	IntRes1 := (imm8[0] ? 0xFF : 0xFFFF)
	FOR i := 0 to UpperBound
		k := i
		FOR j := 0 to UpperBound-i
			IntRes1[i] := IntRes1[i] AND BoolRes[k][j]
			k := k+1
		ENDFOR
	ENDFOR
ESAC
// optionally negate results
FOR i := 0 to UpperBound
	IF imm8[4]
		IF imm8[5] // only negate valid
			IF i &gt;= lb // invalid, don't negate
				IntRes2[i] := IntRes1[i]
			ELSE // valid, negate
				IntRes2[i] := -1 XOR IntRes1[i]
			FI
		ELSE // negate all
			IntRes2[i] := -1 XOR IntRes1[i]
		FI
	ELSE // don't negate
		IntRes2[i] := IntRes1[i]
	FI
ENDFOR
// output
dst := IntRes2[0]</div></div></div><div class="intrinsic SSE4_2" id="831"><div class="instruction">pcmpestri</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cmpestrs</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">la</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">lb</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cmpestrs</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">la</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">lb</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;nmmintrin.h&gt;<br>Instruction: pcmpestri xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.2</span></div><h1>Description</h1><div class="description">Compare packed strings in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> with lengths <span class="desc_var la">la</span> and <span class="desc_var lb">lb</span> using the control in <span class="desc_var imm8">imm8</span>, and returns 1 if any character in <span class="desc_var a">a</span> was null, and 0 otherwise.
	<br><span class="desc_var imm">imm</span> can be a combination of:<div class="desc_note">    _SIDD_UBYTE_OPS                // unsigned 8-bit characters
    _SIDD_UWORD_OPS                // unsigned 16-bit characters
    _SIDD_SBYTE_OPS                // signed 8-bit characters
    _SIDD_SWORD_OPS                // signed 16-bit characters
    _SIDD_CMP_EQUAL_ANY            // compare equal any
    _SIDD_CMP_RANGES               // compare ranges
    _SIDD_CMP_EQUAL_EACH           // compare equal each
    _SIDD_CMP_EQUAL_ORDERED        // compare equal ordered
    _SIDD_NEGATIVE_POLARITY        // negate results
    _SIDD_MASKED_NEGATIVE_POLARITY // negate results only before end of string
    _SIDD_LEAST_SIGNIFICANT        // index only: return last significant bit
    _SIDD_MOST_SIGNIFICANT         // index only: return most significant bit
    _SIDD_BIT_MASK                 // mask only: return bit mask
    _SIDD_UNIT_MASK                // mask only: return byte/word mask</div>
	</div><h1>Operation</h1><div class="operation">size := (imm8[0] ? 16 : 8) // 8 or 16-bit characters
UpperBound := (128 / size) - 1
dst := (la &lt;= UpperBound)</div></div></div><div class="intrinsic SSE4_2" id="832"><div class="instruction">pcmpestri</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cmpestrz</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">la</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">lb</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cmpestrz</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">la</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">lb</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;nmmintrin.h&gt;<br>Instruction: pcmpestri xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.2</span></div><h1>Description</h1><div class="description">Compare packed strings in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> with lengths <span class="desc_var la">la</span> and <span class="desc_var lb">lb</span> using the control in <span class="desc_var imm8">imm8</span>, and returns 1 if any character in <span class="desc_var b">b</span> was null, and 0 otherwise.
	<br><span class="desc_var imm">imm</span> can be a combination of:<div class="desc_note">    _SIDD_UBYTE_OPS                // unsigned 8-bit characters
    _SIDD_UWORD_OPS                // unsigned 16-bit characters
    _SIDD_SBYTE_OPS                // signed 8-bit characters
    _SIDD_SWORD_OPS                // signed 16-bit characters
    _SIDD_CMP_EQUAL_ANY            // compare equal any
    _SIDD_CMP_RANGES               // compare ranges
    _SIDD_CMP_EQUAL_EACH           // compare equal each
    _SIDD_CMP_EQUAL_ORDERED        // compare equal ordered
    _SIDD_NEGATIVE_POLARITY        // negate results
    _SIDD_MASKED_NEGATIVE_POLARITY // negate results only before end of string
    _SIDD_LEAST_SIGNIFICANT        // index only: return last significant bit
    _SIDD_MOST_SIGNIFICANT         // index only: return most significant bit
    _SIDD_BIT_MASK                 // mask only: return bit mask
    _SIDD_UNIT_MASK                // mask only: return byte/word mask</div>
	</div><h1>Operation</h1><div class="operation">size := (imm8[0] ? 16 : 8) // 8 or 16-bit characters
UpperBound := (128 / size) - 1
dst := (lb &lt;= UpperBound)</div></div></div><div class="intrinsic SSE2" id="881"><div class="instruction">cmppd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpge_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpge_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cmppd xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for greater-than-or-equal, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := (a[i+63:i] &gt;= b[i+63:i]) ? 0xFFFFFFFFFFFFFFFF : 0
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="882"><div class="instruction">cmpps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpge_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpge_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cmpps xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for greater-than-or-equal, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := ( a[i+31:i] &gt;= b[i+31:i] ) ? 0xffffffff : 0
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="883"><div class="instruction">cmpsd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpge_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpge_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cmpsd xmm, xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare the lower double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for greater-than-or-equal, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := (a[63:0] &gt;= b[63:0]) ? 0xFFFFFFFFFFFFFFFF : 0
dst[127:64] := a[127:64]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="884"><div class="instruction">cmpss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpge_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpge_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cmpss xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare the lower single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for greater-than-or-equal, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := ( a[31:0] &gt;= b[31:0] ) ? 0xffffffff : 0
dst[127:32] := a[127:32]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="885"><div class="instruction">pcmpgtw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cmpgt_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cmpgt_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pcmpgtw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for greater-than, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := ( a[i+15:i] &gt; b[i+15:i] ) ? 0xFFFF : 0
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="886"><div class="instruction">vpcmpgtw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cmpgt_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cmpgt_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpcmpgtw ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Compare packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for greater-than, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := ( a[i+15:i] &gt; b[i+15:i] ) ? 0xFFFF : 0
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="893"><div class="instruction">pcmpgtd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cmpgt_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cmpgt_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pcmpgtd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare packed 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for greater-than, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := ( a[i+31:i] &gt; b[i+31:i] ) ? 0xFFFFFFFF : 0
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="894"><div class="instruction">vpcmpgtd</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cmpgt_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cmpgt_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpcmpgtd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Compare packed 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for greater-than, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := ( a[i+31:i] &gt; b[i+31:i] ) ? 0xFFFFFFFF : 0
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE4_2" id="901"><div class="instruction">pcmpgtq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cmpgt_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cmpgt_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;nmmintrin.h&gt;<br>Instruction: pcmpgtq xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE4.2</span></div><h1>Description</h1><div class="description">Compare packed 64-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for greater-than, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := ( a[i+63:i] &gt; b[i+63:i] ) ? 0xFFFFFFFFFFFFFFFF : 0
ENDFOR</div></div></div><div class="intrinsic AVX2" id="902"><div class="instruction">vpcmpgtq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cmpgt_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cmpgt_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpcmpgtq ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Compare packed 64-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for greater-than, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := ( a[i+63:i] &gt; b[i+63:i] ) ? 0xFFFFFFFFFFFFFFFF : 0
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>1</td></tr><tr><td>Broadwell</td><td>5</td><td>1</td></tr><tr><td>Haswell</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="909"><div class="instruction">pcmpgtb</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cmpgt_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cmpgt_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pcmpgtb xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for greater-than, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := ( a[i+7:i] &gt; b[i+7:i] ) ? 0xFF : 0
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="910"><div class="instruction">vpcmpgtb</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cmpgt_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cmpgt_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpcmpgtb ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Compare packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for greater-than, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := ( a[i+7:i] &gt; b[i+7:i] ) ? 0xFF : 0
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="941"><div class="instruction">cmppd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpgt_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpgt_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cmppd xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for greater-than, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := (a[i+63:i] &gt; b[i+63:i]) ? 0xFFFFFFFFFFFFFFFF : 0
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic MMX" id="942"><div class="instruction">pcmpgtw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_cmpgt_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_cmpgt_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: pcmpgtw mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Compare packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for greater-than, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := ( a[i+15:i] &gt; b[i+15:i] ) ? 0xFFFF : 0
ENDFOR</div></div></div><div class="intrinsic MMX" id="943"><div class="instruction">pcmpgtd</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_cmpgt_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_cmpgt_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: pcmpgtd mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Compare packed 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for greater-than, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*32
	dst[i+31:i] := ( a[i+31:i] &gt; b[i+31:i] ) ? 0xFFFFFFFF : 0
ENDFOR</div></div></div><div class="intrinsic MMX" id="944"><div class="instruction">pcmpgtb</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_cmpgt_pi8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_cmpgt_pi8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: pcmpgtb mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Compare packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for greater-than, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := ( a[i+7:i] &gt; b[i+7:i] ) ? 0xFF : 0
ENDFOR</div></div></div><div class="intrinsic SSE" id="945"><div class="instruction">cmpps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpgt_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpgt_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cmpps xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for greater-than, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := ( a[i+31:i] &gt; b[i+31:i] ) ? 0xffffffff : 0
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="946"><div class="instruction">cmpsd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpgt_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpgt_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cmpsd xmm, xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare the lower double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for greater-than, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := (a[63:0] &gt; b[63:0]) ? 0xFFFFFFFFFFFFFFFF : 0
dst[127:64] := a[127:64]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="947"><div class="instruction">cmpss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpgt_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpgt_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cmpss xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare the lower single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for greater-than, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := ( a[31:0] &gt; b[31:0] ) ? 0xffffffff : 0
dst[127:32] := a[127:32]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE4_2" id="948"><div class="instruction">pcmpistri</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cmpistra</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cmpistra</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;nmmintrin.h&gt;<br>Instruction: pcmpistri xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.2</span></div><h1>Description</h1><div class="description">Compare packed strings with implicit lengths in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using the control in <span class="desc_var imm8">imm8</span>, and returns 1 if <span class="desc_var b">b</span> did not contain a null character and the resulting mask was zero, and 0 otherwise.
	<br><span class="desc_var imm">imm</span> can be a combination of:<div class="desc_note">    _SIDD_UBYTE_OPS                // unsigned 8-bit characters
    _SIDD_UWORD_OPS                // unsigned 16-bit characters
    _SIDD_SBYTE_OPS                // signed 8-bit characters
    _SIDD_SWORD_OPS                // signed 16-bit characters
    _SIDD_CMP_EQUAL_ANY            // compare equal any
    _SIDD_CMP_RANGES               // compare ranges
    _SIDD_CMP_EQUAL_EACH           // compare equal each
    _SIDD_CMP_EQUAL_ORDERED        // compare equal ordered
    _SIDD_NEGATIVE_POLARITY        // negate results
    _SIDD_MASKED_NEGATIVE_POLARITY // negate results only before end of string
    _SIDD_LEAST_SIGNIFICANT        // index only: return last significant bit
    _SIDD_MOST_SIGNIFICANT         // index only: return most significant bit
    _SIDD_BIT_MASK                 // mask only: return bit mask
    _SIDD_UNIT_MASK                // mask only: return byte/word mask</div>
	</div><h1>Operation</h1><div class="operation">size := (imm8[0] ? 16 : 8) // 8 or 16-bit characters
UpperBound := (128 / size) - 1
// compare all characters
aInvalid := 0
bInvalid := 0
FOR i := 0 to UpperBound
	m := i*size
	FOR j := 0 to UpperBound
		n := j*size
		BoolRes[i][j] := (a[m+size-1:m] == b[n+size-1:n])
		
		// invalidate characters after EOS
		IF a[m+size-1:m] == 0
			aInvalid := 1
		FI
		IF b[n+size-1:n] == 0
			bInvalid := 1
		FI
		
		// override comparisons for invalid characters
		CASE (imm8[3:2]) OF
		0:  // equal any
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			FI
		1:  // ranges
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			FI
		2:  // equal each
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 1
			FI
		3:  // equal ordered
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 1
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 1
			FI
		ESAC
	ENDFOR
ENDFOR
// aggregate results
CASE (imm8[3:2]) OF
0:  // equal any
	IntRes1 := 0
	FOR i := 0 to UpperBound
		FOR j := 0 to UpperBound
			IntRes1[i] := IntRes1[i] OR BoolRes[i][j]
		ENDFOR
	ENDFOR
1:  // ranges
	IntRes1 := 0
	FOR i := 0 to UpperBound
		FOR j := 0 to UpperBound, j += 2
			IntRes1[i] := IntRes1[i] OR (BoolRes[i][j] AND BoolRes[i][j+1])
		ENDFOR
	ENDFOR
2:  // equal each
	IntRes1 := 0
	FOR i := 0 to UpperBound
		IntRes1[i] := BoolRes[i][i]
	ENDFOR
3:  // equal ordered
	IntRes1 := (imm8[0] ? 0xFF : 0xFFFF)
	FOR i := 0 to UpperBound
		k := i
		FOR j := 0 to UpperBound-i
			IntRes1[i] := IntRes1[i] AND BoolRes[k][j]
			k := k+1
		ENDFOR
	ENDFOR
ESAC
// optionally negate results
bInvalid := 0
FOR i := 0 to UpperBound
	IF imm8[4]
		IF imm8[5] // only negate valid
			IF b[n+size-1:n] == 0
				bInvalid := 1
			FI
			IF bInvalid // invalid, don't negate
				IntRes2[i] := IntRes1[i]
			ELSE // valid, negate
				IntRes2[i] := -1 XOR IntRes1[i]
			FI
		ELSE // negate all
			IntRes2[i] := -1 XOR IntRes1[i]
		FI
	ELSE // don't negate
		IntRes2[i] := IntRes1[i]
	FI
ENDFOR
// output
dst := (IntRes2 == 0) AND bInvalid</div></div></div><div class="intrinsic SSE4_2" id="949"><div class="instruction">pcmpistri</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cmpistrc</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cmpistrc</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;nmmintrin.h&gt;<br>Instruction: pcmpistri xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.2</span></div><h1>Description</h1><div class="description">Compare packed strings with implicit lengths in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using the control in <span class="desc_var imm8">imm8</span>, and returns 1 if the resulting mask was non-zero, and 0 otherwise.
	<br><span class="desc_var imm">imm</span> can be a combination of:<div class="desc_note">    _SIDD_UBYTE_OPS                // unsigned 8-bit characters
    _SIDD_UWORD_OPS                // unsigned 16-bit characters
    _SIDD_SBYTE_OPS                // signed 8-bit characters
    _SIDD_SWORD_OPS                // signed 16-bit characters
    _SIDD_CMP_EQUAL_ANY            // compare equal any
    _SIDD_CMP_RANGES               // compare ranges
    _SIDD_CMP_EQUAL_EACH           // compare equal each
    _SIDD_CMP_EQUAL_ORDERED        // compare equal ordered
    _SIDD_NEGATIVE_POLARITY        // negate results
    _SIDD_MASKED_NEGATIVE_POLARITY // negate results only before end of string
    _SIDD_LEAST_SIGNIFICANT        // index only: return last significant bit
    _SIDD_MOST_SIGNIFICANT         // index only: return most significant bit
    _SIDD_BIT_MASK                 // mask only: return bit mask
    _SIDD_UNIT_MASK                // mask only: return byte/word mask</div>
	</div><h1>Operation</h1><div class="operation">size := (imm8[0] ? 16 : 8) // 8 or 16-bit characters
UpperBound := (128 / size) - 1
// compare all characters
aInvalid := 0
bInvalid := 0
FOR i := 0 to UpperBound
	m := i*size
	FOR j := 0 to UpperBound
		n := j*size
		BoolRes[i][j] := (a[m+size-1:m] == b[n+size-1:n])
		
		// invalidate characters after EOS
		IF a[m+size-1:m] == 0
			aInvalid := 1
		FI
		IF b[n+size-1:n] == 0
			bInvalid := 1
		FI
		
		// override comparisons for invalid characters
		CASE (imm8[3:2]) OF
		0:  // equal any
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			FI
		1:  // ranges
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			FI
		2:  // equal each
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 1
			FI
		3:  // equal ordered
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 1
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 1
			FI
		ESAC
	ENDFOR
ENDFOR
// aggregate results
CASE (imm8[3:2]) OF
0:  // equal any
	IntRes1 := 0
	FOR i := 0 to UpperBound
		FOR j := 0 to UpperBound
			IntRes1[i] := IntRes1[i] OR BoolRes[i][j]
		ENDFOR
	ENDFOR
1:  // ranges
	IntRes1 := 0
	FOR i := 0 to UpperBound
		FOR j := 0 to UpperBound, j += 2
			IntRes1[i] := IntRes1[i] OR (BoolRes[i][j] AND BoolRes[i][j+1])
		ENDFOR
	ENDFOR
2:  // equal each
	IntRes1 := 0
	FOR i := 0 to UpperBound
		IntRes1[i] := BoolRes[i][i]
	ENDFOR
3:  // equal ordered
	IntRes1 := (imm8[0] ? 0xFF : 0xFFFF)
	FOR i := 0 to UpperBound
		k := i
		FOR j := 0 to UpperBound-i
			IntRes1[i] := IntRes1[i] AND BoolRes[k][j]
			k := k+1
		ENDFOR
	ENDFOR
ESAC
// optionally negate results
bInvalid := 0
FOR i := 0 to UpperBound
	IF imm8[4]
		IF imm8[5] // only negate valid
			IF b[n+size-1:n] == 0
				bInvalid := 1
			FI
			IF bInvalid // invalid, don't negate
				IntRes2[i] := IntRes1[i]
			ELSE // valid, negate
				IntRes2[i] := -1 XOR IntRes1[i]
			FI
		ELSE // negate all
			IntRes2[i] := -1 XOR IntRes1[i]
		FI
	ELSE // don't negate
		IntRes2[i] := IntRes1[i]
	FI
ENDFOR
// output
dst := (IntRes2 != 0)</div></div></div><div class="intrinsic SSE4_2" id="950"><div class="instruction">pcmpistri</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cmpistri</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cmpistri</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;nmmintrin.h&gt;<br>Instruction: pcmpistri xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.2</span></div><h1>Description</h1><div class="description">Compare packed strings with implicit lengths in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using the control in <span class="desc_var imm8">imm8</span>, and store the generated index in <span class="desc_var dst">dst</span>.
	<br><span class="desc_var imm">imm</span> can be a combination of:<div class="desc_note">    _SIDD_UBYTE_OPS                // unsigned 8-bit characters
    _SIDD_UWORD_OPS                // unsigned 16-bit characters
    _SIDD_SBYTE_OPS                // signed 8-bit characters
    _SIDD_SWORD_OPS                // signed 16-bit characters
    _SIDD_CMP_EQUAL_ANY            // compare equal any
    _SIDD_CMP_RANGES               // compare ranges
    _SIDD_CMP_EQUAL_EACH           // compare equal each
    _SIDD_CMP_EQUAL_ORDERED        // compare equal ordered
    _SIDD_NEGATIVE_POLARITY        // negate results
    _SIDD_MASKED_NEGATIVE_POLARITY // negate results only before end of string
    _SIDD_LEAST_SIGNIFICANT        // index only: return last significant bit
    _SIDD_MOST_SIGNIFICANT         // index only: return most significant bit
    _SIDD_BIT_MASK                 // mask only: return bit mask
    _SIDD_UNIT_MASK                // mask only: return byte/word mask</div>
	</div><h1>Operation</h1><div class="operation">size := (imm8[0] ? 16 : 8) // 8 or 16-bit characters
UpperBound := (128 / size) - 1
// compare all characters
aInvalid := 0
bInvalid := 0
FOR i := 0 to UpperBound
	m := i*size
	FOR j := 0 to UpperBound
		n := j*size
		BoolRes[i][j] := (a[m+size-1:m] == b[n+size-1:n])
		
		// invalidate characters after EOS
		IF a[m+size-1:m] == 0
			aInvalid := 1
		FI
		IF b[n+size-1:n] == 0
			bInvalid := 1
		FI
		
		// override comparisons for invalid characters
		CASE (imm8[3:2]) OF
		0:  // equal any
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			FI
		1:  // ranges
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			FI
		2:  // equal each
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 1
			FI
		3:  // equal ordered
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 1
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 1
			FI
		ESAC
	ENDFOR
ENDFOR
// aggregate results
CASE (imm8[3:2]) OF
0:  // equal any
	IntRes1 := 0
	FOR i := 0 to UpperBound
		FOR j := 0 to UpperBound
			IntRes1[i] := IntRes1[i] OR BoolRes[i][j]
		ENDFOR
	ENDFOR
1:  // ranges
	IntRes1 := 0
	FOR i := 0 to UpperBound
		FOR j := 0 to UpperBound, j += 2
			IntRes1[i] := IntRes1[i] OR (BoolRes[i][j] AND BoolRes[i][j+1])
		ENDFOR
	ENDFOR
2:  // equal each
	IntRes1 := 0
	FOR i := 0 to UpperBound
		IntRes1[i] := BoolRes[i][i]
	ENDFOR
3:  // equal ordered
	IntRes1 := (imm8[0] ? 0xFF : 0xFFFF)
	FOR i := 0 to UpperBound
		k := i
		FOR j := 0 to UpperBound-i
			IntRes1[i] := IntRes1[i] AND BoolRes[k][j]
			k := k+1
		ENDFOR
	ENDFOR
ESAC
// optionally negate results
bInvalid := 0
FOR i := 0 to UpperBound
	IF imm8[4]
		IF imm8[5] // only negate valid
			IF b[n+size-1:n] == 0
				bInvalid := 1
			FI
			IF bInvalid // invalid, don't negate
				IntRes2[i] := IntRes1[i]
			ELSE // valid, negate
				IntRes2[i] := -1 XOR IntRes1[i]
			FI
		ELSE // negate all
			IntRes2[i] := -1 XOR IntRes1[i]
		FI
	ELSE // don't negate
		IntRes2[i] := IntRes1[i]
	FI
ENDFOR
// output
IF imm8[6] // most significant bit
	tmp := UpperBound
	dst := tmp
	DO WHILE ((tmp &gt;= 0) AND a[tmp] == 0)
		tmp := tmp - 1
		dst := tmp
	OD
ELSE // least significant bit
	tmp := 0
	dst := tmp
	DO WHILE ((tmp &lt;= UpperBound) AND a[tmp] == 0)
		tmp := tmp + 1
		dst := tmp
	OD
FI</div></div></div><div class="intrinsic SSE4_2" id="951"><div class="instruction">pcmpistrm</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cmpistrm</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cmpistrm</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;nmmintrin.h&gt;<br>Instruction: pcmpistrm xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.2</span></div><h1>Description</h1><div class="description">Compare packed strings with implicit lengths in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using the control in <span class="desc_var imm8">imm8</span>, and store the generated mask in <span class="desc_var dst">dst</span>.
	<br><span class="desc_var imm">imm</span> can be a combination of:<div class="desc_note">    _SIDD_UBYTE_OPS                // unsigned 8-bit characters
    _SIDD_UWORD_OPS                // unsigned 16-bit characters
    _SIDD_SBYTE_OPS                // signed 8-bit characters
    _SIDD_SWORD_OPS                // signed 16-bit characters
    _SIDD_CMP_EQUAL_ANY            // compare equal any
    _SIDD_CMP_RANGES               // compare ranges
    _SIDD_CMP_EQUAL_EACH           // compare equal each
    _SIDD_CMP_EQUAL_ORDERED        // compare equal ordered
    _SIDD_NEGATIVE_POLARITY        // negate results
    _SIDD_MASKED_NEGATIVE_POLARITY // negate results only before end of string
    _SIDD_LEAST_SIGNIFICANT        // index only: return last significant bit
    _SIDD_MOST_SIGNIFICANT         // index only: return most significant bit
    _SIDD_BIT_MASK                 // mask only: return bit mask
    _SIDD_UNIT_MASK                // mask only: return byte/word mask</div>
	</div><h1>Operation</h1><div class="operation">size := (imm8[0] ? 16 : 8) // 8 or 16-bit characters
UpperBound := (128 / size) - 1
// compare all characters
aInvalid := 0
bInvalid := 0
FOR i := 0 to UpperBound
	m := i*size
	FOR j := 0 to UpperBound
		n := j*size
		BoolRes[i][j] := (a[m+size-1:m] == b[n+size-1:n])
		
		// invalidate characters after EOS
		IF a[m+size-1:m] == 0
			aInvalid := 1
		FI
		IF b[n+size-1:n] == 0
			bInvalid := 1
		FI
		
		// override comparisons for invalid characters
		CASE (imm8[3:2]) OF
		0:  // equal any
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			FI
		1:  // ranges
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			FI
		2:  // equal each
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 1
			FI
		3:  // equal ordered
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 1
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 1
			FI
		ESAC
	ENDFOR
ENDFOR
// aggregate results
CASE (imm8[3:2]) OF
0:  // equal any
	IntRes1 := 0
	FOR i := 0 to UpperBound
		FOR j := 0 to UpperBound
			IntRes1[i] := IntRes1[i] OR BoolRes[i][j]
		ENDFOR
	ENDFOR
1:  // ranges
	IntRes1 := 0
	FOR i := 0 to UpperBound
		FOR j := 0 to UpperBound, j += 2
			IntRes1[i] := IntRes1[i] OR (BoolRes[i][j] AND BoolRes[i][j+1])
		ENDFOR
	ENDFOR
2:  // equal each
	IntRes1 := 0
	FOR i := 0 to UpperBound
		IntRes1[i] := BoolRes[i][i]
	ENDFOR
3:  // equal ordered
	IntRes1 := (imm8[0] ? 0xFF : 0xFFFF)
	FOR i := 0 to UpperBound
		k := i
		FOR j := 0 to UpperBound-i
			IntRes1[i] := IntRes1[i] AND BoolRes[k][j]
			k := k+1
		ENDFOR
	ENDFOR
ESAC
// optionally negate results
bInvalid := 0
FOR i := 0 to UpperBound
	IF imm8[4]
		IF imm8[5] // only negate valid
			IF b[n+size-1:n] == 0
				bInvalid := 1
			FI
			IF bInvalid // invalid, don't negate
				IntRes2[i] := IntRes1[i]
			ELSE // valid, negate
				IntRes2[i] := -1 XOR IntRes1[i]
			FI
		ELSE // negate all
			IntRes2[i] := -1 XOR IntRes1[i]
		FI
	ELSE // don't negate
		IntRes2[i] := IntRes1[i]
	FI
ENDFOR
// output
IF imm8[6] // byte / word mask
	FOR i := 0 to UpperBound
		j := i*size
		IF IntRes2[i]
			dst[j+size-1:j] := (imm8[0] ? 0xFF : 0xFFFF)
		ELSE
			dst[j+size-1:j] := 0
		FI
	ENDFOR
ELSE // bit mask
	dst[UpperBound:0] := IntRes2[UpperBound:0]
	dst[127:UpperBound+1] := 0
FI</div></div></div><div class="intrinsic SSE4_2" id="952"><div class="instruction">pcmpistri</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cmpistro</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cmpistro</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;nmmintrin.h&gt;<br>Instruction: pcmpistri xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.2</span></div><h1>Description</h1><div class="description">Compare packed strings with implicit lengths in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using the control in <span class="desc_var imm8">imm8</span>, and returns bit 0 of the resulting bit mask.
	<br><span class="desc_var imm">imm</span> can be a combination of:<div class="desc_note">    _SIDD_UBYTE_OPS                // unsigned 8-bit characters
    _SIDD_UWORD_OPS                // unsigned 16-bit characters
    _SIDD_SBYTE_OPS                // signed 8-bit characters
    _SIDD_SWORD_OPS                // signed 16-bit characters
    _SIDD_CMP_EQUAL_ANY            // compare equal any
    _SIDD_CMP_RANGES               // compare ranges
    _SIDD_CMP_EQUAL_EACH           // compare equal each
    _SIDD_CMP_EQUAL_ORDERED        // compare equal ordered
    _SIDD_NEGATIVE_POLARITY        // negate results
    _SIDD_MASKED_NEGATIVE_POLARITY // negate results only before end of string
    _SIDD_LEAST_SIGNIFICANT        // index only: return last significant bit
    _SIDD_MOST_SIGNIFICANT         // index only: return most significant bit
    _SIDD_BIT_MASK                 // mask only: return bit mask
    _SIDD_UNIT_MASK                // mask only: return byte/word mask</div>
	</div><h1>Operation</h1><div class="operation">size := (imm8[0] ? 16 : 8) // 8 or 16-bit characters
UpperBound := (128 / size) - 1
// compare all characters
aInvalid := 0
bInvalid := 0
FOR i := 0 to UpperBound
	m := i*size
	FOR j := 0 to UpperBound
		n := j*size
		BoolRes[i][j] := (a[m+size-1:m] == b[n+size-1:n])
		
		// invalidate characters after EOS
		IF a[m+size-1:m] == 0
			aInvalid := 1
		FI
		IF b[n+size-1:n] == 0
			bInvalid := 1
		FI
		
		// override comparisons for invalid characters
		CASE (imm8[3:2]) OF
		0:  // equal any
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			FI
		1:  // ranges
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			FI
		2:  // equal each
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 1
			FI
		3:  // equal ordered
			IF (!aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 0
			ELSE IF (aInvalid &amp;&amp; !bInvalid)
				BoolRes[i][j] := 1
			ELSE IF (aInvalid &amp;&amp; bInvalid)
				BoolRes[i][j] := 1
			FI
		ESAC
	ENDFOR
ENDFOR
// aggregate results
CASE (imm8[3:2]) OF
0:  // equal any
	IntRes1 := 0
	FOR i := 0 to UpperBound
		FOR j := 0 to UpperBound
			IntRes1[i] := IntRes1[i] OR BoolRes[i][j]
		ENDFOR
	ENDFOR
1:  // ranges
	IntRes1 := 0
	FOR i := 0 to UpperBound
		FOR j := 0 to UpperBound, j += 2
			IntRes1[i] := IntRes1[i] OR (BoolRes[i][j] AND BoolRes[i][j+1])
		ENDFOR
	ENDFOR
2:  // equal each
	IntRes1 := 0
	FOR i := 0 to UpperBound
		IntRes1[i] := BoolRes[i][i]
	ENDFOR
3:  // equal ordered
	IntRes1 := (imm8[0] ? 0xFF : 0xFFFF)
	FOR i := 0 to UpperBound
		k := i
		FOR j := 0 to UpperBound-i
			IntRes1[i] := IntRes1[i] AND BoolRes[k][j]
			k := k+1
		ENDFOR
	ENDFOR
ESAC
// optionally negate results
bInvalid := 0
FOR i := 0 to UpperBound
	IF imm8[4]
		IF imm8[5] // only negate valid
			IF b[n+size-1:n] == 0
				bInvalid := 1
			FI
			IF bInvalid // invalid, don't negate
				IntRes2[i] := IntRes1[i]
			ELSE // valid, negate
				IntRes2[i] := -1 XOR IntRes1[i]
			FI
		ELSE // negate all
			IntRes2[i] := -1 XOR IntRes1[i]
		FI
	ELSE // don't negate
		IntRes2[i] := IntRes1[i]
	FI
ENDFOR
// output
dst := IntRes2[0]</div></div></div><div class="intrinsic SSE4_2" id="953"><div class="instruction">pcmpistri</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cmpistrs</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cmpistrs</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;nmmintrin.h&gt;<br>Instruction: pcmpistri xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.2</span></div><h1>Description</h1><div class="description">Compare packed strings with implicit lengths in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using the control in <span class="desc_var imm8">imm8</span>, and returns 1 if any character in <span class="desc_var a">a</span> was null, and 0 otherwise.
	<br><span class="desc_var imm">imm</span> can be a combination of:<div class="desc_note">    _SIDD_UBYTE_OPS                // unsigned 8-bit characters
    _SIDD_UWORD_OPS                // unsigned 16-bit characters
    _SIDD_SBYTE_OPS                // signed 8-bit characters
    _SIDD_SWORD_OPS                // signed 16-bit characters
    _SIDD_CMP_EQUAL_ANY            // compare equal any
    _SIDD_CMP_RANGES               // compare ranges
    _SIDD_CMP_EQUAL_EACH           // compare equal each
    _SIDD_CMP_EQUAL_ORDERED        // compare equal ordered
    _SIDD_NEGATIVE_POLARITY        // negate results
    _SIDD_MASKED_NEGATIVE_POLARITY // negate results only before end of string
    _SIDD_LEAST_SIGNIFICANT        // index only: return last significant bit
    _SIDD_MOST_SIGNIFICANT         // index only: return most significant bit
    _SIDD_BIT_MASK                 // mask only: return bit mask
    _SIDD_UNIT_MASK                // mask only: return byte/word mask</div>
	</div><h1>Operation</h1><div class="operation">size := (imm8[0] ? 16 : 8) // 8 or 16-bit characters
UpperBound := (128 / size) - 1
aInvalid := 0
FOR i := 0 to UpperBound
	m := i*size
	IF b[m+size-1:m] == 0
		aInvalid := 1
	FI
ENDFOR
dst := aInvalid</div></div></div><div class="intrinsic SSE4_2" id="954"><div class="instruction">pcmpistri</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cmpistrz</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cmpistrz</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;nmmintrin.h&gt;<br>Instruction: pcmpistri xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.2</span></div><h1>Description</h1><div class="description">Compare packed strings with implicit lengths in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using the control in <span class="desc_var imm8">imm8</span>, and returns 1 if any character in <span class="desc_var b">b</span> was null, and 0 otherwise.
	<br><span class="desc_var imm">imm</span> can be a combination of:<div class="desc_note">    _SIDD_UBYTE_OPS                // unsigned 8-bit characters
    _SIDD_UWORD_OPS                // unsigned 16-bit characters
    _SIDD_SBYTE_OPS                // signed 8-bit characters
    _SIDD_SWORD_OPS                // signed 16-bit characters
    _SIDD_CMP_EQUAL_ANY            // compare equal any
    _SIDD_CMP_RANGES               // compare ranges
    _SIDD_CMP_EQUAL_EACH           // compare equal each
    _SIDD_CMP_EQUAL_ORDERED        // compare equal ordered
    _SIDD_NEGATIVE_POLARITY        // negate results
    _SIDD_MASKED_NEGATIVE_POLARITY // negate results only before end of string
    _SIDD_LEAST_SIGNIFICANT        // index only: return last significant bit
    _SIDD_MOST_SIGNIFICANT         // index only: return most significant bit
    _SIDD_BIT_MASK                 // mask only: return bit mask
    _SIDD_UNIT_MASK                // mask only: return byte/word mask</div>
	</div><h1>Operation</h1><div class="operation">size := (imm8[0] ? 16 : 8) // 8 or 16-bit characters
UpperBound := (128 / size) - 1
bInvalid := 0
FOR j := 0 to UpperBound
	n := j*size
	IF b[n+size-1:n] == 0
		bInvalid := 1
	FI
ENDFOR
dst := bInvalid</div></div></div><div class="intrinsic SSE2" id="1003"><div class="instruction">cmppd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmple_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmple_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cmppd xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for less-than-or-equal, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := (a[i+63:i] &lt;= b[i+63:i]) ? 0xFFFFFFFFFFFFFFFF : 0
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="1006"><div class="instruction">cmpps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmple_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmple_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cmpps xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for less-than-or-equal, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := ( a[i+31:i] &lt;= b[i+31:i] ) ? 0xffffffff : 0
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1009"><div class="instruction">cmpsd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmple_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmple_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cmpsd xmm, xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare the lower double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for less-than-or-equal, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := (a[63:0] &lt;= b[63:0]) ? 0xFFFFFFFFFFFFFFFF : 0
dst[127:64] := a[127:64]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="1010"><div class="instruction">cmpss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmple_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmple_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cmpss xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare the lower single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for less-than-or-equal, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := ( a[31:0] &lt;= b[31:0] ) ? 0xffffffff : 0
dst[127:32] := a[127:32]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1011"><div class="instruction">pcmpgtw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cmplt_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cmplt_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pcmpgtw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for less-than, and store the results in <span class="desc_var dst">dst</span>. Note: This intrinsic emits the pcmpgtw instruction with the order of the operands switched.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := ( a[i+15:i] &lt; b[i+15:i] ) ? 0xFFFF : 0
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1018"><div class="instruction">pcmpgtd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cmplt_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cmplt_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pcmpgtd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare packed 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for less-than, and store the results in <span class="desc_var dst">dst</span>. Note: This intrinsic emits the pcmpgtd instruction with the order of the operands switched.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := ( a[i+31:i] &lt; b[i+31:i] ) ? 0xFFFFFFFF : 0
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1033"><div class="instruction">pcmpgtb</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cmplt_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cmplt_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pcmpgtb xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for less-than, and store the results in <span class="desc_var dst">dst</span>. Note: This intrinsic emits the pcmpgtb instruction with the order of the operands switched.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := ( a[i+7:i] &lt; b[i+7:i] ) ? 0xFF : 0
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1064"><div class="instruction">cmppd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmplt_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmplt_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cmppd xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for less-than, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := (a[i+63:i] &lt; b[i+63:i]) ? 0xFFFFFFFFFFFFFFFF : 0
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="1067"><div class="instruction">cmpps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmplt_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmplt_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cmpps xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for less-than, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := ( a[i+31:i] &lt; b[i+31:i] ) ? 0xffffffff : 0
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1070"><div class="instruction">cmpsd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmplt_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmplt_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cmpsd xmm, xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare the lower double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for less-than, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := (a[63:0] &lt; b[63:0]) ? 0xFFFFFFFFFFFFFFFF : 0
dst[127:64] := a[127:64]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="1071"><div class="instruction">cmpss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmplt_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmplt_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cmpss xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare the lower single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for less-than, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := ( a[31:0] &lt; b[31:0] ) ? 0xffffffff : 0
dst[127:32] := a[127:32]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1120"><div class="instruction">cmppd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpneq_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpneq_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cmppd xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for not-equal, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := (a[i+63:i] != b[i+63:i]) ? 0xFFFFFFFFFFFFFFFF : 0
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="1123"><div class="instruction">cmpps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpneq_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpneq_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cmpps xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for not-equal, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := ( a[i+31:i] != b[i+31:i] ) ? 0xffffffff : 0
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1126"><div class="instruction">cmpsd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpneq_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpneq_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cmpsd xmm, xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare the lower double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for not-equal, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := (a[63:0] != b[63:0]) ? 0xFFFFFFFFFFFFFFFF : 0
dst[127:64] := a[127:64]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="1127"><div class="instruction">cmpss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpneq_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpneq_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cmpss xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare the lower single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for not-equal, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := ( a[31:0] != b[31:0] ) ? 0xffffffff : 0
dst[127:32] := a[127:32]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1128"><div class="instruction">cmppd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpnge_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpnge_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cmppd xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for not-greater-than-or-equal, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := (!(a[i+63:i] &gt;= b[i+63:i])) ? 0xFFFFFFFFFFFFFFFF : 0
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="1129"><div class="instruction">cmpps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpnge_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpnge_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cmpps xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for not-greater-than-or-equal, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := (!( a[i+31:i] &gt;= b[i+31:i] )) ? 0xffffffff : 0
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1130"><div class="instruction">cmpsd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpnge_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpnge_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cmpsd xmm, xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare the lower double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for not-greater-than-or-equal, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := (!(a[63:0] &gt;= b[63:0])) ? 0xFFFFFFFFFFFFFFFF : 0
dst[127:64] := a[127:64]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="1131"><div class="instruction">cmpss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpnge_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpnge_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cmpss xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare the lower single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for not-greater-than-or-equal, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := (!( a[31:0] &gt;= b[31:0] )) ? 0xffffffff : 0
dst[127:32] := a[127:32]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1132"><div class="instruction">cmppd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpngt_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpngt_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cmppd xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for not-greater-than, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := (!(a[i+63:i] &gt; b[i+63:i])) ? 0xFFFFFFFFFFFFFFFF : 0
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="1133"><div class="instruction">cmpps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpngt_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpngt_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cmpps xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for not-greater-than, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := (!( a[i+31:i] &gt; b[i+31:i] )) ? 0xffffffff : 0
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1134"><div class="instruction">cmpsd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpngt_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpngt_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cmpsd xmm, xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare the lower double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for not-greater-than, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := (!(a[63:0] &gt; b[63:0])) ? 0xFFFFFFFFFFFFFFFF : 0
dst[127:64] := a[127:64]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="1135"><div class="instruction">cmpss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpngt_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpngt_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cmpss xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare the lower single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for not-greater-than, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := (!( a[31:0] &gt; b[31:0] )) ? 0xffffffff : 0
dst[127:32] := a[127:32]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1136"><div class="instruction">cmppd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpnle_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpnle_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cmppd xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for not-less-than-or-equal, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := (!(a[i+63:i] &lt;= b[i+63:i])) ? 0xFFFFFFFFFFFFFFFF : 0
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="1139"><div class="instruction">cmpps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpnle_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpnle_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cmpps xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for not-less-than-or-equal, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := (!( a[i+31:i] &lt;= b[i+31:i] )) ? 0xffffffff : 0
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1142"><div class="instruction">cmpsd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpnle_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpnle_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cmpsd xmm, xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare the lower double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for not-less-than-or-equal, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := (!(a[63:0] &lt;= b[63:0])) ? 0xFFFFFFFFFFFFFFFF : 0
dst[127:64] := a[127:64]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="1143"><div class="instruction">cmpss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpnle_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpnle_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cmpss xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare the lower single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for not-less-than-or-equal, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := (!( a[31:0] &lt;= b[31:0] )) ? 0xffffffff : 0
dst[127:32] := a[127:32]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1144"><div class="instruction">cmppd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpnlt_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpnlt_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cmppd xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for not-less-than, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := (!(a[i+63:i] &lt; b[i+63:i])) ? 0xFFFFFFFFFFFFFFFF : 0
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="1147"><div class="instruction">cmpps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpnlt_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpnlt_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cmpps xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for not-less-than, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := !( a[i+31:i] &lt; b[i+31:i] ) ? 0xffffffff : 0
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1150"><div class="instruction">cmpsd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpnlt_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpnlt_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cmpsd xmm, xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare the lower double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for not-less-than, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := (!(a[63:0] &lt; b[63:0])) ? 0xFFFFFFFFFFFFFFFF : 0
dst[127:64] := a[127:64]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="1151"><div class="instruction">cmpss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpnlt_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpnlt_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cmpss xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare the lower single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for not-less-than, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := (!( a[31:0] &lt; b[31:0] )) ? 0xffffffff : 0
dst[127:32] := a[127:32]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1152"><div class="instruction">cmppd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpord_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpord_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cmppd xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> to see if neither is NaN, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := (a[i+63:i] != NaN AND b[i+63:i] != NaN) ? 0xFFFFFFFFFFFFFFFF : 0
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="1155"><div class="instruction">cmpps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpord_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpord_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cmpps xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> to see if neither is NaN, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := ( a[i+31:i] != NaN AND b[i+31:i] != NaN ) ? 0xffffffff : 0
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1158"><div class="instruction">cmpsd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpord_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpord_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cmpsd xmm, xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare the lower double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> to see if neither is NaN, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := (a[63:0] != NaN AND b[63:0] != NaN) ? 0xFFFFFFFFFFFFFFFF : 0
dst[127:64] := a[127:64]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="1159"><div class="instruction">cmpss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpord_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpord_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cmpss xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare the lower single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> to see if neither is NaN, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := ( a[31:0] != NaN AND b[31:0] != NaN ) ? 0xffffffff : 0
dst[127:32] := a[127:32]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1160"><div class="instruction">cmppd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpunord_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpunord_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cmppd xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> to see if either is NaN, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := (a[i+63:i] == NaN OR b[i+63:i] == NaN) ? 0xFFFFFFFFFFFFFFFF : 0
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="1163"><div class="instruction">cmpps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpunord_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpunord_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cmpps xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> to see if either is NaN, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := ( a[i+31:i] == NaN OR b[i+31:i] == NaN ) ? 0xffffffff : 0
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1166"><div class="instruction">cmpsd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpunord_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cmpunord_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cmpsd xmm, xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare the lower double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> to see if either is NaN, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := (a[63:0] == NaN OR b[63:0] == NaN) ? 0xFFFFFFFFFFFFFFFF : 0
dst[127:64] := a[127:64]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="1167"><div class="instruction">cmpss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpunord_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cmpunord_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cmpss xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare the lower single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> to see if either is NaN, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := ( a[31:0] == NaN OR b[31:0] == NaN ) ? 0xffffffff : 0
dst[127:32] := a[127:32]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1170"><div class="instruction">comisd</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_comieq_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_comieq_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: comisd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare the lower double-precision (64-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for equality, and return the boolean result (0 or 1).</div><h1>Operation</h1><div class="operation">RETURN ( a[63:0] == b[63:0] ) ? 1 : 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="1171"><div class="instruction">comiss</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_comieq_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_comieq_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: comiss xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare the lower single-precision (32-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for equality, and return the boolean result (0 or 1).</div><h1>Operation</h1><div class="operation">RETURN ( a[31:0] == b[31:0] ) ? 1 : 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1172"><div class="instruction">comisd</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_comige_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_comige_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: comisd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare the lower double-precision (64-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for greater-than-or-equal, and return the boolean result (0 or 1).</div><h1>Operation</h1><div class="operation">RETURN ( a[63:0] &gt;= b[63:0] ) ? 1 : 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="1173"><div class="instruction">comiss</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_comige_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_comige_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: comiss xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare the lower single-precision (32-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for greater-than-or-equal, and return the boolean result (0 or 1).</div><h1>Operation</h1><div class="operation">RETURN ( a[31:0] &gt;= b[31:0] ) ? 1 : 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1174"><div class="instruction">comisd</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_comigt_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_comigt_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: comisd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare the lower double-precision (64-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for greater-than, and return the boolean result (0 or 1).</div><h1>Operation</h1><div class="operation">RETURN ( a[63:0] &gt; b[63:0] ) ? 1 : 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="1175"><div class="instruction">comiss</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_comigt_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_comigt_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: comiss xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare the lower single-precision (32-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for greater-than, and return the boolean result (0 or 1).</div><h1>Operation</h1><div class="operation">RETURN ( a[31:0] &gt; b[31:0] ) ? 1 : 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1176"><div class="instruction">comisd</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_comile_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_comile_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: comisd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare the lower double-precision (64-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for less-than-or-equal, and return the boolean result (0 or 1).</div><h1>Operation</h1><div class="operation">RETURN ( a[63:0] &lt;= b[63:0] ) ? 1 : 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="1177"><div class="instruction">comiss</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_comile_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_comile_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: comiss xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare the lower single-precision (32-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for less-than-or-equal, and return the boolean result (0 or 1).</div><h1>Operation</h1><div class="operation">RETURN ( a[31:0] &lt;= b[31:0] ) ? 1 : 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1178"><div class="instruction">comisd</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_comilt_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_comilt_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: comisd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare the lower double-precision (64-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for less-than, and return the boolean result (0 or 1).</div><h1>Operation</h1><div class="operation">RETURN ( a[63:0] &lt; b[63:0] ) ? 1 : 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="1179"><div class="instruction">comiss</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_comilt_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_comilt_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: comiss xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare the lower single-precision (32-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for less-than, and return the boolean result (0 or 1).</div><h1>Operation</h1><div class="operation">RETURN ( a[31:0] &lt; b[31:0] ) ? 1 : 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1180"><div class="instruction">comisd</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_comineq_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_comineq_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: comisd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare the lower double-precision (64-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for not-equal, and return the boolean result (0 or 1).</div><h1>Operation</h1><div class="operation">RETURN ( a[63:0] != b[63:0] ) ? 1 : 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="1181"><div class="instruction">comiss</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_comineq_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_comineq_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: comiss xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare the lower single-precision (32-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for not-equal, and return the boolean result (0 or 1).</div><h1>Operation</h1><div class="operation">RETURN ( a[31:0] != b[31:0] ) ? 1 : 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE4_2" id="1280"><div class="instruction">crc32</div><div class="signature"><span class="sig"><span class="rettype">unsigned int</span> <span class="name">_mm_crc32_u16</span> (<span class="param_type">unsigned int</span> <span class="param_name">crc</span>, <span class="param_type">unsigned short</span> <span class="param_name">v</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">unsigned int</span> <span class="name">_mm_crc32_u16</span> (<span class="param_type">unsigned int</span> <span class="param_name">crc</span>, <span class="param_type">unsigned short</span> <span class="param_name">v</span>)</span><br>#include &lt;nmmintrin.h&gt;<br>Instruction: crc32 r32, r16<br>CPUID Flags: <span class="cpuid">SSE4.2</span></div><h1>Description</h1><div class="description">Starting with the initial value in <span class="desc_var crc">crc</span>, accumulates a CRC32 value for unsigned 16-bit integer <span class="desc_var v">v</span>, and stores the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">tmp1[15:0] := v[0:15] // bit reflection
tmp2[31:0] := crc[0:31] // bit reflection
tmp3[47:0] := tmp1[15:0] &lt;&lt; 32
tmp4[47:0] := tmp2[31:0] &lt;&lt; 16
tmp5[47:0] := tmp3[47:0] XOR tmp4[47:0]
tmp6[31:0] := MOD2(tmp5[47:0], 0x11EDC6F41) // remainder from polynomial division modulus 2
dst[31:0] := tmp6[0:31] // bit reflection</div></div></div><div class="intrinsic SSE4_2" id="1281"><div class="instruction">crc32</div><div class="signature"><span class="sig"><span class="rettype">unsigned int</span> <span class="name">_mm_crc32_u32</span> (<span class="param_type">unsigned int</span> <span class="param_name">crc</span>, <span class="param_type">unsigned int</span> <span class="param_name">v</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">unsigned int</span> <span class="name">_mm_crc32_u32</span> (<span class="param_type">unsigned int</span> <span class="param_name">crc</span>, <span class="param_type">unsigned int</span> <span class="param_name">v</span>)</span><br>#include &lt;nmmintrin.h&gt;<br>Instruction: crc32 r32, r32<br>CPUID Flags: <span class="cpuid">SSE4.2</span></div><h1>Description</h1><div class="description">Starting with the initial value in <span class="desc_var crc">crc</span>, accumulates a CRC32 value for unsigned 32-bit integer <span class="desc_var v">v</span>, and stores the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">tmp1[31:0] := v[0:31] // bit reflection
tmp2[31:0] := crc[0:31] // bit reflection
tmp3[63:0] := tmp1[31:0] &lt;&lt; 32
tmp4[63:0] := tmp2[31:0] &lt;&lt; 32
tmp5[63:0] := tmp3[63:0] XOR tmp4[63:0]
tmp6[31:0] := MOD2(tmp5[63:0], 0x11EDC6F41) // remainder from polynomial division modulus 2
dst[31:0] := tmp6[0:31] // bit reflection</div></div></div><div class="intrinsic SSE4_2" id="1282"><div class="instruction">crc32</div><div class="signature"><span class="sig"><span class="rettype">unsigned __int64</span> <span class="name">_mm_crc32_u64</span> (<span class="param_type">unsigned __int64</span> <span class="param_name">crc</span>, <span class="param_type">unsigned __int64</span> <span class="param_name">v</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">unsigned __int64</span> <span class="name">_mm_crc32_u64</span> (<span class="param_type">unsigned __int64</span> <span class="param_name">crc</span>, <span class="param_type">unsigned __int64</span> <span class="param_name">v</span>)</span><br>#include &lt;nmmintrin.h&gt;<br>Instruction: crc32 r64, r64<br>CPUID Flags: <span class="cpuid">SSE4.2</span></div><h1>Description</h1><div class="description">Starting with the initial value in <span class="desc_var crc">crc</span>, accumulates a CRC32 value for unsigned 64-bit integer <span class="desc_var v">v</span>, and stores the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">tmp1[63:0] := v[0:63] // bit reflection
tmp2[31:0] := crc[0:31] // bit reflection
tmp3[95:0] := tmp1[31:0] &lt;&lt; 32
tmp4[95:0] := tmp2[63:0] &lt;&lt; 64
tmp5[95:0] := tmp3[95:0] XOR tmp4[95:0]
tmp6[31:0] := MOD2(tmp5[95:0], 0x11EDC6F41) // remainder from polynomial division modulus 2
dst[31:0] := tmp6[0:31] // bit reflection</div></div></div><div class="intrinsic SSE4_2" id="1283"><div class="instruction">crc32</div><div class="signature"><span class="sig"><span class="rettype">unsigned int</span> <span class="name">_mm_crc32_u8</span> (<span class="param_type">unsigned int</span> <span class="param_name">crc</span>, <span class="param_type">unsigned char</span> <span class="param_name">v</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">unsigned int</span> <span class="name">_mm_crc32_u8</span> (<span class="param_type">unsigned int</span> <span class="param_name">crc</span>, <span class="param_type">unsigned char</span> <span class="param_name">v</span>)</span><br>#include &lt;nmmintrin.h&gt;<br>Instruction: crc32 r32, r8<br>CPUID Flags: <span class="cpuid">SSE4.2</span></div><h1>Description</h1><div class="description">Starting with the initial value in <span class="desc_var crc">crc</span>, accumulates a CRC32 value for unsigned 8-bit integer <span class="desc_var v">v</span>, and stores the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">tmp1[7:0] := v[0:7] // bit reflection
tmp2[31:0] := crc[0:31] // bit reflection
tmp3[39:0] := tmp1[7:0] &lt;&lt; 32 
tmp4[39:0] := tmp2[31:0] &lt;&lt; 8
tmp5[39:0] := tmp3[39:0] XOR tmp4[39:0]
tmp6[31:0] := MOD2(tmp5[39:0], 0x11EDC6F41) // remainder from polynomial division modulus 2
dst[31:0] := tmp6[0:31] // bit reflection</div></div></div><div class="intrinsic SSE" id="1286"><div class="instruction">cvtpi2ps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cvt_pi2ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cvt_pi2ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cvtpi2ps xmm, mm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Convert packed 32-bit integers in <span class="desc_var b">b</span> to packed single-precision (32-bit) floating-point elements, store the results in the lower 2 elements of <span class="desc_var dst">dst</span>, and copy the upper 2 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">dst[31:0] := Convert_Int32_To_FP32(b[31:0])
dst[63:32] := Convert_Int32_To_FP32(b[63:32])
dst[95:64] := a[95:64]
dst[127:96] := a[127:96]</div></div></div><div class="intrinsic SSE" id="1287"><div class="instruction">cvtps2pi</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_cvt_ps2pi</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_cvt_ps2pi</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cvtps2pi mm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Convert packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> to packed 32-bit integers, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := 32*j
	dst[i+31:i] := Convert_FP32_To_Int32(a[i+31:i])
ENDFOR</div></div></div><div class="intrinsic SSE" id="1375"><div class="instruction">cvtsi2ss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cvt_si2ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cvt_si2ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cvtsi2ss xmm, r32<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Convert the 32-bit integer <span class="desc_var b">b</span> to a single-precision (32-bit) floating-point element, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := Convert_Int32_To_FP32(b[31:0])
dst[127:32] := a[127:32]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>6</td><td>1</td></tr><tr><td>Broadwell</td><td>4</td><td>1</td></tr><tr><td>Haswell</td><td>4</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="1376"><div class="instruction">cvtss2si</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cvt_ss2si</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cvt_ss2si</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cvtss2si r32, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Convert the lower single-precision (32-bit) floating-point element in <span class="desc_var a">a</span> to a 32-bit integer, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := Convert_FP32_To_Int32(a[31:0])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>6</td><td>1</td></tr><tr><td>Broadwell</td><td>4</td><td>1</td></tr><tr><td>Haswell</td><td>4</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE4_1" id="1377"><div class="instruction">pmovsxwd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvtepi16_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvtepi16_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: pmovsxwd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Sign extend packed 16-bit integers in <span class="desc_var a">a</span> to packed 32-bit integers, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := 32*j
	k := 16*j
	dst[i+31:i] := SignExtend(a[k+15:k])
ENDFOR</div></div></div><div class="intrinsic AVX2" id="1380"><div class="instruction">vpmovsxwd</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cvtepi16_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cvtepi16_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmovsxwd ymm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Sign extend packed 16-bit integers in <span class="desc_var a">a</span> to packed 32-bit integers, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j:= 0 to 7
	i := 32*j
	k := 16*j
	dst[i+31:i] := SignExtend(a[k+15:k])
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE4_1" id="1386"><div class="instruction">pmovsxwq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvtepi16_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvtepi16_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: pmovsxwq xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Sign extend packed 16-bit integers in <span class="desc_var a">a</span> to packed 64-bit integers, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := 64*j
	k := 16*j
	dst[i+63:i] := SignExtend(a[k+15:k])
ENDFOR</div></div></div><div class="intrinsic AVX2" id="1389"><div class="instruction">vpmovsxwq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cvtepi16_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cvtepi16_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmovsxwq ymm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Sign extend packed 16-bit integers in <span class="desc_var a">a</span> to packed 64-bit integers, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j:= 0 to 3
	i := 64*j
	k := 16*j
	dst[i+63:i] := SignExtend(a[k+15:k])
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE4_1" id="1416"><div class="instruction">pmovsxdq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvtepi32_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvtepi32_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: pmovsxdq xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Sign extend packed 32-bit integers in <span class="desc_var a">a</span> to packed 64-bit integers, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := 64*j
	k := 32*j
	dst[i+63:i] := SignExtend(a[k+31:k])
ENDFOR</div></div></div><div class="intrinsic AVX2" id="1419"><div class="instruction">vpmovsxdq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cvtepi32_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cvtepi32_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmovsxdq ymm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Sign extend packed 32-bit integers in <span class="desc_var a">a</span> to packed 64-bit integers, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j:= 0 to 3
	i := 64*j
	k := 32*j
	dst[i+63:i] := SignExtend(a[k+31:k])
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="1434"><div class="instruction">cvtdq2pd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cvtepi32_pd</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cvtepi32_pd</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cvtdq2pd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Convert packed 32-bit integers in <span class="desc_var a">a</span> to packed double-precision (64-bit) floating-point elements, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*32
	m := j*64
	dst[m+63:m] := Convert_Int32_To_FP64(a[i+31:i])
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>5</td><td>1</td></tr><tr><td>Broadwell</td><td>4</td><td>1</td></tr><tr><td>Haswell</td><td>4</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>4</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="1437"><div class="instruction">vcvtdq2pd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_cvtepi32_pd</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_cvtepi32_pd</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vcvtdq2pd ymm, xmm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Convert packed 32-bit integers in <span class="desc_var a">a</span> to packed double-precision (64-bit) floating-point elements, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	m := j*64
	dst[m+63:m] := Convert_Int32_To_FP64(a[i+31:i])
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>7</td><td>1</td></tr><tr><td>Broadwell</td><td>6</td><td>1</td></tr><tr><td>Haswell</td><td>6</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>4</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1443"><div class="instruction">cvtdq2ps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cvtepi32_ps</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cvtepi32_ps</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cvtdq2ps xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Convert packed 32-bit integers in <span class="desc_var a">a</span> to packed single-precision (32-bit) floating-point elements, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := 32*j
	dst[i+31:i] := Convert_Int32_To_FP32(a[i+31:i])
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>1</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="1446"><div class="instruction">vcvtdq2ps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_cvtepi32_ps</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_cvtepi32_ps</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vcvtdq2ps ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Convert packed 32-bit integers in <span class="desc_var a">a</span> to packed single-precision (32-bit) floating-point elements, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := 32*j
	dst[i+31:i] := Convert_Int32_To_FP32(a[i+31:i])
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE4_1" id="1514"><div class="instruction">pmovsxbw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvtepi8_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvtepi8_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: pmovsxbw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Sign extend packed 8-bit integers in <span class="desc_var a">a</span> to packed 16-bit integers, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	l := j*16
	dst[l+15:l] := SignExtend(a[i+7:i])
ENDFOR</div></div></div><div class="intrinsic AVX2" id="1517"><div class="instruction">vpmovsxbw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cvtepi8_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cvtepi8_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmovsxbw ymm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Sign extend packed 8-bit integers in <span class="desc_var a">a</span> to packed 16-bit integers, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*8
	l := j*16
	dst[l+15:l] := SignExtend(a[i+7:i])
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE4_1" id="1523"><div class="instruction">pmovsxbd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvtepi8_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvtepi8_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: pmovsxbd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Sign extend packed 8-bit integers in <span class="desc_var a">a</span> to packed 32-bit integers, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := 32*j
	k := 8*j
	dst[i+31:i] := SignExtend(a[k+7:k])
ENDFOR</div></div></div><div class="intrinsic AVX2" id="1526"><div class="instruction">vpmovsxbd</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cvtepi8_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cvtepi8_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmovsxbd ymm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Sign extend packed 8-bit integers in <span class="desc_var a">a</span> to packed 32-bit integers, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := 32*j
	k := 8*j
	dst[i+31:i] := SignExtend(a[k+7:k])
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE4_1" id="1532"><div class="instruction">pmovsxbq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvtepi8_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvtepi8_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: pmovsxbq xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Sign extend packed 8-bit integers in the low 8 bytes of <span class="desc_var a">a</span> to packed 64-bit integers, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := 64*j
	k := 8*j
	dst[i+63:i] := SignExtend(a[k+7:k])
ENDFOR</div></div></div><div class="intrinsic AVX2" id="1535"><div class="instruction">vpmovsxbq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cvtepi8_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cvtepi8_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmovsxbq ymm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Sign extend packed 8-bit integers in the low 8 bytes of <span class="desc_var a">a</span> to packed 64-bit integers, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := 64*j
	k := 8*j
	dst[i+63:i] := SignExtend(a[k+7:k])
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE4_1" id="1541"><div class="instruction">pmovzxwd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvtepu16_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvtepu16_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: pmovzxwd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Zero extend packed unsigned 16-bit integers in <span class="desc_var a">a</span> to packed 32-bit integers, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := 32*j
	k := 16*j
	dst[i+31:i] := ZeroExtend(a[k+15:k])
ENDFOR</div></div></div><div class="intrinsic AVX2" id="1544"><div class="instruction">vpmovzxwd</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cvtepu16_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cvtepu16_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmovzxwd ymm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Zero extend packed unsigned 16-bit integers in <span class="desc_var a">a</span> to packed 32-bit integers, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := 32*j
	k := 16*j
	dst[i+31:i] := ZeroExtend(a[k+15:k])
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE4_1" id="1550"><div class="instruction">pmovzxwq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvtepu16_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvtepu16_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: pmovzxwq xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Zero extend packed unsigned 16-bit integers in <span class="desc_var a">a</span> to packed 64-bit integers, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := 64*j
	k := 16*j
	dst[i+63:i] := ZeroExtend(a[k+15:k])
ENDFOR</div></div></div><div class="intrinsic AVX2" id="1553"><div class="instruction">vpmovzxwq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cvtepu16_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cvtepu16_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmovzxwq ymm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Zero extend packed unsigned 16-bit integers in <span class="desc_var a">a</span> to packed 64-bit integers, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j:= 0 to 3
	i := 64*j
	k := 16*j
	dst[i+63:i] := ZeroExtend(a[k+15:k])
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE4_1" id="1559"><div class="instruction">pmovzxdq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvtepu32_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvtepu32_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: pmovzxdq xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Zero extend packed unsigned 32-bit integers in <span class="desc_var a">a</span> to packed 64-bit integers, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := 64*j
	k := 32*j
	dst[i+63:i] := ZeroExtend(a[k+31:k])
ENDFOR</div></div></div><div class="intrinsic AVX2" id="1562"><div class="instruction">vpmovzxdq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cvtepu32_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cvtepu32_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmovzxdq ymm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Zero extend packed unsigned 32-bit integers in <span class="desc_var a">a</span> to packed 64-bit integers, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j:= 0 to 3
	i := 64*j
	k := 32*j
	dst[i+63:i] := ZeroExtend(a[k+31:k])
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE4_1" id="1600"><div class="instruction">pmovzxbw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvtepu8_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvtepu8_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: pmovzxbw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Zero extend packed unsigned 8-bit integers in <span class="desc_var a">a</span> to packed 16-bit integers, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	l := j*16
	dst[l+15:l] := ZeroExtend(a[i+7:i])
ENDFOR</div></div></div><div class="intrinsic AVX2" id="1603"><div class="instruction">vpmovzxbw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cvtepu8_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cvtepu8_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmovzxbw ymm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Zero extend packed unsigned 8-bit integers in <span class="desc_var a">a</span> to packed 16-bit integers, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*8
	l := j*16
	dst[l+15:l] := ZeroExtend(a[i+7:i])
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE4_1" id="1609"><div class="instruction">pmovzxbd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvtepu8_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvtepu8_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: pmovzxbd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Zero extend packed unsigned 8-bit integers in <span class="desc_var a">a</span> to packed 32-bit integers, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := 32*j
	k := 8*j
	dst[i+31:i] := ZeroExtend(a[k+7:k])
ENDFOR</div></div></div><div class="intrinsic AVX2" id="1612"><div class="instruction">vpmovzxbd</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cvtepu8_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cvtepu8_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmovzxbd ymm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Zero extend packed unsigned 8-bit integers in <span class="desc_var a">a</span> to packed 32-bit integers, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := 32*j
	k := 8*j
	dst[i+31:i] := ZeroExtend(a[k+7:k])
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE4_1" id="1618"><div class="instruction">pmovzxbq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvtepu8_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvtepu8_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: pmovzxbq xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Zero extend packed unsigned 8-bit integers in the low 8 byte sof <span class="desc_var a">a</span> to packed 64-bit integers, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := 64*j
	k := 8*j
	dst[i+63:i] := ZeroExtend(a[k+7:k])
ENDFOR</div></div></div><div class="intrinsic AVX2" id="1621"><div class="instruction">vpmovzxbq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cvtepu8_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cvtepu8_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmovzxbq ymm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Zero extend packed unsigned 8-bit integers in the low 8 byte sof <span class="desc_var a">a</span> to packed 64-bit integers, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := 64*j
	k := 8*j
	dst[i+63:i] := ZeroExtend(a[k+7:k])
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic MMX" id="1640"><div class="instruction">movq</div><div class="signature"><span class="sig"><span class="rettype">__int64</span> <span class="name">_mm_cvtm64_si64</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__int64</span> <span class="name">_mm_cvtm64_si64</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: movq r64, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Copy 64-bit integer <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := a[63:0]</div></div></div><div class="intrinsic SSE2" id="1663"><div class="instruction">cvtpd2dq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvtpd_epi32</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvtpd_epi32</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cvtpd2dq xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Convert packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> to packed 32-bit integers, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := 32*j
	k := 64*j
	dst[i+31:i] := Convert_FP64_To_Int32(a[k+63:k])
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>5</td><td>1</td></tr><tr><td>Broadwell</td><td>4</td><td>1</td></tr><tr><td>Haswell</td><td>4</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>4</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="1666"><div class="instruction">vcvtpd2dq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm256_cvtpd_epi32</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm256_cvtpd_epi32</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vcvtpd2dq xmm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Convert packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> to packed 32-bit integers, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := 32*j
	k := 64*j
	dst[i+31:i] := Convert_FP64_To_Int32(a[k+63:k])
ENDFOR
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>7</td><td>1</td></tr><tr><td>Broadwell</td><td>6</td><td>1</td></tr><tr><td>Haswell</td><td>6</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>4</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1699"><div class="instruction">cvtpd2pi</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_cvtpd_pi32</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_cvtpd_pi32</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cvtpd2pi mm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Convert packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> to packed 32-bit integers, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := 32*j
	k := 64*j
	dst[i+31:i] := Convert_FP64_To_Int32(a[k+63:k])
ENDFOR</div></div></div><div class="intrinsic SSE2" id="1700"><div class="instruction">cvtpd2ps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cvtpd_ps</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cvtpd_ps</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cvtpd2ps xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Convert packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> to packed single-precision (32-bit) floating-point elements, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := 32*j
	k := 64*j
	dst[i+31:i] := Convert_FP64_To_FP32(a[k+63:k])
ENDFOR
dst[127:64] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>5</td><td>1</td></tr><tr><td>Broadwell</td><td>4</td><td>1</td></tr><tr><td>Haswell</td><td>4</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>4</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="1703"><div class="instruction">vcvtpd2ps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm256_cvtpd_ps</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm256_cvtpd_ps</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vcvtpd2ps xmm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Convert packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> to packed single-precision (32-bit) floating-point elements, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := 32*j
	k := 64*j
	dst[i+31:i] := Convert_FP64_To_FP32(a[k+63:k])
ENDFOR
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>7</td><td>1</td></tr><tr><td>Broadwell</td><td>6</td><td>1</td></tr><tr><td>Haswell</td><td>6</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>4</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="1720"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cvtpi16_ps</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cvtpi16_ps</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Convert packed 16-bit integers in <span class="desc_var a">a</span> to packed single-precision (32-bit) floating-point elements, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	m := j*32
	dst[m+31:m] := Convert_Int16_To_FP32(a[i+15:i])
ENDFOR</div></div></div><div class="intrinsic SSE2" id="1721"><div class="instruction">cvtpi2pd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cvtpi32_pd</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cvtpi32_pd</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cvtpi2pd xmm, mm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Convert packed 32-bit integers in <span class="desc_var a">a</span> to packed double-precision (64-bit) floating-point elements, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*32
	m := j*64
	dst[m+63:m] := Convert_Int32_To_FP64(a[i+31:i])
ENDFOR</div></div></div><div class="intrinsic SSE" id="1722"><div class="instruction">cvtpi2ps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cvtpi32_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cvtpi32_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cvtpi2ps xmm, mm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Convert packed 32-bit integers in <span class="desc_var b">b</span> to packed single-precision (32-bit) floating-point elements, store the results in the lower 2 elements of <span class="desc_var dst">dst</span>, and copy the upper 2 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">dst[31:0] := Convert_Int32_To_FP32(b[31:0])
dst[63:32] := Convert_Int32_To_FP32(b[63:32])
dst[95:64] := a[95:64]
dst[127:96] := a[127:96]</div></div></div><div class="intrinsic SSE" id="1723"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cvtpi32x2_ps</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cvtpi32x2_ps</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Convert packed 32-bit integers in <span class="desc_var a">a</span> to packed single-precision (32-bit) floating-point elements, store the results in the lower 2 elements of <span class="desc_var dst">dst</span>, then covert the packed 32-bit integers in <span class="desc_var a">a</span> to single-precision (32-bit) floating-point element, and store the results in the upper 2 elements of <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">dst[31:0] := Convert_Int32_To_FP32(a[31:0])
dst[63:32] := Convert_Int32_To_FP32(a[63:32])
dst[95:64] := Convert_Int32_To_FP32(b[31:0])
dst[127:96] := Convert_Int32_To_FP32(b[63:32])</div></div></div><div class="intrinsic SSE" id="1724"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cvtpi8_ps</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cvtpi8_ps</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Convert the lower packed 8-bit integers in <span class="desc_var a">a</span> to packed single-precision (32-bit) floating-point elements, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*8
	m := j*32
	dst[m+31:m] := Convert_Int8_To_FP32(a[i+7:i])
ENDFOR</div></div></div><div class="intrinsic SSE2" id="1725"><div class="instruction">cvtps2dq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvtps_epi32</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvtps_epi32</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cvtps2dq xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Convert packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> to packed 32-bit integers, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := 32*j
	dst[i+31:i] := Convert_FP32_To_Int32(a[i+31:i])
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>1</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="1728"><div class="instruction">vcvtps2dq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cvtps_epi32</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cvtps_epi32</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vcvtps2dq ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Convert packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> to packed 32-bit integers, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := 32*j
	dst[i+31:i] := Convert_FP32_To_Int32(a[i+31:i])
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>1</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1761"><div class="instruction">cvtps2pd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cvtps_pd</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cvtps_pd</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cvtps2pd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Convert packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> to packed double-precision (64-bit) floating-point elements, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := 64*j
	k := 32*j
	dst[i+63:i] := Convert_FP32_To_FP64(a[k+31:k])
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>5</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="1762"><div class="instruction">vcvtps2pd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_cvtps_pd</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_cvtps_pd</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vcvtps2pd ymm, xmm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Convert packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> to packed double-precision (64-bit) floating-point elements, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := 64*j
	k := 32*j
	dst[i+63:i] := Convert_FP32_To_FP64(a[k+31:k])
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>7</td><td>1</td></tr><tr><td>Broadwell</td><td>4</td><td>1</td></tr><tr><td>Haswell</td><td>4</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="1775"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_cvtps_pi16</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_cvtps_pi16</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Convert packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> to packed 16-bit integers, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := 16*j
	k := 32*j
	dst[i+15:i] := Convert_FP32_To_Int16(a[k+31:k])
ENDFOR</div></div></div><div class="intrinsic SSE" id="1776"><div class="instruction">cvtps2pi</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_cvtps_pi32</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_cvtps_pi32</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cvtps2pi mm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Convert packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> to packed 32-bit integers, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := 32*j
	dst[i+31:i] := Convert_FP32_To_Int32(a[i+31:i])
ENDFOR</div></div></div><div class="intrinsic SSE" id="1777"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_cvtps_pi8</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_cvtps_pi8</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Convert packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> to packed 8-bit integers, and store the results in lower 4 elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := 8*j
	k := 32*j
	dst[i+7:i] := Convert_FP32_To_Int8(a[k+31:k])
ENDFOR</div></div></div><div class="intrinsic SSE" id="1780"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cvtpu16_ps</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cvtpu16_ps</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Convert packed unsigned 16-bit integers in <span class="desc_var a">a</span> to packed single-precision (32-bit) floating-point elements, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	m := j*32
	dst[m+31:m] := Convert_UnsignedInt16_To_FP32(a[i+15:i])
ENDFOR</div></div></div><div class="intrinsic SSE" id="1781"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cvtpu8_ps</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cvtpu8_ps</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Convert the lower packed unsigned 8-bit integers in <span class="desc_var a">a</span> to packed single-precision (32-bit) floating-point elements, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*8
	m := j*32
	dst[m+31:m] := Convert_UnsignedInt8_To_FP32(a[i+7:i])
ENDFOR</div></div></div><div class="intrinsic SSE2" id="1782"><div class="instruction">movsd</div><div class="signature"><span class="sig"><span class="rettype">double</span> <span class="name">_mm_cvtsd_f64</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">double</span> <span class="name">_mm_cvtsd_f64</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: movsd m64, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Copy the lower double-precision (64-bit) floating-point element of <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := a[63:0]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="1783"><div class="instruction">movsd</div><div class="signature"><span class="sig"><span class="rettype">double</span> <span class="name">_mm256_cvtsd_f64</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">double</span> <span class="name">_mm256_cvtsd_f64</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: movsd m64, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Copy the lower double-precision (64-bit) floating-point element of <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := a[63:0]</div></div></div><div class="intrinsic SSE2" id="1787"><div class="instruction">cvtsd2si</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cvtsd_si32</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cvtsd_si32</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cvtsd2si r32, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Convert the lower double-precision (64-bit) floating-point element in <span class="desc_var a">a</span> to a 32-bit integer, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := Convert_FP64_To_Int32(a[63:0])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>6</td><td>1</td></tr><tr><td>Broadwell</td><td>4</td><td>1</td></tr><tr><td>Haswell</td><td>4</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1788"><div class="instruction">cvtsd2si</div><div class="signature"><span class="sig"><span class="rettype">__int64</span> <span class="name">_mm_cvtsd_si64</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__int64</span> <span class="name">_mm_cvtsd_si64</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cvtsd2si r64, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Convert the lower double-precision (64-bit) floating-point element in <span class="desc_var a">a</span> to a 64-bit integer, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := Convert_FP64_To_Int64(a[63:0])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>6</td><td>1</td></tr><tr><td>Broadwell</td><td>4</td><td>1</td></tr><tr><td>Haswell</td><td>4</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1789"><div class="instruction">cvtsd2si</div><div class="signature"><span class="sig"><span class="rettype">__int64</span> <span class="name">_mm_cvtsd_si64x</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__int64</span> <span class="name">_mm_cvtsd_si64x</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cvtsd2si r64, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Convert the lower double-precision (64-bit) floating-point element in <span class="desc_var a">a</span> to a 64-bit integer, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := Convert_FP64_To_Int64(a[63:0])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>6</td><td>1</td></tr><tr><td>Broadwell</td><td>4</td><td>1</td></tr><tr><td>Haswell</td><td>4</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1790"><div class="instruction">cvtsd2ss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cvtsd_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cvtsd_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cvtsd2ss xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Convert the lower double-precision (64-bit) floating-point element in <span class="desc_var b">b</span> to a single-precision (32-bit) floating-point element, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">dst[31:0] := Convert_FP64_To_FP32(b[63:0])
dst[127:32] := a[127:31]
dst[MAX:64] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>5</td><td>1</td></tr><tr><td>Broadwell</td><td>4</td><td>1</td></tr><tr><td>Haswell</td><td>4</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>4</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1868"><div class="instruction">movd</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cvtsi128_si32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cvtsi128_si32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: movd r32, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Copy the lower 32-bit integer in <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := a[31:0]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1869"><div class="instruction">movq</div><div class="signature"><span class="sig"><span class="rettype">__int64</span> <span class="name">_mm_cvtsi128_si64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__int64</span> <span class="name">_mm_cvtsi128_si64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: movq r64, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Copy the lower 64-bit integer in <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := a[63:0]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.33</td></tr><tr><td>Haswell</td><td>1</td><td>0.33</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.33</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1870"><div class="instruction">movq</div><div class="signature"><span class="sig"><span class="rettype">__int64</span> <span class="name">_mm_cvtsi128_si64x</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__int64</span> <span class="name">_mm_cvtsi128_si64x</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: movq r64, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Copy the lower 64-bit integer in <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := a[63:0]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.33</td></tr><tr><td>Haswell</td><td>1</td><td>0.33</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.33</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="1871"><div class="instruction">movd</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm256_cvtsi256_si32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm256_cvtsi256_si32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: movd r32, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Copy the lower 32-bit integer in <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := a[31:0]</div></div></div><div class="intrinsic SSE2" id="1872"><div class="instruction">cvtsi2sd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cvtsi32_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cvtsi32_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cvtsi2sd xmm, r32<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Convert the 32-bit integer <span class="desc_var b">b</span> to a double-precision (64-bit) floating-point element, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">dst[63:0] := Convert_Int32_To_FP64(b[31:0])
dst[127:64] := a[127:64]
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>5</td><td>1</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>4</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1873"><div class="instruction">movd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvtsi32_si128</span> (<span class="param_type">int</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvtsi32_si128</span> (<span class="param_type">int</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: movd xmm, r32<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Copy 32-bit integer <span class="desc_var a">a</span> to the lower elements of <span class="desc_var dst">dst</span>, and zero the upper elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := a[31:0]
dst[127:32] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic MMX" id="1874"><div class="instruction">movd</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_cvtsi32_si64</span> (<span class="param_type">int</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_cvtsi32_si64</span> (<span class="param_type">int</span> <span class="param_name">a</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: movd mm, r32<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Copy 32-bit integer <span class="desc_var a">a</span> to the lower elements of <span class="desc_var dst">dst</span>, and zero the upper element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := a[31:0]
dst[63:32] := 0</div></div></div><div class="intrinsic SSE" id="1875"><div class="instruction">cvtsi2ss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cvtsi32_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cvtsi32_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cvtsi2ss xmm, r32<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Convert the 32-bit integer <span class="desc_var b">b</span> to a single-precision (32-bit) floating-point element, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := Convert_Int32_To_FP32(b[31:0])
dst[127:32] := a[127:32]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>6</td><td>1</td></tr><tr><td>Broadwell</td><td>4</td><td>1</td></tr><tr><td>Haswell</td><td>4</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic MMX" id="1877"><div class="instruction">movq</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_cvtsi64_m64</span> (<span class="param_type">__int64</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_cvtsi64_m64</span> (<span class="param_type">__int64</span> <span class="param_name">a</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: movq mm, r64<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Copy 64-bit integer <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := a[63:0]</div></div></div><div class="intrinsic SSE2" id="1878"><div class="instruction">cvtsi2sd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cvtsi64_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__int64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cvtsi64_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__int64</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cvtsi2sd xmm, r64<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Convert the 64-bit integer <span class="desc_var b">b</span> to a double-precision (64-bit) floating-point element, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">dst[63:0] := Convert_Int64_To_FP64(b[63:0])
dst[127:64] := a[127:64]
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>5</td><td>1</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>4</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1879"><div class="instruction">movq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvtsi64_si128</span> (<span class="param_type">__int64</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvtsi64_si128</span> (<span class="param_type">__int64</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: movq xmm, r64<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Copy 64-bit integer <span class="desc_var a">a</span> to the lower element of <span class="desc_var dst">dst</span>, and zero the upper element.</div><h1>Operation</h1><div class="operation">dst[63:0] := a[63:0]
dst[127:64] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.33</td></tr><tr><td>Haswell</td><td>1</td><td>0.33</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.33</td></tr></tbody></table></div></div><div class="intrinsic MMX" id="1880"><div class="instruction">movd</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cvtsi64_si32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cvtsi64_si32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: movd r32, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Copy the lower 32-bit integer in <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := a[31:0]</div></div></div><div class="intrinsic SSE" id="1881"><div class="instruction">cvtsi2ss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cvtsi64_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__int64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_cvtsi64_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__int64</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cvtsi2ss xmm, r64<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Convert the 64-bit integer <span class="desc_var b">b</span> to a single-precision (32-bit) floating-point element, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := Convert_Int64_To_FP32(b[63:0])
dst[127:32] := a[127:32]
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>6</td><td>1</td></tr><tr><td>Broadwell</td><td>4</td><td>1</td></tr><tr><td>Haswell</td><td>4</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1882"><div class="instruction">cvtsi2sd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cvtsi64x_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__int64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cvtsi64x_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__int64</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cvtsi2sd xmm, r64<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Convert the 64-bit integer <span class="desc_var b">b</span> to a double-precision (64-bit) floating-point element, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">dst[63:0] := Convert_Int64_To_FP64(b[63:0])
dst[127:64] := a[127:64]
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>5</td><td>1</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>4</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1883"><div class="instruction">movq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvtsi64x_si128</span> (<span class="param_type">__int64</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvtsi64x_si128</span> (<span class="param_type">__int64</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: movq xmm, r64<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Copy 64-bit integer <span class="desc_var a">a</span> to the lower element of <span class="desc_var dst">dst</span>, and zero the upper element.</div><h1>Operation</h1><div class="operation">dst[63:0] := a[63:0]
dst[127:64] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.33</td></tr><tr><td>Haswell</td><td>1</td><td>0.33</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.33</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="1884"><div class="instruction">movss</div><div class="signature"><span class="sig"><span class="rettype">float</span> <span class="name">_mm_cvtss_f32</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">float</span> <span class="name">_mm_cvtss_f32</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: movss m32, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Copy the lower single-precision (32-bit) floating-point element of <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := a[31:0]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="1885"><div class="instruction">movss</div><div class="signature"><span class="sig"><span class="rettype">float</span> <span class="name">_mm256_cvtss_f32</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">float</span> <span class="name">_mm256_cvtss_f32</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: movss m32, xmm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Copy the lower single-precision (32-bit) floating-point element of <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := a[31:0]</div></div></div><div class="intrinsic SSE2" id="1889"><div class="instruction">cvtss2sd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cvtss_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_cvtss_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cvtss2sd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Convert the lower single-precision (32-bit) floating-point element in <span class="desc_var b">b</span> to a double-precision (64-bit) floating-point element, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">dst[63:0] := Convert_FP32_To_FP64(b[31:0])
dst[127:64] := a[127:64]
dst[MAX:64] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>5</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="1893"><div class="instruction">cvtss2si</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cvtss_si32</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cvtss_si32</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cvtss2si r32, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Convert the lower single-precision (32-bit) floating-point element in <span class="desc_var a">a</span> to a 32-bit integer, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := Convert_FP32_To_Int32(a[31:0])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>6</td><td>1</td></tr><tr><td>Broadwell</td><td>4</td><td>1</td></tr><tr><td>Haswell</td><td>4</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="1894"><div class="instruction">cvtss2si</div><div class="signature"><span class="sig"><span class="rettype">__int64</span> <span class="name">_mm_cvtss_si64</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__int64</span> <span class="name">_mm_cvtss_si64</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cvtss2si r64, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Convert the lower single-precision (32-bit) floating-point element in <span class="desc_var a">a</span> to a 64-bit integer, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := Convert_FP32_To_Int64(a[31:0])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>6</td><td>1</td></tr><tr><td>Broadwell</td><td>4</td><td>1</td></tr><tr><td>Haswell</td><td>4</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="1897"><div class="instruction">cvttps2pi</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_cvtt_ps2pi</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_cvtt_ps2pi</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cvttps2pi mm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Convert packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> to packed 32-bit integers with truncation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := 32*j
	dst[i+31:i] := Convert_FP32_To_Int32_Truncate(a[i+31:i])
ENDFOR</div></div></div><div class="intrinsic SSE" id="1934"><div class="instruction">cvttss2si</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cvtt_ss2si</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cvtt_ss2si</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cvttss2si r32, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Convert the lower single-precision (32-bit) floating-point element in <span class="desc_var a">a</span> to a 32-bit integer with truncation, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := Convert_FP32_To_Int32_Truncate(a[31:0])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>6</td><td>1</td></tr><tr><td>Broadwell</td><td>4</td><td>1</td></tr><tr><td>Haswell</td><td>4</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1935"><div class="instruction">cvttpd2dq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvttpd_epi32</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvttpd_epi32</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cvttpd2dq xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Convert packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> to packed 32-bit integers with truncation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := 32*j
	k := 64*j
	dst[i+31:i] := Convert_FP64_To_Int32_Truncate(a[k+63:k])
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>5</td><td>1</td></tr><tr><td>Broadwell</td><td>4</td><td>1</td></tr><tr><td>Haswell</td><td>4</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>4</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="1938"><div class="instruction">vcvttpd2dq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm256_cvttpd_epi32</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm256_cvttpd_epi32</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vcvttpd2dq xmm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Convert packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> to packed 32-bit integers with truncation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := 32*j
	k := 64*j
	dst[i+31:i] := Convert_FP64_To_Int32_Truncate(a[k+63:k])
ENDFOR
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>7</td><td>1</td></tr><tr><td>Broadwell</td><td>6</td><td>1</td></tr><tr><td>Haswell</td><td>6</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>4</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="1971"><div class="instruction">cvttpd2pi</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_cvttpd_pi32</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_cvttpd_pi32</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cvttpd2pi mm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Convert packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> to packed 32-bit integers with truncation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := 32*j
	k := 64*j
	dst[i+31:i] := Convert_FP64_To_Int32_Truncate(a[k+63:k])
ENDFOR</div></div></div><div class="intrinsic SSE2" id="1972"><div class="instruction">cvttps2dq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvttps_epi32</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_cvttps_epi32</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cvttps2dq xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Convert packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> to packed 32-bit integers with truncation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := 32*j
	dst[i+31:i] := Convert_FP32_To_Int32_Truncate(a[i+31:i])
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>1</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="1975"><div class="instruction">vcvttps2dq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cvttps_epi32</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_cvttps_epi32</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vcvttps2dq ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Convert packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> to packed 32-bit integers with truncation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := 32*j
	dst[i+31:i] := Convert_FP32_To_Int32_Truncate(a[i+31:i])
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>1</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="2008"><div class="instruction">cvttps2pi</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_cvttps_pi32</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_cvttps_pi32</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cvttps2pi mm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Convert packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> to packed 32-bit integers with truncation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := 32*j
	dst[i+31:i] := Convert_FP32_To_Int32_Truncate(a[i+31:i])
ENDFOR</div></div></div><div class="intrinsic SSE2" id="2011"><div class="instruction">cvttsd2si</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cvttsd_si32</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cvttsd_si32</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cvttsd2si r32, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Convert the lower double-precision (64-bit) floating-point element in <span class="desc_var a">a</span> to a 32-bit integer with truncation, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := Convert_FP64_To_Int32_Truncate(a[63:0])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>6</td><td>1</td></tr><tr><td>Broadwell</td><td>4</td><td>1</td></tr><tr><td>Haswell</td><td>4</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="2012"><div class="instruction">cvttsd2si</div><div class="signature"><span class="sig"><span class="rettype">__int64</span> <span class="name">_mm_cvttsd_si64</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__int64</span> <span class="name">_mm_cvttsd_si64</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cvttsd2si r64, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Convert the lower double-precision (64-bit) floating-point element in <span class="desc_var a">a</span> to a 64-bit integer with truncation, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := Convert_FP64_To_Int64_Truncate(a[63:0])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>6</td><td>1</td></tr><tr><td>Broadwell</td><td>4</td><td>1</td></tr><tr><td>Haswell</td><td>4</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="2013"><div class="instruction">cvttsd2si</div><div class="signature"><span class="sig"><span class="rettype">__int64</span> <span class="name">_mm_cvttsd_si64x</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__int64</span> <span class="name">_mm_cvttsd_si64x</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: cvttsd2si r64, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Convert the lower double-precision (64-bit) floating-point element in <span class="desc_var a">a</span> to a 64-bit integer with truncation, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := Convert_FP64_To_Int64_Truncate(a[63:0])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>6</td><td>1</td></tr><tr><td>Broadwell</td><td>4</td><td>1</td></tr><tr><td>Haswell</td><td>4</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="2018"><div class="instruction">cvttss2si</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cvttss_si32</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_cvttss_si32</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cvttss2si r32, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Convert the lower single-precision (32-bit) floating-point element in <span class="desc_var a">a</span> to a 32-bit integer with truncation, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := Convert_FP32_To_Int32_Truncate(a[31:0])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>6</td><td>1</td></tr><tr><td>Broadwell</td><td>4</td><td>1</td></tr><tr><td>Haswell</td><td>4</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="2019"><div class="instruction">cvttss2si</div><div class="signature"><span class="sig"><span class="rettype">__int64</span> <span class="name">_mm_cvttss_si64</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__int64</span> <span class="name">_mm_cvttss_si64</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: cvttss2si r64, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Convert the lower single-precision (32-bit) floating-point element in <span class="desc_var a">a</span> to a 64-bit integer with truncation, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := Convert_FP64_To_Int32_Truncate(a[31:0])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>6</td><td>1</td></tr><tr><td>Broadwell</td><td>4</td><td>1</td></tr><tr><td>Haswell</td><td>4</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="2141"><div class="instruction">divpd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_div_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_div_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: divpd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Divide packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> by packed elements in <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := 64*j
	dst[i+63:i] := a[i+63:i] / b[i+63:i]
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>38</td><td>~10</td></tr><tr><td>Skylake</td><td>14</td><td>4</td></tr><tr><td>Broadwell</td><td>&lt;14</td><td>8</td></tr><tr><td>Haswell</td><td>14-20</td><td>13</td></tr><tr><td>Ivy Bridge</td><td>15-20</td><td>14</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="2144"><div class="instruction">vdivpd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_div_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_div_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vdivpd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Divide packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> by packed elements in <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := 64*j
	dst[i+63:i] := a[i+63:i] / b[i+63:i]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>38</td><td>~10</td></tr><tr><td>Skylake</td><td>14</td><td>8</td></tr><tr><td>Broadwell</td><td>16-23</td><td>16</td></tr><tr><td>Haswell</td><td>25-35</td><td>27</td></tr><tr><td>Ivy Bridge</td><td>27-35</td><td>28</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="2150"><div class="instruction">divps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_div_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_div_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: divps xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Divide packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> by packed elements in <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := 32*j
	dst[i+31:i] := a[i+31:i] / b[i+31:i]
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>38</td><td>~10</td></tr><tr><td>Skylake</td><td>11</td><td>3</td></tr><tr><td>Broadwell</td><td>&lt;11</td><td>4</td></tr><tr><td>Haswell</td><td>&lt;13</td><td>6</td></tr><tr><td>Ivy Bridge</td><td>14-Nov</td><td>6</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="2153"><div class="instruction">vdivps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_div_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_div_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vdivps ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Divide packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> by packed elements in <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := 32*j
	dst[i+31:i] := a[i+31:i] / b[i+31:i]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>38</td><td>~10</td></tr><tr><td>Skylake</td><td>11</td><td>5</td></tr><tr><td>Broadwell</td><td>13-17</td><td>10</td></tr><tr><td>Haswell</td><td>17-21</td><td>13</td></tr><tr><td>Ivy Bridge</td><td>18-21</td><td>14</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="2171"><div class="instruction">divsd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_div_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_div_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: divsd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Divide the lower double-precision (64-bit) floating-point element in <span class="desc_var a">a</span> by the lower double-precision (64-bit) floating-point element in <span class="desc_var b">b</span>, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">dst[63:0] := a[63:0] / b[63:0]
dst[127:64] := a[127:64]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>40</td><td>~33</td></tr><tr><td>Skylake</td><td>14</td><td>4</td></tr><tr><td>Broadwell</td><td>&lt;14</td><td>5</td></tr><tr><td>Haswell</td><td>14-20</td><td>13</td></tr><tr><td>Ivy Bridge</td><td>15-20</td><td>14</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="2174"><div class="instruction">divss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_div_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_div_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: divss xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Divide the lower single-precision (32-bit) floating-point element in <span class="desc_var a">a</span> by the lower single-precision (32-bit) floating-point element in <span class="desc_var b">b</span>, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">dst[31:0] := a[31:0] / b[31:0]
dst[127:32] := a[127:32]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>25</td><td>~20</td></tr><tr><td>Skylake</td><td>11</td><td>3</td></tr><tr><td>Broadwell</td><td>&lt;11</td><td>2.5</td></tr><tr><td>Haswell</td><td>&lt;13</td><td>6</td></tr><tr><td>Ivy Bridge</td><td>14-Nov</td><td>6</td></tr></tbody></table></div></div><div class="intrinsic SSE4_1" id="2177"><div class="instruction">dppd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_dp_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_dp_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: dppd xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Conditionally multiply the packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using the high 4 bits in <span class="desc_var imm8">imm8</span>, sum the four products, and conditionally store the sum in <span class="desc_var dst">dst</span> using the low 4 bits of <span class="desc_var imm8">imm8</span>.</div><h1>Operation</h1><div class="operation">DEFINE DP(a[127:0], b[127:0], imm8[7:0]) {
	FOR j := 0 to 1
		i := j*64
		IF imm8[(4+j)%8]
			temp[i+63:i] := a[i+63:i] * b[i+63:i]
		ELSE
			temp[i+63:i] := 0
		FI
	ENDFOR
	
	sum[63:0] := temp[127:64] + temp[63:0]
	
	FOR j := 0 to 1
		i := j*64
		IF imm8[j%8]
			tmpdst[i+63:i] := sum[63:0]
		ELSE
			tmpdst[i+63:i] := 0
		FI
	ENDFOR
	RETURN tmpdst[127:0]
}
dst[127:0] := DP(a[127:0], b[127:0], imm8[7:0])</div></div></div><div class="intrinsic SSE4_1" id="2178"><div class="instruction">dpps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_dp_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_dp_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: dpps xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Conditionally multiply the packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using the high 4 bits in <span class="desc_var imm8">imm8</span>, sum the four products, and conditionally store the sum in <span class="desc_var dst">dst</span> using the low 4 bits of <span class="desc_var imm8">imm8</span>.</div><h1>Operation</h1><div class="operation">DEFINE DP(a[127:0], b[127:0], imm8[7:0]) {
	FOR j := 0 to 3
		i := j*32
		IF imm8[(4+j)%8]
			temp[i+31:i] := a[i+31:i] * b[i+31:i]
		ELSE
			temp[i+31:i] := 0
		FI
	ENDFOR
	
	sum[31:0] := (temp[127:96] + temp[95:64]) + (temp[63:32] + temp[31:0])
	
	FOR j := 0 to 3
		i := j*32
		IF imm8[j%8]
			tmpdst[i+31:i] := sum[31:0]
		ELSE
			tmpdst[i+31:i] := 0
		FI
	ENDFOR
	RETURN tmpdst[127:0]
}
dst[127:0] := DP(a[127:0], b[127:0], imm8[7:0])</div></div></div><div class="intrinsic AVX" id="2179"><div class="instruction">vdpps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_dp_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_dp_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vdpps ymm, ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Conditionally multiply the packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using the high 4 bits in <span class="desc_var imm8">imm8</span>, sum the four products, and conditionally store the sum in <span class="desc_var dst">dst</span> using the low 4 bits of <span class="desc_var imm8">imm8</span>.</div><h1>Operation</h1><div class="operation">DEFINE DP(a[127:0], b[127:0], imm8[7:0]) {
	FOR j := 0 to 3
		i := j*32
		IF imm8[(4+j)%8]
			temp[i+31:i] := a[i+31:i] * b[i+31:i]
		ELSE
			temp[i+31:i] := 0
		FI
	ENDFOR
	
	sum[31:0] := (temp[127:96] + temp[95:64]) + (temp[63:32] + temp[31:0])
	
	FOR j := 0 to 3
		i := j*32
		IF imm8[j%8]
			tmpdst[i+31:i] := sum[31:0]
		ELSE
			tmpdst[i+31:i] := 0
		FI
	ENDFOR
	RETURN tmpdst[127:0]
}
dst[127:0] := DP(a[127:0], b[127:0], imm8[7:0])
dst[255:128] := DP(a[255:128], b[255:128], imm8[7:0])
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>13</td><td>1.5</td></tr><tr><td>Broadwell</td><td>12</td><td>2</td></tr><tr><td>Haswell</td><td>14</td><td>2</td></tr><tr><td>Ivy Bridge</td><td>12</td><td>2</td></tr></tbody></table></div></div><div class="intrinsic MMX" id="2225"><div class="instruction">emms</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_m_empty</span> (<span class="param_type">void</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_m_empty</span> (<span class="param_type">void</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: emms<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Empty the MMX state, which marks the x87 FPU registers as available for use by x87 instructions. This instruction must be used at the end of all MMX technology procedures.</div></div></div><div class="intrinsic MMX" id="2226"><div class="instruction">emms</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_empty</span> (<span class="param_type">void</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_empty</span> (<span class="param_type">void</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: emms<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Empty the MMX state, which marks the x87 FPU registers as available for use by x87 instructions. This instruction must be used at the end of all MMX technology procedures.</div></div></div><div class="intrinsic SSE2" id="2420"><div class="instruction">pextrw</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_extract_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_extract_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pextrw r32, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Extract a 16-bit integer from <span class="desc_var a">a</span>, selected with <span class="desc_var imm8">imm8</span>, and store the result in the lower element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[15:0] := (a[127:0] &gt;&gt; (imm8[2:0] * 16))[15:0]
dst[31:16] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>1</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="2421"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm256_extract_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">index</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm256_extract_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">index</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Extract a 16-bit integer from <span class="desc_var a">a</span>, selected with <span class="desc_var index">index</span>, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[15:0] := (a[255:0] &gt;&gt; (index * 16))[15:0]</div></div></div><div class="intrinsic SSE4_1" id="2422"><div class="instruction">pextrd</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_extract_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_extract_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: pextrd r32, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Extract a 32-bit integer from <span class="desc_var a">a</span>, selected with <span class="desc_var imm8">imm8</span>, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := (a[127:0] &gt;&gt; (imm8[1:0] * 32))[31:0]</div></div></div><div class="intrinsic AVX" id="2423"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__int32</span> <span class="name">_mm256_extract_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">index</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__int32</span> <span class="name">_mm256_extract_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">index</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Extract a 32-bit integer from <span class="desc_var a">a</span>, selected with <span class="desc_var index">index</span>, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := (a[255:0] &gt;&gt; (index * 32))[31:0]</div></div></div><div class="intrinsic SSE4_1" id="2424"><div class="instruction">pextrq</div><div class="signature"><span class="sig"><span class="rettype">__int64</span> <span class="name">_mm_extract_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__int64</span> <span class="name">_mm_extract_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: pextrq r64, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Extract a 64-bit integer from <span class="desc_var a">a</span>, selected with <span class="desc_var imm8">imm8</span>, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := (a[127:0] &gt;&gt; (imm8[0] * 64))[63:0]</div></div></div><div class="intrinsic AVX" id="2425"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__int64</span> <span class="name">_mm256_extract_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">index</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__int64</span> <span class="name">_mm256_extract_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">index</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Extract a 64-bit integer from <span class="desc_var a">a</span>, selected with <span class="desc_var index">index</span>, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := (a[255:0] &gt;&gt; (index * 64))[63:0]</div></div></div><div class="intrinsic SSE4_1" id="2426"><div class="instruction">pextrb</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_extract_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_extract_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: pextrb r32, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Extract an 8-bit integer from <span class="desc_var a">a</span>, selected with <span class="desc_var imm8">imm8</span>, and store the result in the lower element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[7:0] := (a[127:0] &gt;&gt; (imm8[3:0] * 8))[7:0]
dst[31:8] := 0</div></div></div><div class="intrinsic AVX2" id="2427"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm256_extract_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">index</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm256_extract_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">index</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Extract an 8-bit integer from <span class="desc_var a">a</span>, selected with <span class="desc_var index">index</span>, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[7:0] := (a[255:0] &gt;&gt; (index * 8))[7:0]</div></div></div><div class="intrinsic SSE" id="2428"><div class="instruction">pextrw</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_extract_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_extract_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: pextrw r32, mm, imm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Extract a 16-bit integer from <span class="desc_var a">a</span>, selected with <span class="desc_var imm8">imm8</span>, and store the result in the lower element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[15:0] := (a[63:0] &gt;&gt; (imm8[1:0] * 16))[15:0]
dst[31:16] := 0</div></div></div><div class="intrinsic SSE4_1" id="2429"><div class="instruction">extractps</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_extract_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_extract_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: extractps r32, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Extract a single-precision (32-bit) floating-point element from <span class="desc_var a">a</span>, selected with <span class="desc_var imm8">imm8</span>, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := (a[127:0] &gt;&gt; (imm8[1:0] * 32))[31:0]</div></div></div><div class="intrinsic AVX" id="2430"><div class="instruction">vextractf128</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm256_extractf128_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm256_extractf128_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vextractf128 xmm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Extract 128 bits (composed of 2 packed double-precision (64-bit) floating-point elements) from <span class="desc_var a">a</span>, selected with <span class="desc_var imm8">imm8</span>, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">CASE imm8[7:0] OF
0: dst[127:0] := a[127:0]
1: dst[127:0] := a[255:128]
ESAC
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>1</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="2431"><div class="instruction">vextractf128</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm256_extractf128_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm256_extractf128_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vextractf128 xmm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Extract 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from <span class="desc_var a">a</span>, selected with <span class="desc_var imm8">imm8</span>, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">CASE imm8[7:0] OF
0: dst[127:0] := a[127:0]
1: dst[127:0] := a[255:128]
ESAC
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>1</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="2432"><div class="instruction">vextractf128</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm256_extractf128_si256</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm256_extractf128_si256</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vextractf128 xmm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Extract 128 bits (composed of integer data) from <span class="desc_var a">a</span>, selected with <span class="desc_var imm8">imm8</span>, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">CASE imm8[7:0] OF
0: dst[127:0] := a[127:0]
1: dst[127:0] := a[255:128]
ESAC
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>1</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="2451"><div class="instruction">vextracti128</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm256_extracti128_si256</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm256_extracti128_si256</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vextracti128 xmm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Extract 128 bits (composed of integer data) from <span class="desc_var a">a</span>, selected with <span class="desc_var imm8">imm8</span>, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">CASE imm8[7:0] OF
0: dst[127:0] := a[127:0]
1: dst[127:0] := a[255:128]
ESAC
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE4_1" id="2518"><div class="instruction">roundpd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_floor_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_floor_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: roundpd xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Round the packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> down to an integer value, and store the results as packed double-precision floating-point elements in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := FLOOR(a[i+63:i])
ENDFOR</div></div></div><div class="intrinsic AVX" id="2519"><div class="instruction">vroundpd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_floor_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_floor_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vroundpd ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Round the packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> down to an integer value, and store the results as packed double-precision floating-point elements in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := FLOOR(a[i+63:i])
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>8</td><td>1</td></tr><tr><td>Broadwell</td><td>6</td><td>2</td></tr><tr><td>Haswell</td><td>6</td><td>2</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE4_1" id="2522"><div class="instruction">roundps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_floor_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_floor_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: roundps xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Round the packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> down to an integer value, and store the results as packed single-precision floating-point elements in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := FLOOR(a[i+31:i])
ENDFOR</div></div></div><div class="intrinsic AVX" id="2523"><div class="instruction">vroundps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_floor_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_floor_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vroundps ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Round the packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> down to an integer value, and store the results as packed single-precision floating-point elements in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := FLOOR(a[i+31:i])
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>8</td><td>1</td></tr><tr><td>Broadwell</td><td>6</td><td>2</td></tr><tr><td>Haswell</td><td>6</td><td>2</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE4_1" id="2526"><div class="instruction">roundsd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_floor_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_floor_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: roundsd xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Round the lower double-precision (64-bit) floating-point element in <span class="desc_var b">b</span> down to an integer value, store the result as a double-precision floating-point element in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := FLOOR(b[63:0])
dst[127:64] := a[127:64]</div></div></div><div class="intrinsic SSE4_1" id="2527"><div class="instruction">roundss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_floor_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_floor_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: roundss xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Round the lower single-precision (32-bit) floating-point element in <span class="desc_var b">b</span> down to an integer value, store the result as a single-precision floating-point element in the lower element of <span class="desc_var dst">dst</span>, and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := FLOOR(b[31:0])
dst[127:32] := a[127:32]</div></div></div><div class="intrinsic FMA" id="2531"><div class="instruction">vfmadd132pd, vfmadd213pd, vfmadd231pd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_fmadd_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">__m128d</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_fmadd_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">__m128d</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vfmadd132pd xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmadd213pd xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmadd231pd xmm, xmm, xmm<br>CPUID Flags: <span class="cpuid">FMA</span></div><h1>Description</h1><div class="description">Multiply packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, add the intermediate result to packed elements in <span class="desc_var c">c</span>, and store the results in <span class="desc_var dst">dst</span>. 
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
ENDFOR
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>6</td><td>0.5</td></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic FMA" id="2535"><div class="instruction">vfmadd132pd, vfmadd213pd, vfmadd231pd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_fmadd_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>, <span class="param_type">__m256d</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_fmadd_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>, <span class="param_type">__m256d</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vfmadd132pd ymm, ymm, ymm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmadd213pd ymm, ymm, ymm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmadd231pd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">FMA</span></div><h1>Description</h1><div class="description">Multiply packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, add the intermediate result to packed elements in <span class="desc_var c">c</span>, and store the results in <span class="desc_var dst">dst</span>. 
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>6</td><td>0.5</td></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic FMA" id="2543"><div class="instruction">vfmadd132ps, vfmadd213ps, vfmadd231ps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_fmadd_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">__m128</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_fmadd_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">__m128</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vfmadd132ps xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmadd213ps xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmadd231ps xmm, xmm, xmm<br>CPUID Flags: <span class="cpuid">FMA</span></div><h1>Description</h1><div class="description">Multiply packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, add the intermediate result to packed elements in <span class="desc_var c">c</span>, and store the results in <span class="desc_var dst">dst</span>. 
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
ENDFOR
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>6</td><td>0.5</td></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic FMA" id="2547"><div class="instruction">vfmadd132ps, vfmadd213ps, vfmadd231ps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_fmadd_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>, <span class="param_type">__m256</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_fmadd_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>, <span class="param_type">__m256</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vfmadd132ps ymm, ymm, ymm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmadd213ps ymm, ymm, ymm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmadd231ps ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">FMA</span></div><h1>Description</h1><div class="description">Multiply packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, add the intermediate result to packed elements in <span class="desc_var c">c</span>, and store the results in <span class="desc_var dst">dst</span>. 
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>6</td><td>0.5</td></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic FMA" id="2571"><div class="instruction">vfmadd132sd, vfmadd213sd, vfmadd231sd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_fmadd_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">__m128d</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_fmadd_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">__m128d</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vfmadd132sd xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmadd213sd xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmadd231sd xmm, xmm, xmm<br>CPUID Flags: <span class="cpuid">FMA</span></div><h1>Description</h1><div class="description">Multiply the lower double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and add the intermediate result to the lower element in <span class="desc_var c">c</span>. Store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">dst[63:0] := (a[63:0] * b[63:0]) + c[63:0]
dst[127:64] := a[127:64]
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>6</td><td>0.5</td></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic FMA" id="2575"><div class="instruction">vfmadd132ss, vfmadd213ss, vfmadd231ss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_fmadd_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">__m128</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_fmadd_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">__m128</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vfmadd132ss xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmadd213ss xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmadd231ss xmm, xmm, xmm<br>CPUID Flags: <span class="cpuid">FMA</span></div><h1>Description</h1><div class="description">Multiply the lower single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and add the intermediate result to the lower element in <span class="desc_var c">c</span>. Store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">dst[31:0] := (a[31:0] * b[31:0]) + c[31:0]
dst[127:32] := a[127:32]
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>6</td><td>0.5</td></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic FMA" id="2585"><div class="instruction">vfmaddsub132pd, vfmaddsub213pd, vfmaddsub231pd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_fmaddsub_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">__m128d</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_fmaddsub_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">__m128d</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vfmaddsub132pd xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmaddsub213pd xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmaddsub231pd xmm, xmm, xmm<br>CPUID Flags: <span class="cpuid">FMA</span></div><h1>Description</h1><div class="description">Multiply packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, alternatively add and subtract packed elements in <span class="desc_var c">c</span> to/from the intermediate result, and store the results in <span class="desc_var dst">dst</span>. 
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	IF (j % 1 == 0) 
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
	ELSE
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>6</td><td>0.5</td></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic FMA" id="2589"><div class="instruction">vfmaddsub132pd, vfmaddsub213pd, vfmaddsub231pd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_fmaddsub_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>, <span class="param_type">__m256d</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_fmaddsub_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>, <span class="param_type">__m256d</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vfmaddsub132pd ymm, ymm, ymm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmaddsub213pd ymm, ymm, ymm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmaddsub231pd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">FMA</span></div><h1>Description</h1><div class="description">Multiply packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, alternatively add and subtract packed elements in <span class="desc_var c">c</span> to/from the intermediate result, and store the results in <span class="desc_var dst">dst</span>. 
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	IF (j % 1 == 0) 
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
	ELSE
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>6</td><td>0.5</td></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic FMA" id="2597"><div class="instruction">vfmaddsub132ps, vfmaddsub213ps, vfmaddsub231ps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_fmaddsub_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">__m128</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_fmaddsub_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">__m128</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vfmaddsub132ps xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmaddsub213ps xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmaddsub231ps xmm, xmm, xmm<br>CPUID Flags: <span class="cpuid">FMA</span></div><h1>Description</h1><div class="description">Multiply packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, alternatively add and subtract packed elements in <span class="desc_var c">c</span> to/from the intermediate result, and store the results in <span class="desc_var dst">dst</span>. 
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	IF (j % 1 == 0) 
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
	ELSE
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>6</td><td>0.5</td></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic FMA" id="2601"><div class="instruction">vfmaddsub132ps, vfmaddsub213ps, vfmaddsub231ps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_fmaddsub_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>, <span class="param_type">__m256</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_fmaddsub_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>, <span class="param_type">__m256</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vfmaddsub132ps ymm, ymm, ymm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmaddsub213ps ymm, ymm, ymm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmaddsub231ps ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">FMA</span></div><h1>Description</h1><div class="description">Multiply packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, alternatively add and subtract packed elements in <span class="desc_var c">c</span> to/from the intermediate result, and store the results in <span class="desc_var dst">dst</span>. 
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	IF (j % 1 == 0) 
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
	ELSE
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>6</td><td>0.5</td></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic FMA" id="2617"><div class="instruction">vfmsub132pd, vfmsub213pd, vfmsub231pd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_fmsub_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">__m128d</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_fmsub_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">__m128d</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vfmsub132pd xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmsub213pd xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmsub231pd xmm, xmm, xmm<br>CPUID Flags: <span class="cpuid">FMA</span></div><h1>Description</h1><div class="description">Multiply packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, subtract packed elements in <span class="desc_var c">c</span> from the intermediate result, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
ENDFOR
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>6</td><td>0.5</td></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic FMA" id="2621"><div class="instruction">vfmsub132pd, vfmsub213pd, vfmsub231pd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_fmsub_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>, <span class="param_type">__m256d</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_fmsub_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>, <span class="param_type">__m256d</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vfmsub132pd ymm, ymm, ymm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmsub213pd ymm, ymm, ymm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmsub231pd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">FMA</span></div><h1>Description</h1><div class="description">Multiply packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, subtract packed elements in <span class="desc_var c">c</span> from the intermediate result, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>6</td><td>0.5</td></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic FMA" id="2629"><div class="instruction">vfmsub132ps, vfmsub213ps, vfmsub231ps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_fmsub_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">__m128</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_fmsub_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">__m128</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vfmsub132ps xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmsub213ps xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmsub231ps xmm, xmm, xmm<br>CPUID Flags: <span class="cpuid">FMA</span></div><h1>Description</h1><div class="description">Multiply packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, subtract packed elements in <span class="desc_var c">c</span> from the intermediate result, and store the results in <span class="desc_var dst">dst</span>. 
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
ENDFOR
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>6</td><td>0.5</td></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic FMA" id="2633"><div class="instruction">vfmsub132ps, vfmsub213ps, vfmsub231ps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_fmsub_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>, <span class="param_type">__m256</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_fmsub_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>, <span class="param_type">__m256</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vfmsub132ps ymm, ymm, ymm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmsub213ps ymm, ymm, ymm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmsub231ps ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">FMA</span></div><h1>Description</h1><div class="description">Multiply packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, subtract packed elements in <span class="desc_var c">c</span> from the intermediate result, and store the results in <span class="desc_var dst">dst</span>. 
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>6</td><td>0.5</td></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic FMA" id="2657"><div class="instruction">vfmsub132sd, vfmsub213sd, vfmsub231sd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_fmsub_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">__m128d</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_fmsub_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">__m128d</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vfmsub132sd xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmsub213sd xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmsub231sd xmm, xmm, xmm<br>CPUID Flags: <span class="cpuid">FMA</span></div><h1>Description</h1><div class="description">Multiply the lower double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and subtract the lower element in <span class="desc_var c">c</span> from the intermediate result. Store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := (a[63:0] * b[63:0]) - c[63:0]
dst[127:64] := a[127:64]
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>6</td><td>0.5</td></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic FMA" id="2661"><div class="instruction">vfmsub132ss, vfmsub213ss, vfmsub231ss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_fmsub_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">__m128</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_fmsub_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">__m128</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vfmsub132ss xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmsub213ss xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmsub231ss xmm, xmm, xmm<br>CPUID Flags: <span class="cpuid">FMA</span></div><h1>Description</h1><div class="description">Multiply the lower single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and subtract the lower element in <span class="desc_var c">c</span> from the intermediate result. Store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := (a[31:0] * b[31:0]) - c[31:0]
dst[127:32] := a[127:32]
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>6</td><td>0.5</td></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic FMA" id="2665"><div class="instruction">vfmsubadd132pd, vfmsubadd213pd, vfmsubadd231pd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_fmsubadd_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">__m128d</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_fmsubadd_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">__m128d</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vfmsubadd132pd xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmsubadd213pd xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmsubadd231pd xmm, xmm, xmm<br>CPUID Flags: <span class="cpuid">FMA</span></div><h1>Description</h1><div class="description">Multiply packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, alternatively subtract and add packed elements in <span class="desc_var c">c</span> from/to the intermediate result, and store the results in <span class="desc_var dst">dst</span>. 
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	IF (j % 1 == 0) 
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
	ELSE
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>6</td><td>0.5</td></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic FMA" id="2669"><div class="instruction">vfmsubadd132pd, vfmsubadd213pd, vfmsubadd231pd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_fmsubadd_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>, <span class="param_type">__m256d</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_fmsubadd_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>, <span class="param_type">__m256d</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vfmsubadd132pd ymm, ymm, ymm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmsubadd213pd ymm, ymm, ymm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmsubadd231pd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">FMA</span></div><h1>Description</h1><div class="description">Multiply packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, alternatively subtract and add packed elements in <span class="desc_var c">c</span> from/to the intermediate result, and store the results in <span class="desc_var dst">dst</span>. 
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	IF (j % 1 == 0) 
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
	ELSE
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>6</td><td>0.5</td></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic FMA" id="2677"><div class="instruction">vfmsubadd132ps, vfmsubadd213ps, vfmsubadd231ps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_fmsubadd_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">__m128</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_fmsubadd_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">__m128</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vfmsubadd132ps xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmsubadd213ps xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmsubadd231ps xmm, xmm, xmm<br>CPUID Flags: <span class="cpuid">FMA</span></div><h1>Description</h1><div class="description">Multiply packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, alternatively subtract and add packed elements in <span class="desc_var c">c</span> from/to the intermediate result, and store the results in <span class="desc_var dst">dst</span>. 
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	IF (j % 1 == 0) 
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
	ELSE
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>6</td><td>0.5</td></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic FMA" id="2681"><div class="instruction">vfmsubadd132ps, vfmsubadd213ps, vfmsubadd231ps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_fmsubadd_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>, <span class="param_type">__m256</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_fmsubadd_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>, <span class="param_type">__m256</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vfmsubadd132ps ymm, ymm, ymm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmsubadd213ps ymm, ymm, ymm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfmsubadd231ps ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">FMA</span></div><h1>Description</h1><div class="description">Multiply packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, alternatively subtract and add packed elements in <span class="desc_var c">c</span> from/to the intermediate result, and store the results in <span class="desc_var dst">dst</span>. 
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	IF (j % 1 == 0) 
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
	ELSE
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>6</td><td>0.5</td></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic FMA" id="2697"><div class="instruction">vfnmadd132pd, vfnmadd213pd, vfnmadd231pd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_fnmadd_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">__m128d</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_fnmadd_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">__m128d</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vfnmadd132pd xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfnmadd213pd xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfnmadd231pd xmm, xmm, xmm<br>CPUID Flags: <span class="cpuid">FMA</span></div><h1>Description</h1><div class="description">Multiply packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, add the negated intermediate result to packed elements in <span class="desc_var c">c</span>, and store the results in <span class="desc_var dst">dst</span>. 
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := -(a[i+63:i] * b[i+63:i]) + c[i+63:i]
ENDFOR	
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>6</td><td>0.5</td></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic FMA" id="2701"><div class="instruction">vfnmadd132pd, vfnmadd213pd, vfnmadd231pd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_fnmadd_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>, <span class="param_type">__m256d</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_fnmadd_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>, <span class="param_type">__m256d</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vfnmadd132pd ymm, ymm, ymm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfnmadd213pd ymm, ymm, ymm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfnmadd231pd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">FMA</span></div><h1>Description</h1><div class="description">Multiply packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, add the negated intermediate result to packed elements in <span class="desc_var c">c</span>, and store the results in <span class="desc_var dst">dst</span>. 
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := -(a[i+63:i] * b[i+63:i]) + c[i+63:i]
ENDFOR	
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>6</td><td>0.5</td></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic FMA" id="2709"><div class="instruction">vfnmadd132ps, vfnmadd213ps, vfnmadd231ps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_fnmadd_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">__m128</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_fnmadd_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">__m128</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vfnmadd132ps xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfnmadd213ps xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfnmadd231ps xmm, xmm, xmm<br>CPUID Flags: <span class="cpuid">FMA</span></div><h1>Description</h1><div class="description">Multiply packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, add the negated intermediate result to packed elements in <span class="desc_var c">c</span>, and store the results in <span class="desc_var dst">dst</span>. 
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	a[i+31:i] := -(a[i+31:i] * b[i+31:i]) + c[i+31:i]
ENDFOR	
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>6</td><td>0.5</td></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic FMA" id="2713"><div class="instruction">vfnmadd132ps, vfnmadd213ps, vfnmadd231ps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_fnmadd_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>, <span class="param_type">__m256</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_fnmadd_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>, <span class="param_type">__m256</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vfnmadd132ps ymm, ymm, ymm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfnmadd213ps ymm, ymm, ymm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfnmadd231ps ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">FMA</span></div><h1>Description</h1><div class="description">Multiply packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, add the negated intermediate result to packed elements in <span class="desc_var c">c</span>, and store the results in <span class="desc_var dst">dst</span>. 
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	a[i+31:i] := -(a[i+31:i] * b[i+31:i]) + c[i+31:i]
ENDFOR	
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>6</td><td>0.5</td></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic FMA" id="2737"><div class="instruction">vfnmadd132sd, vfnmadd213sd, vfnmadd231sd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_fnmadd_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">__m128d</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_fnmadd_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">__m128d</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vfnmadd132sd xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfnmadd213sd xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfnmadd231sd xmm, xmm, xmm<br>CPUID Flags: <span class="cpuid">FMA</span></div><h1>Description</h1><div class="description">Multiply the lower double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and add the negated intermediate result to the lower element in <span class="desc_var c">c</span>. Store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := -(a[63:0] * b[63:0]) + c[63:0]
dst[127:64] := a[127:64]
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>6</td><td>0.5</td></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic FMA" id="2741"><div class="instruction">vfnmadd132ss, vfnmadd213ss, vfnmadd231ss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_fnmadd_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">__m128</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_fnmadd_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">__m128</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vfnmadd132ss xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfnmadd213ss xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfnmadd231ss xmm, xmm, xmm<br>CPUID Flags: <span class="cpuid">FMA</span></div><h1>Description</h1><div class="description">Multiply the lower single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and add the negated intermediate result to the lower element in <span class="desc_var c">c</span>. Store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := -(a[31:0] * b[31:0]) + c[31:0]
dst[127:32] := a[127:32]
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>6</td><td>0.5</td></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic FMA" id="2745"><div class="instruction">vfnmsub132pd, vfnmsub213pd, vfnmsub231pd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_fnmsub_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">__m128d</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_fnmsub_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">__m128d</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vfnmsub132pd xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfnmsub213pd xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfnmsub231pd xmm, xmm, xmm<br>CPUID Flags: <span class="cpuid">FMA</span></div><h1>Description</h1><div class="description">Multiply packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, subtract packed elements in <span class="desc_var c">c</span> from the negated intermediate result, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := -(a[i+63:i] * b[i+63:i]) - c[i+63:i]
ENDFOR	
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>6</td><td>0.5</td></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic FMA" id="2749"><div class="instruction">vfnmsub132pd, vfnmsub213pd, vfnmsub231pd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_fnmsub_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>, <span class="param_type">__m256d</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_fnmsub_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>, <span class="param_type">__m256d</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vfnmsub132pd ymm, ymm, ymm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfnmsub213pd ymm, ymm, ymm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfnmsub231pd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">FMA</span></div><h1>Description</h1><div class="description">Multiply packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, subtract packed elements in <span class="desc_var c">c</span> from the negated intermediate result, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := -(a[i+63:i] * b[i+63:i]) - c[i+63:i]
ENDFOR	
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>6</td><td>0.5</td></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic FMA" id="2757"><div class="instruction">vfnmsub132ps, vfnmsub213ps, vfnmsub231ps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_fnmsub_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">__m128</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_fnmsub_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">__m128</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vfnmsub132ps xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfnmsub213ps xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfnmsub231ps xmm, xmm, xmm<br>CPUID Flags: <span class="cpuid">FMA</span></div><h1>Description</h1><div class="description">Multiply packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, subtract packed elements in <span class="desc_var c">c</span> from the negated intermediate result, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := -(a[i+31:i] * b[i+31:i]) - c[i+31:i]
ENDFOR	
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>6</td><td>0.5</td></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic FMA" id="2761"><div class="instruction">vfnmsub132ps, vfnmsub213ps, vfnmsub231ps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_fnmsub_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>, <span class="param_type">__m256</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_fnmsub_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>, <span class="param_type">__m256</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vfnmsub132ps ymm, ymm, ymm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfnmsub213ps ymm, ymm, ymm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfnmsub231ps ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">FMA</span></div><h1>Description</h1><div class="description">Multiply packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, subtract packed elements in <span class="desc_var c">c</span> from the negated intermediate result, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := -(a[i+31:i] * b[i+31:i]) - c[i+31:i]
ENDFOR	
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>6</td><td>0.5</td></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic FMA" id="2785"><div class="instruction">vfnmsub132sd, vfnmsub213sd, vfnmsub231sd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_fnmsub_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">__m128d</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_fnmsub_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">__m128d</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vfnmsub132sd xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfnmsub213sd xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfnmsub231sd xmm, xmm, xmm<br>CPUID Flags: <span class="cpuid">FMA</span></div><h1>Description</h1><div class="description">Multiply the lower double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and subtract the lower element in <span class="desc_var c">c</span> from the negated intermediate result. Store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := -(a[63:0] * b[63:0]) - c[63:0]
dst[127:64] := a[127:64]
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>6</td><td>0.5</td></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic FMA" id="2789"><div class="instruction">vfnmsub132ss, vfnmsub213ss, vfnmsub231ss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_fnmsub_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">__m128</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_fnmsub_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">__m128</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vfnmsub132ss xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfnmsub213ss xmm, xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfnmsub231ss xmm, xmm, xmm<br>CPUID Flags: <span class="cpuid">FMA</span></div><h1>Description</h1><div class="description">Multiply the lower single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and subtract the lower element in <span class="desc_var c">c</span> from the negated intermediate result. Store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := -(a[31:0] * b[31:0]) - c[31:0]
dst[127:32] := a[127:32]
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>6</td><td>0.5</td></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="2809"><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_free</span> (<span class="param_type">void *</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_free</span> (<span class="param_type">void *</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Free aligned memory that was allocated with <span class="desc_var _mm_malloc">_mm_malloc</span>.</div></div></div><div class="intrinsic MMX" id="2810"><div class="instruction">movd</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_from_int</span> (<span class="param_type">int</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_from_int</span> (<span class="param_type">int</span> <span class="param_name">a</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: movd mm, r32<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Copy 32-bit integer <span class="desc_var a">a</span> to the lower elements of <span class="desc_var dst">dst</span>, and zero the upper element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := a[31:0]
dst[63:32] := 0</div></div></div><div class="intrinsic MMX" id="2811"><div class="instruction">movq</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_from_int64</span> (<span class="param_type">__int64</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_from_int64</span> (<span class="param_type">__int64</span> <span class="param_name">a</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: movq mm, r64<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Copy 64-bit integer <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := a[63:0]</div></div></div><div class="intrinsic SSE" id="2816"><div class="signature"><span class="sig"><span class="rettype">unsigned int</span> <span class="name">_MM_GET_EXCEPTION_MASK</span> ()</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">unsigned int</span> <span class="name">_MM_GET_EXCEPTION_MASK</span> ()</span><br>#include &lt;xmmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Macro: Get the exception mask bits from the MXCSR control and status register. The exception mask may contain any of the following flags: _MM_MASK_INVALID, _MM_MASK_DIV_ZERO, _MM_MASK_DENORM, _MM_MASK_OVERFLOW, _MM_MASK_UNDERFLOW, _MM_MASK_INEXACT</div><h1>Operation</h1><div class="operation">dst[31:0] := MXCSR &amp; _MM_MASK_MASK</div></div></div><div class="intrinsic SSE" id="2817"><div class="signature"><span class="sig"><span class="rettype">unsigned int</span> <span class="name">_MM_GET_EXCEPTION_STATE</span> ()</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">unsigned int</span> <span class="name">_MM_GET_EXCEPTION_STATE</span> ()</span><br>#include &lt;xmmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Macro: Get the exception state bits from the MXCSR control and status register. The exception state may contain any of the following flags: _MM_EXCEPT_INVALID, _MM_EXCEPT_DIV_ZERO, _MM_EXCEPT_DENORM, _MM_EXCEPT_OVERFLOW, _MM_EXCEPT_UNDERFLOW, _MM_EXCEPT_INEXACT</div><h1>Operation</h1><div class="operation">dst[31:0] := MXCSR &amp; _MM_EXCEPT_MASK</div></div></div><div class="intrinsic SSE" id="2818"><div class="signature"><span class="sig"><span class="rettype">unsigned int</span> <span class="name">_MM_GET_FLUSH_ZERO_MODE</span> ()</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">unsigned int</span> <span class="name">_MM_GET_FLUSH_ZERO_MODE</span> ()</span><br>#include &lt;xmmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Macro: Get the flush zero bits from the MXCSR control and status register. The flush zero may contain any of the following flags: _MM_FLUSH_ZERO_ON or _MM_FLUSH_ZERO_OFF</div><h1>Operation</h1><div class="operation">dst[31:0] := MXCSR &amp; _MM_FLUSH_MASK</div></div></div><div class="intrinsic SSE" id="2819"><div class="signature"><span class="sig"><span class="rettype">unsigned int</span> <span class="name">_MM_GET_ROUNDING_MODE</span> ()</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">unsigned int</span> <span class="name">_MM_GET_ROUNDING_MODE</span> ()</span><br>#include &lt;xmmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Macro: Get the rounding mode bits from the MXCSR control and status register. The rounding mode may contain any of the following flags: _MM_ROUND_NEAREST, _MM_ROUND_DOWN, _MM_ROUND_UP, _MM_ROUND_TOWARD_ZERO</div><h1>Operation</h1><div class="operation">dst[31:0] := MXCSR &amp; _MM_ROUND_MASK</div></div></div><div class="intrinsic SSE" id="2822"><div class="instruction">stmxcsr</div><div class="signature"><span class="sig"><span class="rettype">unsigned int</span> <span class="name">_mm_getcsr</span> (<span class="param_type">void</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">unsigned int</span> <span class="name">_mm_getcsr</span> (<span class="param_type">void</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: stmxcsr MEMd<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Get the unsigned 32-bit value of the MXCSR control and status register.</div><h1>Operation</h1><div class="operation">dst[31:0] := MXCSR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>-</td><td>1</td></tr><tr><td>Broadwell</td><td>-</td><td>1</td></tr><tr><td>Haswell</td><td>-</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>-</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSSE3" id="2932"><div class="instruction">phaddw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_hadd_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_hadd_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: phaddw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Horizontally add adjacent pairs of 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and pack the signed 16-bit results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[15:0] := a[31:16] + a[15:0]
dst[31:16] := a[63:48] + a[47:32]
dst[47:32] := a[95:80] + a[79:64]
dst[63:48] := a[127:112] + a[111:96]
dst[79:64] := b[31:16] + b[15:0]
dst[95:80] := b[63:48] + b[47:32]
dst[111:96] := b[95:80] + b[79:64]
dst[127:112] := b[127:112] + b[111:96]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>2</td></tr><tr><td>Broadwell</td><td>3</td><td>2</td></tr><tr><td>Haswell</td><td>3</td><td>2</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="2933"><div class="instruction">vphaddw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_hadd_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_hadd_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vphaddw ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Horizontally add adjacent pairs of 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and pack the signed 16-bit results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[15:0] := a[31:16] + a[15:0]
dst[31:16] := a[63:48] + a[47:32]
dst[47:32] := a[95:80] + a[79:64]
dst[63:48] := a[127:112] + a[111:96]
dst[79:64] := b[31:16] + b[15:0]
dst[95:80] := b[63:48] + b[47:32]
dst[111:96] := b[95:80] + b[79:64]
dst[127:112] := b[127:112] + b[111:96]
dst[143:128] := a[159:144] + a[143:128]
dst[159:144] := a[191:176] + a[175:160]
dst[175:160] := a[223:208] + a[207:192]
dst[191:176] := a[255:240] + a[239:224]
dst[207:192] := b[127:112] + b[143:128]
dst[223:208] := b[159:144] + b[175:160]
dst[239:224] := b[191:176] + b[207:192]
dst[255:240] := b[223:208] + b[239:224]
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>2</td></tr><tr><td>Broadwell</td><td>3</td><td>2</td></tr><tr><td>Haswell</td><td>3</td><td>2</td></tr></tbody></table></div></div><div class="intrinsic SSSE3" id="2934"><div class="instruction">phaddd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_hadd_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_hadd_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: phaddd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Horizontally add adjacent pairs of 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and pack the signed 32-bit results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := a[63:32] + a[31:0]
dst[63:32] := a[127:96] + a[95:64]
dst[95:64] := b[63:32] + b[31:0]
dst[127:96] := b[127:96] + b[95:64]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>2</td></tr><tr><td>Broadwell</td><td>3</td><td>2</td></tr><tr><td>Haswell</td><td>3</td><td>2</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="2935"><div class="instruction">vphaddd</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_hadd_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_hadd_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vphaddd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Horizontally add adjacent pairs of 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and pack the signed 32-bit results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := a[63:32] + a[31:0]
dst[63:32] := a[127:96] + a[95:64]
dst[95:64] := b[63:32] + b[31:0]
dst[127:96] := b[127:96] + b[95:64]
dst[159:128] := a[191:160] + a[159:128]
dst[191:160] := a[255:224] + a[223:192]
dst[223:192] := b[191:160] + b[159:128]
dst[255:224] := b[255:224] + b[223:192]
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>2</td></tr><tr><td>Broadwell</td><td>3</td><td>2</td></tr><tr><td>Haswell</td><td>3</td><td>2</td></tr></tbody></table></div></div><div class="intrinsic SSE3" id="2936"><div class="instruction">haddpd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_hadd_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_hadd_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;pmmintrin.h&gt;<br>Instruction: haddpd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE3</span></div><h1>Description</h1><div class="description">Horizontally add adjacent pairs of double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and pack the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := a[127:64] + a[63:0]
dst[127:64] := b[127:64] + b[63:0]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>6</td><td>2</td></tr><tr><td>Broadwell</td><td>5</td><td>2</td></tr><tr><td>Haswell</td><td>5</td><td>2</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>2</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="2937"><div class="instruction">vhaddpd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_hadd_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_hadd_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vhaddpd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Horizontally add adjacent pairs of double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and pack the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := a[127:64] + a[63:0]
dst[127:64] := b[127:64] + b[63:0]
dst[191:128] := a[255:192] + a[191:128]
dst[255:192] := b[255:192] + b[191:128]
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSSE3" id="2938"><div class="instruction">phaddw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_hadd_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_hadd_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: phaddw mm, mm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Horizontally add adjacent pairs of 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and pack the signed 16-bit results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[15:0] := a[31:16] + a[15:0]
dst[31:16] := a[63:48] + a[47:32]
dst[47:32] := b[31:16] + b[15:0]
dst[63:48] := b[63:48] + b[47:32]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>2</td></tr><tr><td>Broadwell</td><td>3</td><td>2</td></tr><tr><td>Haswell</td><td>3</td><td>2</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1.5</td></tr></tbody></table></div></div><div class="intrinsic SSSE3" id="2939"><div class="instruction">phaddw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_hadd_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_hadd_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: phaddw mm, mm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Horizontally add adjacent pairs of 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and pack the signed 32-bit results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := a[63:32] + a[31:0]
dst[63:32] := b[63:32] + b[31:0]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>2</td></tr><tr><td>Broadwell</td><td>3</td><td>2</td></tr><tr><td>Haswell</td><td>3</td><td>2</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1.5</td></tr></tbody></table></div></div><div class="intrinsic SSE3" id="2940"><div class="instruction">haddps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_hadd_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_hadd_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;pmmintrin.h&gt;<br>Instruction: haddps xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE3</span></div><h1>Description</h1><div class="description">Horizontally add adjacent pairs of single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and pack the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := a[63:32] + a[31:0]
dst[63:32] := a[127:96] + a[95:64]
dst[95:64] := b[63:32] + b[31:0]
dst[127:96] := b[127:96] + b[95:64]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>6</td><td>2</td></tr><tr><td>Broadwell</td><td>5</td><td>2</td></tr><tr><td>Haswell</td><td>5</td><td>2</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>2</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="2941"><div class="instruction">vhaddps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_hadd_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_hadd_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vhaddps ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Horizontally add adjacent pairs of single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and pack the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := a[63:32] + a[31:0]
dst[63:32] := a[127:96] + a[95:64]
dst[95:64] := b[63:32] + b[31:0]
dst[127:96] := b[127:96] + b[95:64]
dst[159:128] := a[191:160] + a[159:128]
dst[191:160] := a[255:224] + a[223:192]
dst[223:192] := b[191:160] + b[159:128]
dst[255:224] := b[255:224] + b[223:192]
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSSE3" id="2942"><div class="instruction">phaddsw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_hadds_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_hadds_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: phaddsw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Horizontally add adjacent pairs of 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and pack the signed 16-bit results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[15:0] := Saturate_To_Int16(a[31:16] + a[15:0])
dst[31:16] := Saturate_To_Int16(a[63:48] + a[47:32])
dst[47:32] := Saturate_To_Int16(a[95:80] + a[79:64])
dst[63:48] := Saturate_To_Int16(a[127:112] + a[111:96])
dst[79:64] := Saturate_To_Int16(b[31:16] + b[15:0])
dst[95:80] := Saturate_To_Int16(b[63:48] + b[47:32])
dst[111:96] := Saturate_To_Int16(b[95:80] + b[79:64])
dst[127:112] := Saturate_To_Int16(b[127:112] + b[111:96])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>2</td></tr><tr><td>Broadwell</td><td>3</td><td>2</td></tr><tr><td>Haswell</td><td>3</td><td>2</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="2943"><div class="instruction">vphaddsw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_hadds_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_hadds_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vphaddsw ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Horizontally add adjacent pairs of 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and pack the signed 16-bit results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[15:0] := Saturate_To_Int16(a[31:16] + a[15:0])
dst[31:16] := Saturate_To_Int16(a[63:48] + a[47:32])
dst[47:32] := Saturate_To_Int16(a[95:80] + a[79:64])
dst[63:48] := Saturate_To_Int16(a[127:112] + a[111:96])
dst[79:64] := Saturate_To_Int16(b[31:16] + b[15:0])
dst[95:80] := Saturate_To_Int16(b[63:48] + b[47:32])
dst[111:96] := Saturate_To_Int16(b[95:80] + b[79:64])
dst[127:112] := Saturate_To_Int16(b[127:112] + b[111:96])
dst[143:128] := Saturate_To_Int16(a[159:144] + a[143:128])
dst[159:144] := Saturate_To_Int16(a[191:176] + a[175:160])
dst[175:160] := Saturate_To_Int16(a[223:208] + a[207:192])
dst[191:176] := Saturate_To_Int16(a[255:240] + a[239:224])
dst[207:192] := Saturate_To_Int16(b[127:112] + b[143:128])
dst[223:208] := Saturate_To_Int16(b[159:144] + b[175:160])
dst[239:224] := Saturate_To_Int16(b[191:160] + b[159:128])
dst[255:240] := Saturate_To_Int16(b[255:240] + b[239:224])
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>2</td></tr><tr><td>Broadwell</td><td>3</td><td>2</td></tr><tr><td>Haswell</td><td>3</td><td>2</td></tr></tbody></table></div></div><div class="intrinsic SSSE3" id="2944"><div class="instruction">phaddsw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_hadds_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_hadds_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: phaddsw mm, mm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Horizontally add adjacent pairs of 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and pack the signed 16-bit results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[15:0] := Saturate_To_Int16(a[31:16] + a[15:0])
dst[31:16] := Saturate_To_Int16(a[63:48] + a[47:32])
dst[47:32] := Saturate_To_Int16(b[31:16] + b[15:0])
dst[63:48] := Saturate_To_Int16(b[63:48] + b[47:32])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>2</td></tr><tr><td>Broadwell</td><td>3</td><td>2</td></tr><tr><td>Haswell</td><td>3</td><td>2</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1.5</td></tr></tbody></table></div></div><div class="intrinsic SSSE3" id="2945"><div class="instruction">phsubw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_hsub_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_hsub_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: phsubw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Horizontally subtract adjacent pairs of 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and pack the signed 16-bit results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[15:0] := a[15:0] - a[31:16]
dst[31:16] := a[47:32] - a[63:48]
dst[47:32] := a[79:64] - a[95:80]
dst[63:48] := a[111:96] - a[127:112]
dst[79:64] := b[15:0] - b[31:16]
dst[95:80] := b[47:32] - b[63:48]
dst[111:96] := b[79:64] - b[95:80]
dst[127:112] := b[111:96] - b[127:112]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>2</td></tr><tr><td>Broadwell</td><td>3</td><td>2</td></tr><tr><td>Haswell</td><td>3</td><td>2</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="2946"><div class="instruction">vphsubw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_hsub_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_hsub_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vphsubw ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Horizontally subtract adjacent pairs of 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and pack the signed 16-bit results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[15:0] := a[15:0] - a[31:16]
dst[31:16] := a[47:32] - a[63:48]
dst[47:32] := a[79:64] - a[95:80]
dst[63:48] := a[111:96] - a[127:112]
dst[79:64] := b[15:0] - b[31:16]
dst[95:80] := b[47:32] - b[63:48]
dst[111:96] := b[79:64] - b[95:80]
dst[127:112] := b[111:96] - b[127:112]
dst[143:128] := a[143:128] - a[159:144]
dst[159:144] := a[175:160] - a[191:176]
dst[175:160] := a[207:192] - a[223:208]
dst[191:176] := a[239:224] - a[255:240]
dst[207:192] := b[143:128] - b[159:144]
dst[223:208] := b[175:160] - b[191:176]
dst[239:224] := b[207:192] - b[223:208]
dst[255:240] := b[239:224] - b[255:240]
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSSE3" id="2947"><div class="instruction">phsubd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_hsub_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_hsub_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: phsubd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Horizontally subtract adjacent pairs of 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and pack the signed 32-bit results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := a[31:0] - a[63:32]
dst[63:32] := a[95:64] - a[127:96]
dst[95:64] := b[31:0] - b[63:32]
dst[127:96] := b[95:64] - b[127:96]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>2</td></tr><tr><td>Broadwell</td><td>3</td><td>2</td></tr><tr><td>Haswell</td><td>3</td><td>2</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="2948"><div class="instruction">vphsubd</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_hsub_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_hsub_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vphsubd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Horizontally subtract adjacent pairs of 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and pack the signed 32-bit results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := a[31:0] - a[63:32]
dst[63:32] := a[95:64] - a[127:96]
dst[95:64] := b[31:0] - b[63:32]
dst[127:96] := b[95:64] - b[127:96]
dst[159:128] := a[159:128] - a[191:160]
dst[191:160] := a[223:192] - a[255:224]
dst[223:192] := b[159:128] - b[191:160]
dst[255:224] := b[223:192] - b[255:224]
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE3" id="2949"><div class="instruction">hsubpd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_hsub_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_hsub_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;pmmintrin.h&gt;<br>Instruction: hsubpd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE3</span></div><h1>Description</h1><div class="description">Horizontally subtract adjacent pairs of double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and pack the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := a[63:0] - a[127:64]
dst[127:64] := b[63:0] - b[127:64]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>6</td><td>2</td></tr><tr><td>Broadwell</td><td>5</td><td>2</td></tr><tr><td>Haswell</td><td>5</td><td>2</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>2</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="2950"><div class="instruction">vhsubpd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_hsub_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_hsub_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vhsubpd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Horizontally subtract adjacent pairs of double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and pack the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := a[63:0] - a[127:64]
dst[127:64] := b[63:0] - b[127:64]
dst[191:128] := a[191:128] - a[255:192]
dst[255:192] := b[191:128] - b[255:192]
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSSE3" id="2951"><div class="instruction">phsubw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_hsub_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_hsub_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: phsubw mm, mm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Horizontally subtract adjacent pairs of 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and pack the signed 16-bit results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[15:0] := a[15:0] - a[31:16]
dst[31:16] := a[47:32] - a[63:48]
dst[47:32] := b[15:0] - b[31:16]
dst[63:48] := b[47:32] - b[63:48]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>2</td></tr><tr><td>Broadwell</td><td>3</td><td>2</td></tr><tr><td>Haswell</td><td>3</td><td>2</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1.5</td></tr></tbody></table></div></div><div class="intrinsic SSSE3" id="2952"><div class="instruction">phsubd</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_hsub_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_hsub_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: phsubd mm, mm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Horizontally subtract adjacent pairs of 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and pack the signed 32-bit results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := a[31:0] - a[63:32]
dst[63:32] := b[31:0] - b[63:32]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>2</td></tr><tr><td>Broadwell</td><td>3</td><td>2</td></tr><tr><td>Haswell</td><td>3</td><td>2</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1.5</td></tr></tbody></table></div></div><div class="intrinsic SSE3" id="2953"><div class="instruction">hsubps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_hsub_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_hsub_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;pmmintrin.h&gt;<br>Instruction: hsubps xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE3</span></div><h1>Description</h1><div class="description">Horizontally add adjacent pairs of single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and pack the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := a[31:0] - a[63:32]
dst[63:32] := a[95:64] - a[127:96]
dst[95:64] := b[31:0] - b[63:32]
dst[127:96] := b[95:64] - b[127:96]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>6</td><td>2</td></tr><tr><td>Broadwell</td><td>5</td><td>2</td></tr><tr><td>Haswell</td><td>5</td><td>2</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>2</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="2954"><div class="instruction">vhsubps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_hsub_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_hsub_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vhsubps ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Horizontally add adjacent pairs of single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and pack the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := a[31:0] - a[63:32]
dst[63:32] := a[95:64] - a[127:96]
dst[95:64] := b[31:0] - b[63:32]
dst[127:96] := b[95:64] - b[127:96]
dst[159:128] := a[159:128] - a[191:160]
dst[191:160] := a[223:192] - a[255:224]
dst[223:192] := b[159:128] - b[191:160]
dst[255:224] := b[223:192] - b[255:224]
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSSE3" id="2955"><div class="instruction">phsubsw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_hsubs_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_hsubs_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: phsubsw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Horizontally subtract adjacent pairs of 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and pack the signed 16-bit results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[15:0] := Saturate_To_Int16(a[15:0] - a[31:16])
dst[31:16] := Saturate_To_Int16(a[47:32] - a[63:48])
dst[47:32] := Saturate_To_Int16(a[79:64] - a[95:80])
dst[63:48] := Saturate_To_Int16(a[111:96] - a[127:112])
dst[79:64] := Saturate_To_Int16(b[15:0] - b[31:16])
dst[95:80] := Saturate_To_Int16(b[47:32] - b[63:48])
dst[111:96] := Saturate_To_Int16(b[79:64] - b[95:80])
dst[127:112] := Saturate_To_Int16(b[111:96] - b[127:112])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>2</td></tr><tr><td>Broadwell</td><td>3</td><td>2</td></tr><tr><td>Haswell</td><td>3</td><td>2</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="2956"><div class="instruction">vphsubsw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_hsubs_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_hsubs_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vphsubsw ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Horizontally subtract adjacent pairs of 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and pack the signed 16-bit results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[15:0] := Saturate_To_Int16(a[15:0] - a[31:16])
dst[31:16] := Saturate_To_Int16(a[47:32] - a[63:48])
dst[47:32] := Saturate_To_Int16(a[79:64] - a[95:80])
dst[63:48] := Saturate_To_Int16(a[111:96] - a[127:112])
dst[79:64] := Saturate_To_Int16(b[15:0] - b[31:16])
dst[95:80] := Saturate_To_Int16(b[47:32] - b[63:48])
dst[111:96] := Saturate_To_Int16(b[79:64] - b[95:80])
dst[127:112] := Saturate_To_Int16(b[111:96] - b[127:112])
dst[143:128] := Saturate_To_Int16(a[143:128] - a[159:144])
dst[159:144] := Saturate_To_Int16(a[175:160] - a[191:176])
dst[175:160] := Saturate_To_Int16(a[207:192] - a[223:208])
dst[191:176] := Saturate_To_Int16(a[239:224] - a[255:240])
dst[207:192] := Saturate_To_Int16(b[143:128] - b[159:144])
dst[223:208] := Saturate_To_Int16(b[175:160] - b[191:176])
dst[239:224] := Saturate_To_Int16(b[207:192] - b[223:208])
dst[255:240] := Saturate_To_Int16(b[239:224] - b[255:240])
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSSE3" id="2957"><div class="instruction">phsubsw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_hsubs_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_hsubs_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: phsubsw mm, mm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Horizontally subtract adjacent pairs of 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and pack the signed 16-bit results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[15:0] := Saturate_To_Int16(a[15:0] - a[31:16])
dst[31:16] := Saturate_To_Int16(a[47:32] - a[63:48])
dst[47:32] := Saturate_To_Int16(b[15:0] - b[31:16])
dst[63:48] := Saturate_To_Int16(b[47:32] - b[63:48])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>2</td></tr><tr><td>Broadwell</td><td>3</td><td>2</td></tr><tr><td>Haswell</td><td>3</td><td>2</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="2974"><div class="instruction">vpgatherdd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_i32gather_epi32</span> (<span class="param_type">int const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_i32gather_epi32</span> (<span class="param_type">int const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpgatherdd xmm, vm32x, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">
	Gather 32-bit integers from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at <span class="desc_var base_addr">base_addr</span> and offset by each 32-bit element in <span class="desc_var vindex">vindex</span> (each index is scaled by the factor in <span class="desc_var scale">scale</span>). Gathered elements are merged into <span class="desc_var dst">dst</span>. <span class="desc_var scale">scale</span> should be 1, 2, 4 or 8.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	m := j*32
	dst[i+31:i] := MEM[base_addr + SignExtend(vindex[i+31:i])*scale]
ENDFOR
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>~20</td><td>~4</td></tr><tr><td>Broadwell</td><td>~17</td><td>~5</td></tr><tr><td>Haswell</td><td>~14</td><td>~7</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="2975"><div class="instruction">vpgatherdd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mask_i32gather_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">src</span>, <span class="param_type">int const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">__m128i</span> <span class="param_name">mask</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mask_i32gather_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">src</span>, <span class="param_type">int const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">__m128i</span> <span class="param_name">mask</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpgatherdd xmm, vm32x, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">
	Gather 32-bit integers from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at <span class="desc_var base_addr">base_addr</span> and offset by each 32-bit element in <span class="desc_var vindex">vindex</span> (each index is scaled by the factor in <span class="desc_var scale">scale</span>). Gathered elements are merged into <span class="desc_var dst">dst</span> using <span class="desc_var mask">mask</span> (elements are copied from <span class="desc_var src">src</span> when the highest bit is not set in the corresponding element). <span class="desc_var scale">scale</span> should be 1, 2, 4 or 8.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	IF mask[i+31]
		dst[i+31:i] := MEM[base_addr + SignExtend(vindex[i+31:i])*scale]
		mask[i+31] := 0
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
mask[MAX:128] := 0
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>~20</td><td>~4</td></tr><tr><td>Broadwell</td><td>~17</td><td>~5</td></tr><tr><td>Haswell</td><td>~14</td><td>~7</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="2977"><div class="instruction">vpgatherdd</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_i32gather_epi32</span> (<span class="param_type">int const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">vindex</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_i32gather_epi32</span> (<span class="param_type">int const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">vindex</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpgatherdd ymm, vm32x, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">
	Gather 32-bit integers from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at <span class="desc_var base_addr">base_addr</span> and offset by each 32-bit element in <span class="desc_var vindex">vindex</span> (each index is scaled by the factor in <span class="desc_var scale">scale</span>). Gathered elements are merged into <span class="desc_var dst">dst</span>. <span class="desc_var scale">scale</span> should be 1, 2, 4 or 8.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := MEM[base_addr + SignExtend(vindex[i+31:i])*scale]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>~22</td><td>~5</td></tr><tr><td>Broadwell</td><td>~19</td><td>~6</td></tr><tr><td>Haswell</td><td>~20</td><td>~10</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="2978"><div class="instruction">vpgatherdd</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mask_i32gather_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">src</span>, <span class="param_type">int const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">vindex</span>, <span class="param_type">__m256i</span> <span class="param_name">mask</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mask_i32gather_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">src</span>, <span class="param_type">int const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">vindex</span>, <span class="param_type">__m256i</span> <span class="param_name">mask</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpgatherdd ymm, vm32x, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">
	Gather 32-bit integers from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at <span class="desc_var base_addr">base_addr</span> and offset by each 32-bit element in <span class="desc_var vindex">vindex</span> (each index is scaled by the factor in <span class="desc_var scale">scale</span>). Gathered elements are merged into <span class="desc_var dst">dst</span> using <span class="desc_var mask">mask</span> (elements are copied from <span class="desc_var src">src</span> when the highest bit is not set in the corresponding element). <span class="desc_var scale">scale</span> should be 1, 2, 4 or 8.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	IF mask[i+31]
		dst[i+31:i] := MEM[base_addr + SignExtend(vindex[i+31:i])*scale]
		mask[i+31] := 0
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
mask[MAX:256] := 0
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>~22</td><td>~5</td></tr><tr><td>Broadwell</td><td>~19</td><td>~6</td></tr><tr><td>Haswell</td><td>~20</td><td>~10</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="2982"><div class="instruction">vpgatherdq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_i32gather_epi64</span> (<span class="param_type">__int64 const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_i32gather_epi64</span> (<span class="param_type">__int64 const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpgatherdq xmm, vm32x, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Gather 64-bit integers from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at <span class="desc_var base_addr">base_addr</span> and offset by each 32-bit element in <span class="desc_var vindex">vindex</span> (each index is scaled by the factor in <span class="desc_var scale">scale</span>). Gathered elements are merged into <span class="desc_var dst">dst</span>. <span class="desc_var scale">scale</span> should be 1, 2, 4 or 8.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	m := j*32
	dst[i+63:i] := MEM[base_addr + SignExtend(vindex[m+31:m])*scale]
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX2" id="2983"><div class="instruction">vpgatherdq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mask_i32gather_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">src</span>, <span class="param_type">__int64 const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">__m128i</span> <span class="param_name">mask</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mask_i32gather_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">src</span>, <span class="param_type">__int64 const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">__m128i</span> <span class="param_name">mask</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpgatherdq xmm, vm32x, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">
	Gather 64-bit integers from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at <span class="desc_var base_addr">base_addr</span> and offset by each 32-bit element in <span class="desc_var vindex">vindex</span> (each index is scaled by the factor in <span class="desc_var scale">scale</span>). Gathered elements are merged into <span class="desc_var dst">dst</span> using <span class="desc_var mask">mask</span> (elements are copied from <span class="desc_var src">src</span> when the highest bit is not set in the corresponding element). <span class="desc_var scale">scale</span> should be 1, 2, 4 or 8.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	m := j*32
	IF mask[i+63]
		dst[i+63:i] := MEM[base_addr + SignExtend(vindex[m+31:m])*scale]
		mask[i+63] := 0
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
mask[MAX:128] := 0
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX2" id="2985"><div class="instruction">vpgatherdq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_i32gather_epi64</span> (<span class="param_type">__int64 const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_i32gather_epi64</span> (<span class="param_type">__int64 const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpgatherdq ymm, vm32x, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Gather 64-bit integers from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at <span class="desc_var base_addr">base_addr</span> and offset by each 32-bit element in <span class="desc_var vindex">vindex</span> (each index is scaled by the factor in <span class="desc_var scale">scale</span>). Gathered elements are merged into <span class="desc_var dst">dst</span>. <span class="desc_var scale">scale</span> should be 1, 2, 4 or 8.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	m := j*32
	dst[i+63:i] := MEM[base_addr + SignExtend(vindex[m+31:m])*scale]
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX2" id="2986"><div class="instruction">vpgatherdq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mask_i32gather_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">src</span>, <span class="param_type">__int64 const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">__m256i</span> <span class="param_name">mask</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mask_i32gather_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">src</span>, <span class="param_type">__int64 const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">__m256i</span> <span class="param_name">mask</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpgatherdq ymm, vm32x, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">
	Gather 64-bit integers from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at <span class="desc_var base_addr">base_addr</span> and offset by each 32-bit element in <span class="desc_var vindex">vindex</span> (each index is scaled by the factor in <span class="desc_var scale">scale</span>). Gathered elements are merged into <span class="desc_var dst">dst</span> using <span class="desc_var mask">mask</span> (elements are copied from <span class="desc_var src">src</span> when the highest bit is not set in the corresponding element). <span class="desc_var scale">scale</span> should be 1, 2, 4 or 8.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	m := j*32
	IF mask[i+63]
		dst[i+63:i] := MEM[base_addr + SignExtend(vindex[m+31:m])*scale]
		mask[i+63] := 0
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
mask[MAX:256] := 0
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX2" id="2990"><div class="instruction">vgatherdpd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_i32gather_pd</span> (<span class="param_type">double const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_i32gather_pd</span> (<span class="param_type">double const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vgatherdpd xmm, vm32x, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">
	Gather double-precision (64-bit) floating-point elements from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at <span class="desc_var base_addr">base_addr</span> and offset by each 32-bit element in <span class="desc_var vindex">vindex</span> (each index is scaled by the factor in <span class="desc_var scale">scale</span>). Gathered elements are merged into <span class="desc_var dst">dst</span>. <span class="desc_var scale">scale</span> should be 1, 2, 4 or 8.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	m := j*32
	dst[i+63:i] := MEM[base_addr + SignExtend(vindex[m+31:m])*scale]
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX2" id="2991"><div class="instruction">vgatherdpd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_mask_i32gather_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">src</span>, <span class="param_type">double const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">__m128d</span> <span class="param_name">mask</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_mask_i32gather_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">src</span>, <span class="param_type">double const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">__m128d</span> <span class="param_name">mask</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vgatherdpd xmm, vm32x, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">
	Gather double-precision (64-bit) floating-point elements from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at <span class="desc_var base_addr">base_addr</span> and offset by each 32-bit element in <span class="desc_var vindex">vindex</span> (each index is scaled by the factor in <span class="desc_var scale">scale</span>). Gathered elements are merged into <span class="desc_var dst">dst</span> using <span class="desc_var mask">mask</span> (elements are copied from <span class="desc_var src">src</span> when the highest bit is not set in the corresponding element). <span class="desc_var scale">scale</span> should be 1, 2, 4 or 8.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	m := j*32
	IF mask[i+63]
		dst[i+63:i] := MEM[base_addr + SignExtend(vindex[m+31:m])*scale]
		mask[i+63] := 0
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
mask[MAX:128] := 0
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX2" id="2993"><div class="instruction">vgatherdpd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_i32gather_pd</span> (<span class="param_type">double const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_i32gather_pd</span> (<span class="param_type">double const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vgatherdpd ymm, vm32x, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">
	Gather double-precision (64-bit) floating-point elements from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at <span class="desc_var base_addr">base_addr</span> and offset by each 32-bit element in <span class="desc_var vindex">vindex</span> (each index is scaled by the factor in <span class="desc_var scale">scale</span>). Gathered elements are merged into <span class="desc_var dst">dst</span>. <span class="desc_var scale">scale</span> should be 1, 2, 4 or 8.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	m := j*32
	dst[i+63:i] := MEM[base_addr + SignExtend(vindex[m+31:m])*scale]
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX2" id="2994"><div class="instruction">vgatherdpd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_mask_i32gather_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">src</span>, <span class="param_type">double const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">__m256d</span> <span class="param_name">mask</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_mask_i32gather_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">src</span>, <span class="param_type">double const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">__m256d</span> <span class="param_name">mask</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vgatherdpd ymm, vm32x, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">
	Gather double-precision (64-bit) floating-point elements from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at <span class="desc_var base_addr">base_addr</span> and offset by each 32-bit element in <span class="desc_var vindex">vindex</span> (each index is scaled by the factor in <span class="desc_var scale">scale</span>). Gathered elements are merged into <span class="desc_var dst">dst</span> using <span class="desc_var mask">mask</span> (elements are copied from <span class="desc_var src">src</span> when the highest bit is not set in the corresponding element). <span class="desc_var scale">scale</span> should be 1, 2, 4 or 8.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	m := j*32
	IF mask[i+63]
		dst[i+63:i] := MEM[base_addr + SignExtend(vindex[m+31:m])*scale]
		mask[i+63] := 0
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
mask[MAX:256] := 0
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX2" id="2998"><div class="instruction">vgatherdps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_i32gather_ps</span> (<span class="param_type">float const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_i32gather_ps</span> (<span class="param_type">float const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vgatherdps xmm, vm32x, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Gather single-precision (32-bit) floating-point elements from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at <span class="desc_var base_addr">base_addr</span> and offset by each 32-bit element in <span class="desc_var vindex">vindex</span> (each index is scaled by the factor in <span class="desc_var scale">scale</span>). Gathered elements are merged into <span class="desc_var dst">dst</span>. <span class="desc_var scale">scale</span> should be 1, 2, 4 or 8.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	m := j*32
	dst[i+31:i] := MEM[base_addr + SignExtend(vindex[i+31:i])*scale]
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX2" id="2999"><div class="instruction">vgatherdps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_mask_i32gather_ps</span> (<span class="param_type">__m128</span> <span class="param_name">src</span>, <span class="param_type">float const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">__m128</span> <span class="param_name">mask</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_mask_i32gather_ps</span> (<span class="param_type">__m128</span> <span class="param_name">src</span>, <span class="param_type">float const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">__m128</span> <span class="param_name">mask</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vgatherdps xmm, vm32x, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">
	Gather single-precision (32-bit) floating-point elements from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at <span class="desc_var base_addr">base_addr</span> and offset by each 32-bit element in <span class="desc_var vindex">vindex</span> (each index is scaled by the factor in <span class="desc_var scale">scale</span>). Gathered elements are merged into <span class="desc_var dst">dst</span> using <span class="desc_var mask">mask</span> (elements are copied from <span class="desc_var src">src</span> when the highest bit is not set in the corresponding element). <span class="desc_var scale">scale</span> should be 1, 2, 4 or 8.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	IF mask[i+31]
		dst[i+31:i] := MEM[base_addr + SignExtend(vindex[i+31:i])*scale]
		mask[i+31] := 0
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
mask[MAX:128] := 0
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX2" id="3001"><div class="instruction">vgatherdps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_i32gather_ps</span> (<span class="param_type">float const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">vindex</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_i32gather_ps</span> (<span class="param_type">float const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">vindex</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vgatherdps ymm, vm32x, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Gather single-precision (32-bit) floating-point elements from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at <span class="desc_var base_addr">base_addr</span> and offset by each 32-bit element in <span class="desc_var vindex">vindex</span> (each index is scaled by the factor in <span class="desc_var scale">scale</span>). Gathered elements are merged into <span class="desc_var dst">dst</span>. <span class="desc_var scale">scale</span> should be 1, 2, 4 or 8.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := MEM[base_addr + SignExtend(vindex[i+31:i])*scale]
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX2" id="3002"><div class="instruction">vgatherdps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_mask_i32gather_ps</span> (<span class="param_type">__m256</span> <span class="param_name">src</span>, <span class="param_type">float const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">vindex</span>, <span class="param_type">__m256</span> <span class="param_name">mask</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_mask_i32gather_ps</span> (<span class="param_type">__m256</span> <span class="param_name">src</span>, <span class="param_type">float const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">vindex</span>, <span class="param_type">__m256</span> <span class="param_name">mask</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vgatherdps ymm, vm32x, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">
	Gather single-precision (32-bit) floating-point elements from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at <span class="desc_var base_addr">base_addr</span> and offset by each 32-bit element in <span class="desc_var vindex">vindex</span> (each index is scaled by the factor in <span class="desc_var scale">scale</span>). Gathered elements are merged into <span class="desc_var dst">dst</span> using <span class="desc_var mask">mask</span> (elements are copied from <span class="desc_var src">src</span> when the highest bit is not set in the corresponding element). <span class="desc_var scale">scale</span> should be 1, 2, 4 or 8.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	IF mask[i+31]
		dst[i+31:i] := MEM[base_addr + SignExtend(vindex[i+31:i])*scale]
		mask[i+31] := 0
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
mask[MAX:256] := 0
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX2" id="3062"><div class="instruction">vpgatherqd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_i64gather_epi32</span> (<span class="param_type">int const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_i64gather_epi32</span> (<span class="param_type">int const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpgatherqd xmm, vm64x, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Gather 32-bit integers from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at <span class="desc_var base_addr">base_addr</span> and offset by each 64-bit element in <span class="desc_var vindex">vindex</span> (each index is scaled by the factor in <span class="desc_var scale">scale</span>). Gathered elements are merged into <span class="desc_var dst">dst</span>. <span class="desc_var scale">scale</span> should be 1, 2, 4 or 8.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*32
	m := j*64
	dst[i+31:i] := MEM[base_addr + SignExtend(vindex[m+63:m])*scale]
ENDFOR
dst[MAX:64] := 0</div></div></div><div class="intrinsic AVX2" id="3063"><div class="instruction">vpgatherqd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mask_i64gather_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">src</span>, <span class="param_type">int const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">__m128i</span> <span class="param_name">mask</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mask_i64gather_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">src</span>, <span class="param_type">int const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">__m128i</span> <span class="param_name">mask</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpgatherqd xmm, vm64x, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">
	Gather 32-bit integers from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at <span class="desc_var base_addr">base_addr</span> and offset by each 64-bit element in <span class="desc_var vindex">vindex</span> (each index is scaled by the factor in <span class="desc_var scale">scale</span>). Gathered elements are merged into <span class="desc_var dst">dst</span> using <span class="desc_var mask">mask</span> (elements are copied from <span class="desc_var src">src</span> when the highest bit is not set in the corresponding element). <span class="desc_var scale">scale</span> should be 1, 2, 4 or 8.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*32
	m := j*64
	IF mask[i+31]
		dst[i+31:i] := MEM[base_addr + SignExtend(vindex[m+63:m])*scale]
		mask[i+31] := 0
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
mask[MAX:64] := 0
dst[MAX:64] := 0</div></div></div><div class="intrinsic AVX2" id="3065"><div class="instruction">vpgatherqd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm256_i64gather_epi32</span> (<span class="param_type">int const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">vindex</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm256_i64gather_epi32</span> (<span class="param_type">int const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">vindex</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpgatherqd ymm, vm64x, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Gather 32-bit integers from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at <span class="desc_var base_addr">base_addr</span> and offset by each 64-bit element in <span class="desc_var vindex">vindex</span> (each index is scaled by the factor in <span class="desc_var scale">scale</span>). Gathered elements are merged into <span class="desc_var dst">dst</span>. <span class="desc_var scale">scale</span> should be 1, 2, 4 or 8.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	m := j*64
	dst[i+31:i] := MEM[base_addr + SignExtend(vindex[m+63:m])*scale]
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX2" id="3066"><div class="instruction">vpgatherqd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm256_mask_i64gather_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">src</span>, <span class="param_type">int const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">vindex</span>, <span class="param_type">__m128i</span> <span class="param_name">mask</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm256_mask_i64gather_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">src</span>, <span class="param_type">int const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">vindex</span>, <span class="param_type">__m128i</span> <span class="param_name">mask</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpgatherqd ymm, vm64x, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">
	Gather 32-bit integers from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at <span class="desc_var base_addr">base_addr</span> and offset by each 64-bit element in <span class="desc_var vindex">vindex</span> (each index is scaled by the factor in <span class="desc_var scale">scale</span>). Gathered elements are merged into <span class="desc_var dst">dst</span> using <span class="desc_var mask">mask</span> (elements are copied from <span class="desc_var src">src</span> when the highest bit is not set in the corresponding element). <span class="desc_var scale">scale</span> should be 1, 2, 4 or 8.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	m := j*64
	IF mask[i+31]
		dst[i+31:i] := MEM[base_addr + SignExtend(vindex[m+63:m])*scale]
		mask[i+31] := 0
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
mask[MAX:128] := 0
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX2" id="3072"><div class="instruction">vpgatherqq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_i64gather_epi64</span> (<span class="param_type">__int64 const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_i64gather_epi64</span> (<span class="param_type">__int64 const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpgatherqq xmm, vm64x, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Gather 64-bit integers from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at <span class="desc_var base_addr">base_addr</span> and offset by each 64-bit element in <span class="desc_var vindex">vindex</span> (each index is scaled by the factor in <span class="desc_var scale">scale</span>). Gathered elements are merged into <span class="desc_var dst">dst</span>. <span class="desc_var scale">scale</span> should be 1, 2, 4 or 8.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	m := j*64
	dst[i+63:i] := MEM[base_addr + SignExtend(vindex[m+63:m])*scale]
ENDFOR
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>~18</td><td>~3</td></tr><tr><td>Broadwell</td><td>~15</td><td>~4</td></tr><tr><td>Haswell</td><td>~12</td><td>~5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="3073"><div class="instruction">vpgatherqq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mask_i64gather_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">src</span>, <span class="param_type">__int64 const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">__m128i</span> <span class="param_name">mask</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mask_i64gather_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">src</span>, <span class="param_type">__int64 const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">__m128i</span> <span class="param_name">mask</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpgatherqq xmm, vm64x, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">
	Gather 64-bit integers from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at <span class="desc_var base_addr">base_addr</span> and offset by each 64-bit element in <span class="desc_var vindex">vindex</span> (each index is scaled by the factor in <span class="desc_var scale">scale</span>). Gathered elements are merged into <span class="desc_var dst">dst</span> using <span class="desc_var mask">mask</span> (elements are copied from <span class="desc_var src">src</span> when the highest bit is not set in the corresponding element). <span class="desc_var scale">scale</span> should be 1, 2, 4 or 8.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	m := j*64
	IF mask[i+63]
		dst[i+63:i] := MEM[base_addr + SignExtend(vindex[m+63:m])*scale]
		mask[i+63] := 0
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
mask[MAX:128] := 0
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>~18</td><td>~3</td></tr><tr><td>Broadwell</td><td>~15</td><td>~4</td></tr><tr><td>Haswell</td><td>~12</td><td>~5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="3075"><div class="instruction">vpgatherqq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_i64gather_epi64</span> (<span class="param_type">__int64 const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">vindex</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_i64gather_epi64</span> (<span class="param_type">__int64 const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">vindex</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpgatherqq ymm, vm64x, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Gather 64-bit integers from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at <span class="desc_var base_addr">base_addr</span> and offset by each 64-bit element in <span class="desc_var vindex">vindex</span> (each index is scaled by the factor in <span class="desc_var scale">scale</span>). Gathered elements are merged into <span class="desc_var dst">dst</span>. <span class="desc_var scale">scale</span> should be 1, 2, 4 or 8.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	m := j*64
	dst[i+63:i] := MEM[base_addr + SignExtend(vindex[m+63:m])*scale]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>~20</td><td>~4</td></tr><tr><td>Broadwell</td><td>~16</td><td>~5</td></tr><tr><td>Haswell</td><td>~15</td><td>~7</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="3076"><div class="instruction">vpgatherqq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mask_i64gather_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">src</span>, <span class="param_type">__int64 const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">vindex</span>, <span class="param_type">__m256i</span> <span class="param_name">mask</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mask_i64gather_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">src</span>, <span class="param_type">__int64 const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">vindex</span>, <span class="param_type">__m256i</span> <span class="param_name">mask</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpgatherqq ymm, vm64x, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">
	Gather 64-bit integers from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at <span class="desc_var base_addr">base_addr</span> and offset by each 64-bit element in <span class="desc_var vindex">vindex</span> (each index is scaled by the factor in <span class="desc_var scale">scale</span>). Gathered elements are merged into <span class="desc_var dst">dst</span> using <span class="desc_var mask">mask</span> (elements are copied from <span class="desc_var src">src</span> when the highest bit is not set in the corresponding element). <span class="desc_var scale">scale</span> should be 1, 2, 4 or 8.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	m := j*64
	IF mask[i+63]
		dst[i+63:i] := MEM[base_addr + SignExtend(vindex[m+63:m])*scale]
		mask[i+63] := 0
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
mask[MAX:256] := 0
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>~20</td><td>~4</td></tr><tr><td>Broadwell</td><td>~16</td><td>~5</td></tr><tr><td>Haswell</td><td>~15</td><td>~7</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="3080"><div class="instruction">vgatherqpd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_i64gather_pd</span> (<span class="param_type">double const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_i64gather_pd</span> (<span class="param_type">double const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vgatherqpd xmm, vm64x, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">
	Gather double-precision (64-bit) floating-point elements from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at <span class="desc_var base_addr">base_addr</span> and offset by each 64-bit element in <span class="desc_var vindex">vindex</span> (each index is scaled by the factor in <span class="desc_var scale">scale</span>). Gathered elements are merged into <span class="desc_var dst">dst</span>. <span class="desc_var scale">scale</span> should be 1, 2, 4 or 8.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	m := j*64
	dst[i+63:i] := MEM[base_addr + SignExtend(vindex[m+63:m])*scale]
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX2" id="3081"><div class="instruction">vgatherqpd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_mask_i64gather_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">src</span>, <span class="param_type">double const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">__m128d</span> <span class="param_name">mask</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_mask_i64gather_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">src</span>, <span class="param_type">double const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">__m128d</span> <span class="param_name">mask</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vgatherqpd xmm, vm64x, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">
	Gather double-precision (64-bit) floating-point elements from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at <span class="desc_var base_addr">base_addr</span> and offset by each 64-bit element in <span class="desc_var vindex">vindex</span> (each index is scaled by the factor in <span class="desc_var scale">scale</span>). Gathered elements are merged into <span class="desc_var dst">dst</span> using <span class="desc_var mask">mask</span> (elements are copied from <span class="desc_var src">src</span> when the highest bit is not set in the corresponding element). <span class="desc_var scale">scale</span> should be 1, 2, 4 or 8.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	m := j*64
	IF mask[i+63]
		dst[i+63:i] := MEM[base_addr + SignExtend(vindex[m+63:m])*scale]
		mask[i+63] := 0
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
mask[MAX:128] := 0
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX2" id="3083"><div class="instruction">vgatherqpd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_i64gather_pd</span> (<span class="param_type">double const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">vindex</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_i64gather_pd</span> (<span class="param_type">double const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">vindex</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vgatherqpd ymm, vm64x, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">
	Gather double-precision (64-bit) floating-point elements from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at <span class="desc_var base_addr">base_addr</span> and offset by each 64-bit element in <span class="desc_var vindex">vindex</span> (each index is scaled by the factor in <span class="desc_var scale">scale</span>). Gathered elements are merged into <span class="desc_var dst">dst</span>. <span class="desc_var scale">scale</span> should be 1, 2, 4 or 8.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	m := j*64
	dst[i+63:i] := MEM[base_addr + SignExtend(vindex[m+63:m])*scale]
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX2" id="3084"><div class="instruction">vgatherqpd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_mask_i64gather_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">src</span>, <span class="param_type">double const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">vindex</span>, <span class="param_type">__m256d</span> <span class="param_name">mask</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_mask_i64gather_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">src</span>, <span class="param_type">double const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">vindex</span>, <span class="param_type">__m256d</span> <span class="param_name">mask</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vgatherqpd ymm, vm64x, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">
	Gather double-precision (64-bit) floating-point elements from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at <span class="desc_var base_addr">base_addr</span> and offset by each 64-bit element in <span class="desc_var vindex">vindex</span> (each index is scaled by the factor in <span class="desc_var scale">scale</span>). Gathered elements are merged into <span class="desc_var dst">dst</span> using <span class="desc_var mask">mask</span> (elements are copied from <span class="desc_var src">src</span> when the highest bit is not set in the corresponding element). <span class="desc_var scale">scale</span> should be 1, 2, 4 or 8.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	m := j*64
	IF mask[i+63]
		dst[i+63:i] := MEM[base_addr + SignExtend(vindex[m+63:m])*scale]
		mask[i+63] := 0
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
mask[MAX:256] := 0
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX2" id="3088"><div class="instruction">vgatherqps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_i64gather_ps</span> (<span class="param_type">float const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_i64gather_ps</span> (<span class="param_type">float const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vgatherqps xmm, vm64x, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">
	Gather single-precision (32-bit) floating-point elements from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at <span class="desc_var base_addr">base_addr</span> and offset by each 64-bit element in <span class="desc_var vindex">vindex</span> (each index is scaled by the factor in <span class="desc_var scale">scale</span>). Gathered elements are merged into <span class="desc_var dst">dst</span>. <span class="desc_var scale">scale</span> should be 1, 2, 4 or 8.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*32
	m := j*64
	dst[i+31:i] := MEM[base_addr + SignExtend(vindex[m+63:m])*scale]
ENDFOR
dst[MAX:64] := 0</div></div></div><div class="intrinsic AVX2" id="3089"><div class="instruction">vgatherqps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_mask_i64gather_ps</span> (<span class="param_type">__m128</span> <span class="param_name">src</span>, <span class="param_type">float const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">__m128</span> <span class="param_name">mask</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_mask_i64gather_ps</span> (<span class="param_type">__m128</span> <span class="param_name">src</span>, <span class="param_type">float const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">vindex</span>, <span class="param_type">__m128</span> <span class="param_name">mask</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vgatherqps xmm, vm64x, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">
	Gather single-precision (32-bit) floating-point elements from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at <span class="desc_var base_addr">base_addr</span> and offset by each 64-bit element in <span class="desc_var vindex">vindex</span> (each index is scaled by the factor in <span class="desc_var scale">scale</span>). Gathered elements are merged into <span class="desc_var dst">dst</span> using <span class="desc_var mask">mask</span> (elements are copied from <span class="desc_var src">src</span> when the highest bit is not set in the corresponding element). <span class="desc_var scale">scale</span> should be 1, 2, 4 or 8.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*32
	m := j*64
	IF mask[i+31]
		dst[i+31:i] := MEM[base_addr + SignExtend(vindex[m+63:m])*scale]
		mask[i+31] := 0
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
mask[MAX:64] := 0
dst[MAX:64] := 0</div></div></div><div class="intrinsic AVX2" id="3091"><div class="instruction">vgatherqps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm256_i64gather_ps</span> (<span class="param_type">float const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">vindex</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm256_i64gather_ps</span> (<span class="param_type">float const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">vindex</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vgatherqps ymm, vm64x, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">
	Gather single-precision (32-bit) floating-point elements from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at <span class="desc_var base_addr">base_addr</span> and offset by each 64-bit element in <span class="desc_var vindex">vindex</span> (each index is scaled by the factor in <span class="desc_var scale">scale</span>). Gathered elements are merged into <span class="desc_var dst">dst</span>. <span class="desc_var scale">scale</span> should be 1, 2, 4 or 8.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	m := j*64
	dst[i+31:i] := MEM[base_addr + SignExtend(vindex[m+63:m])*scale]
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX2" id="3092"><div class="instruction">vgatherqps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm256_mask_i64gather_ps</span> (<span class="param_type">__m128</span> <span class="param_name">src</span>, <span class="param_type">float const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">vindex</span>, <span class="param_type">__m128</span> <span class="param_name">mask</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm256_mask_i64gather_ps</span> (<span class="param_type">__m128</span> <span class="param_name">src</span>, <span class="param_type">float const*</span> <span class="param_name">base_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">vindex</span>, <span class="param_type">__m128</span> <span class="param_name">mask</span>, <span class="param_type">const int</span> <span class="param_name">scale</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vgatherqps ymm, vm64x, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">
	Gather single-precision (32-bit) floating-point elements from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at <span class="desc_var base_addr">base_addr</span> and offset by each 64-bit element in <span class="desc_var vindex">vindex</span> (each index is scaled by the factor in <span class="desc_var scale">scale</span>). Gathered elements are merged into <span class="desc_var dst">dst</span> using <span class="desc_var mask">mask</span> (elements are copied from <span class="desc_var src">src</span> when the highest bit is not set in the corresponding element). <span class="desc_var scale">scale</span> should be 1, 2, 4 or 8.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	m := j*64
	IF mask[i+31]
		dst[i+31:i] := MEM[base_addr + SignExtend(vindex[m+63:m])*scale]
		mask[i+31] := 0
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
mask[MAX:128] := 0
dst[MAX:128] := 0</div></div></div><div class="intrinsic SSE2" id="3133"><div class="instruction">pinsrw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_insert_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">i</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_insert_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">i</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pinsrw xmm, r32, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Copy <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>, and insert the 16-bit integer <span class="desc_var i">i</span> into <span class="desc_var dst">dst</span> at the location specified by <span class="desc_var imm8">imm8</span>. </div><h1>Operation</h1><div class="operation">dst[127:0] := a[127:0]
sel := imm8[2:0]*16
dst[sel+15:sel] := i[15:0]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>2</td></tr><tr><td>Broadwell</td><td>2</td><td>2</td></tr><tr><td>Haswell</td><td>2</td><td>2</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="3134"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_insert_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__int16</span> <span class="param_name">i</span>, <span class="param_type">const int</span> <span class="param_name">index</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_insert_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__int16</span> <span class="param_name">i</span>, <span class="param_type">const int</span> <span class="param_name">index</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Copy <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>, and insert the 16-bit integer <span class="desc_var i">i</span> into <span class="desc_var dst">dst</span> at the location specified by <span class="desc_var index">index</span>. </div><h1>Operation</h1><div class="operation">dst[255:0] := a[255:0]
sel := index*16
dst[sel+15:sel] := i[15:0]</div></div></div><div class="intrinsic SSE4_1" id="3135"><div class="instruction">pinsrd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_insert_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">i</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_insert_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">i</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: pinsrd xmm, r32, imm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Copy <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>, and insert the 32-bit integer <span class="desc_var i">i</span> into <span class="desc_var dst">dst</span> at the location specified by <span class="desc_var imm8">imm8</span>. </div><h1>Operation</h1><div class="operation">dst[127:0] := a[127:0]
sel := imm8[1:0]*32
dst[sel+31:sel] := i[31:0]</div></div></div><div class="intrinsic AVX" id="3136"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_insert_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__int32</span> <span class="param_name">i</span>, <span class="param_type">const int</span> <span class="param_name">index</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_insert_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__int32</span> <span class="param_name">i</span>, <span class="param_type">const int</span> <span class="param_name">index</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Copy <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>, and insert the 32-bit integer <span class="desc_var i">i</span> into <span class="desc_var dst">dst</span> at the location specified by <span class="desc_var index">index</span>. </div><h1>Operation</h1><div class="operation">dst[255:0] := a[255:0]
sel := index*32
dst[sel+31:sel] := i[31:0]</div></div></div><div class="intrinsic SSE4_1" id="3137"><div class="instruction">pinsrq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_insert_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__int64</span> <span class="param_name">i</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_insert_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__int64</span> <span class="param_name">i</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: pinsrq xmm, r64, imm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Copy <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>, and insert the 64-bit integer <span class="desc_var i">i</span> into <span class="desc_var dst">dst</span> at the location specified by <span class="desc_var imm8">imm8</span>. </div><h1>Operation</h1><div class="operation">dst[127:0] := a[127:0]
sel := imm8[0]*64
dst[sel+63:sel] := i[63:0]</div></div></div><div class="intrinsic AVX" id="3138"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_insert_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__int64</span> <span class="param_name">i</span>, <span class="param_type">const int</span> <span class="param_name">index</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_insert_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__int64</span> <span class="param_name">i</span>, <span class="param_type">const int</span> <span class="param_name">index</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Copy <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>, and insert the 64-bit integer <span class="desc_var i">i</span> into <span class="desc_var dst">dst</span> at the location specified by <span class="desc_var index">index</span>. </div><h1>Operation</h1><div class="operation">dst[255:0] := a[255:0]
sel := index*64
dst[sel+63:sel] := i[63:0]</div></div></div><div class="intrinsic SSE4_1" id="3139"><div class="instruction">pinsrb</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_insert_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">i</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_insert_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">i</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: pinsrb xmm, r32, imm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Copy <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>, and insert the lower 8-bit integer from <span class="desc_var i">i</span> into <span class="desc_var dst">dst</span> at the location specified by <span class="desc_var imm8">imm8</span>. </div><h1>Operation</h1><div class="operation">dst[127:0] := a[127:0]
sel := imm8[3:0]*8
dst[sel+7:sel] := i[7:0]</div></div></div><div class="intrinsic AVX" id="3140"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_insert_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__int8</span> <span class="param_name">i</span>, <span class="param_type">const int</span> <span class="param_name">index</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_insert_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__int8</span> <span class="param_name">i</span>, <span class="param_type">const int</span> <span class="param_name">index</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Copy <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>, and insert the 8-bit integer <span class="desc_var i">i</span> into <span class="desc_var dst">dst</span> at the location specified by <span class="desc_var index">index</span>. </div><h1>Operation</h1><div class="operation">dst[255:0] := a[255:0]
sel := index*8
dst[sel+7:sel] := i[7:0]</div></div></div><div class="intrinsic SSE" id="3141"><div class="instruction">pinsrw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_insert_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">i</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_insert_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">i</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: pinsrw xmm, r32, imm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Copy <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>, and insert the 16-bit integer <span class="desc_var i">i</span> into <span class="desc_var dst">dst</span> at the location specified by <span class="desc_var imm8">imm8</span>. </div><h1>Operation</h1><div class="operation">dst[63:0] := a[63:0]
sel := imm8[1:0]*16
dst[sel+15:sel] := i[15:0]</div></div></div><div class="intrinsic SSE4_1" id="3142"><div class="instruction">insertps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_insert_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_insert_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: insertps xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Copy <span class="desc_var a">a</span> to <span class="desc_var tmp">tmp</span>, then insert a single-precision (32-bit) floating-point element from <span class="desc_var b">b</span> into <span class="desc_var tmp">tmp</span> using the control in <span class="desc_var imm8">imm8</span>. Store <span class="desc_var tmp">tmp</span> to <span class="desc_var dst">dst</span> using the mask in <span class="desc_var imm8">imm8</span> (elements are zeroed out when the corresponding bit is set). </div><h1>Operation</h1><div class="operation">tmp2[127:0] := a[127:0]
CASE (imm8[7:6]) OF
0: tmp1[31:0] := b[31:0]
1: tmp1[31:0] := b[63:32]
2: tmp1[31:0] := b[95:64]
3: tmp1[31:0] := b[127:96]
ESAC
CASE (imm8[5:4]) OF
0: tmp2[31:0] := tmp1[31:0]
1: tmp2[63:32] := tmp1[31:0]
2: tmp2[95:64] := tmp1[31:0]
3: tmp2[127:96] := tmp1[31:0]
ESAC
FOR j := 0 to 3
	i := j*32
	IF imm8[j%8]
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := tmp2[i+31:i]
	FI
ENDFOR</div></div></div><div class="intrinsic AVX" id="3143"><div class="instruction">vinsertf128</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_insertf128_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_insertf128_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vinsertf128 ymm, ymm, xmm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Copy <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>, then insert 128 bits (composed of 2 packed double-precision (64-bit) floating-point elements) from <span class="desc_var b">b</span> into <span class="desc_var dst">dst</span> at the location specified by <span class="desc_var imm8">imm8</span>.</div><h1>Operation</h1><div class="operation">dst[255:0] := a[255:0]
CASE imm8[7:0] OF
0: dst[127:0] := b[127:0]
1: dst[255:128] := b[127:0]
ESAC
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>1</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="3144"><div class="instruction">vinsertf128</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_insertf128_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_insertf128_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vinsertf128 ymm, ymm, xmm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Copy <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>, then insert 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from <span class="desc_var b">b</span> into <span class="desc_var dst">dst</span> at the location specified by <span class="desc_var imm8">imm8</span>.</div><h1>Operation</h1><div class="operation">dst[255:0] := a[255:0]
CASE (imm8[1:0]) OF
0: dst[127:0] := b[127:0]
1: dst[255:128] := b[127:0]
ESAC
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>1</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="3145"><div class="instruction">vinsertf128</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_insertf128_si256</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_insertf128_si256</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vinsertf128 ymm, ymm, xmm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Copy <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>, then insert 128 bits from <span class="desc_var b">b</span> into <span class="desc_var dst">dst</span> at the location specified by <span class="desc_var imm8">imm8</span>.</div><h1>Operation</h1><div class="operation">dst[255:0] := a[255:0]
CASE (imm8[1:0]) OF
0: dst[127:0] := b[127:0]
1: dst[255:128] := b[127:0]
ESAC
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>1</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="3164"><div class="instruction">vinserti128</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_inserti128_si256</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_inserti128_si256</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vinserti128 ymm, ymm, xmm, imm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Copy <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>, then insert 128 bits (composed of integer data) from <span class="desc_var b">b</span> into <span class="desc_var dst">dst</span> at the location specified by <span class="desc_var imm8">imm8</span>.</div><h1>Operation</h1><div class="operation">dst[255:0] := a[255:0]
CASE (imm8[1:0]) OF
0: dst[127:0] := b[127:0]
1: dst[255:128] := b[127:0]
ESAC
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>1</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE3" id="3289"><div class="instruction">lddqu</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_lddqu_si128</span> (<span class="param_type">__m128i const*</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_lddqu_si128</span> (<span class="param_type">__m128i const*</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;pmmintrin.h&gt;<br>Instruction: lddqu xmm, m128<br>CPUID Flags: <span class="cpuid">SSE3</span></div><h1>Description</h1><div class="description">Load 128-bits of integer data from unaligned memory into <span class="desc_var dst">dst</span>. This intrinsic may perform better than <span class="desc_var _mm_loadu_si128">_mm_loadu_si128</span> when the data crosses a cache line boundary.</div><h1>Operation</h1><div class="operation">dst[127:0] := MEM[mem_addr+127:mem_addr]</div></div></div><div class="intrinsic AVX" id="3290"><div class="instruction">vlddqu</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_lddqu_si256</span> (<span class="param_type">__m256i const *</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_lddqu_si256</span> (<span class="param_type">__m256i const *</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vlddqu ymm, m256<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Load 256-bits of integer data from unaligned memory into <span class="desc_var dst">dst</span>. This intrinsic may perform better than <span class="desc_var _mm256_loadu_si256">_mm256_loadu_si256</span> when the data crosses a cache line boundary.</div><h1>Operation</h1><div class="operation">dst[255:0] := MEM[mem_addr+255:mem_addr]
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="3291"><div class="instruction">lfence</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_lfence</span> (<span class="param_type">void</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_lfence</span> (<span class="param_type">void</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: lfence<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Perform a serializing operation on all load-from-memory instructions that were issued prior to this instruction. Guarantees that every load instruction that precedes, in program order, is globally visible before any load instruction which follows the fence in program order.</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>-</td><td>6</td></tr><tr><td>Broadwell</td><td>-</td><td>5</td></tr><tr><td>Haswell</td><td>-</td><td>5</td></tr><tr><td>Ivy Bridge</td><td>-</td><td>4</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="3314"><div class="instruction">movapd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_load_pd</span> (<span class="param_type">double const*</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_load_pd</span> (<span class="param_type">double const*</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: movapd xmm, m128<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Load 128-bits (composed of 2 packed double-precision (64-bit) floating-point elements) from memory into <span class="desc_var dst">dst</span>.
	<span class="desc_var mem_addr">mem_addr</span> must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div><h1>Operation</h1><div class="operation">dst[127:0] := MEM[mem_addr+127:mem_addr]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="3317"><div class="instruction">vmovapd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_load_pd</span> (<span class="param_type">double const *</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_load_pd</span> (<span class="param_type">double const *</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vmovapd ymm, m256<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Load 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from memory into <span class="desc_var dst">dst</span>.
	<span class="desc_var mem_addr">mem_addr</span> must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div><h1>Operation</h1><div class="operation">dst[255:0] := MEM[mem_addr+255:mem_addr]
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.25</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="3323"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_load_pd1</span> (<span class="param_type">double const*</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_load_pd1</span> (<span class="param_type">double const*</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: <span class="instruction_note" note-type="sequence">movapd</span> xmm, m128<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Load a double-precision (64-bit) floating-point element from memory into both elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := MEM[mem_addr+63:mem_addr]
dst[127:64] := MEM[mem_addr+63:mem_addr]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="3324"><div class="instruction">movaps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_load_ps</span> (<span class="param_type">float const*</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_load_ps</span> (<span class="param_type">float const*</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: movaps xmm, m128<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Load 128-bits (composed of 4 packed single-precision (32-bit) floating-point elements) from memory into <span class="desc_var dst">dst</span>.
	<span class="desc_var mem_addr">mem_addr</span> must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div><h1>Operation</h1><div class="operation">dst[127:0] := MEM[mem_addr+127:mem_addr]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.25</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="3327"><div class="instruction">vmovaps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_load_ps</span> (<span class="param_type">float const *</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_load_ps</span> (<span class="param_type">float const *</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vmovaps ymm, m256<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Load 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from memory into <span class="desc_var dst">dst</span>.
	<span class="desc_var mem_addr">mem_addr</span> must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div><h1>Operation</h1><div class="operation">dst[255:0] := MEM[mem_addr+255:mem_addr]
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.25</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="3333"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_load_ps1</span> (<span class="param_type">float const*</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_load_ps1</span> (<span class="param_type">float const*</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Load a single-precision (32-bit) floating-point element from memory into all elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := MEM[mem_addr+31:mem_addr]
dst[63:32] := MEM[mem_addr+31:mem_addr]
dst[95:64] := MEM[mem_addr+31:mem_addr]
dst[127:96] := MEM[mem_addr+31:mem_addr]</div></div></div><div class="intrinsic SSE2" id="3334"><div class="instruction">movsd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_load_sd</span> (<span class="param_type">double const*</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_load_sd</span> (<span class="param_type">double const*</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: movsd xmm, m64<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Load a double-precision (64-bit) floating-point element from memory into the lower of <span class="desc_var dst">dst</span>, and zero the upper element. <span class="desc_var mem_addr">mem_addr</span> does not need to be aligned on any particular boundary.</div><h1>Operation</h1><div class="operation">dst[63:0] := MEM[mem_addr+63:mem_addr]
dst[127:64] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="3337"><div class="instruction">movdqa</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_load_si128</span> (<span class="param_type">__m128i const*</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_load_si128</span> (<span class="param_type">__m128i const*</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: movdqa xmm, m128<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Load 128-bits of integer data from memory into <span class="desc_var dst">dst</span>. 
	<span class="desc_var mem_addr">mem_addr</span> must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div><h1>Operation</h1><div class="operation">dst[127:0] := MEM[mem_addr+127:mem_addr]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.25</td></tr><tr><td>Broadwell</td><td>1</td><td>0.33</td></tr><tr><td>Haswell</td><td>1</td><td>0.33</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="3338"><div class="instruction">vmovdqa</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_load_si256</span> (<span class="param_type">__m256i const *</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_load_si256</span> (<span class="param_type">__m256i const *</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vmovdqa ymm, m256<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Load 256-bits of integer data from memory into <span class="desc_var dst">dst</span>.
	<span class="desc_var mem_addr">mem_addr</span> must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div><h1>Operation</h1><div class="operation">dst[255:0] := MEM[mem_addr+255:mem_addr]
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.25</td></tr><tr><td>Broadwell</td><td>1</td><td>0.25</td></tr><tr><td>Haswell</td><td>1</td><td>0.25</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="3340"><div class="instruction">movss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_load_ss</span> (<span class="param_type">float const*</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_load_ss</span> (<span class="param_type">float const*</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: movss xmm, m32<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Load a single-precision (32-bit) floating-point element from memory into the lower of <span class="desc_var dst">dst</span>, and zero the upper 3 elements. <span class="desc_var mem_addr">mem_addr</span> does not need to be aligned on any particular boundary.</div><h1>Operation</h1><div class="operation">dst[31:0] := MEM[mem_addr+31:mem_addr]
dst[127:32] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="3343"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_load1_pd</span> (<span class="param_type">double const*</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_load1_pd</span> (<span class="param_type">double const*</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: <span class="instruction_note" note-type="sequence">movapd</span> xmm, m128<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Load a double-precision (64-bit) floating-point element from memory into both elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := MEM[mem_addr+63:mem_addr]
dst[127:64] := MEM[mem_addr+63:mem_addr]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="3344"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_load1_ps</span> (<span class="param_type">float const*</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_load1_ps</span> (<span class="param_type">float const*</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Load a single-precision (32-bit) floating-point element from memory into all elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := MEM[mem_addr+31:mem_addr]
dst[63:32] := MEM[mem_addr+31:mem_addr]
dst[95:64] := MEM[mem_addr+31:mem_addr]
dst[127:96] := MEM[mem_addr+31:mem_addr]</div></div></div><div class="intrinsic SSE3" id="3348"><div class="instruction">movddup</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_loaddup_pd</span> (<span class="param_type">double const*</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_loaddup_pd</span> (<span class="param_type">double const*</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;pmmintrin.h&gt;<br>Instruction: movddup xmm, m64<br>CPUID Flags: <span class="cpuid">SSE3</span></div><h1>Description</h1><div class="description">Load a double-precision (64-bit) floating-point element from memory into both elements of <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">tmp[63:0] := MEM[mem_addr+63:mem_addr]
tmp[127:64] := MEM[mem_addr+63:mem_addr]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="3349"><div class="instruction">movhpd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_loadh_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">double const*</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_loadh_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">double const*</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: movhpd xmm, m64<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Load a double-precision (64-bit) floating-point element from memory into the upper element of <span class="desc_var dst">dst</span>, and copy the lower element from <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>. <span class="desc_var mem_addr">mem_addr</span> does not need to be aligned on any particular boundary.</div><h1>Operation</h1><div class="operation">dst[63:0] := a[63:0]
dst[127:64] := MEM[mem_addr+63:mem_addr]</div></div></div><div class="intrinsic SSE" id="3350"><div class="instruction">movhps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_loadh_pi</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m64 const*</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_loadh_pi</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m64 const*</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: movhps xmm, m64<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Load 2 single-precision (32-bit) floating-point elements from memory into the upper 2 elements of <span class="desc_var dst">dst</span>, and copy the lower 2 elements from <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>. <span class="desc_var mem_addr">mem_addr</span> does not need to be aligned on any particular boundary.</div><h1>Operation</h1><div class="operation">dst[31:0] := a[31:0]
dst[63:32] := a[63:32]
dst[95:64] := MEM[mem_addr+31:mem_addr]
dst[127:96] := MEM[mem_addr+63:mem_addr+32]</div></div></div><div class="intrinsic SSE2" id="3351"><div class="instruction">movq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_loadl_epi64</span> (<span class="param_type">__m128i const*</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_loadl_epi64</span> (<span class="param_type">__m128i const*</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: movq xmm, m64<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Load 64-bit integer from memory into the first element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := MEM[mem_addr+63:mem_addr]
dst[MAX:64] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.33</td></tr><tr><td>Haswell</td><td>1</td><td>0.33</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.33</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="3352"><div class="instruction">movlpd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_loadl_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">double const*</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_loadl_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">double const*</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: movlpd xmm, m64<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Load a double-precision (64-bit) floating-point element from memory into the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>. <span class="desc_var mem_addr">mem_addr</span> does not need to be aligned on any particular boundary.</div><h1>Operation</h1><div class="operation">dst[63:0] := MEM[mem_addr+63:mem_addr]
dst[127:64] := a[127:64]</div></div></div><div class="intrinsic SSE" id="3353"><div class="instruction">movlps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_loadl_pi</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m64 const*</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_loadl_pi</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m64 const*</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: movlps xmm, m64<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Load 2 single-precision (32-bit) floating-point elements from memory into the lower 2 elements of <span class="desc_var dst">dst</span>, and copy the upper 2 elements from <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>. <span class="desc_var mem_addr">mem_addr</span> does not need to be aligned on any particular boundary.</div><h1>Operation</h1><div class="operation">dst[31:0] := MEM[mem_addr+31:mem_addr]
dst[63:32] := MEM[mem_addr+63:mem_addr+32]
dst[95:64] := a[95:64]
dst[127:96] := a[127:96]</div></div></div><div class="intrinsic SSE2" id="3354"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_loadr_pd</span> (<span class="param_type">double const*</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_loadr_pd</span> (<span class="param_type">double const*</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: <span class="instruction_note" note-type="sequence">movapd</span> xmm, m128<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Load 2 double-precision (64-bit) floating-point elements from memory into <span class="desc_var dst">dst</span> in reverse order. mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div><h1>Operation</h1><div class="operation">dst[63:0] := MEM[mem_addr+127:mem_addr+64]
dst[127:64] := MEM[mem_addr+63:mem_addr]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="3355"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_loadr_ps</span> (<span class="param_type">float const*</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_loadr_ps</span> (<span class="param_type">float const*</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Load 4 single-precision (32-bit) floating-point elements from memory into <span class="desc_var dst">dst</span> in reverse order. mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div><h1>Operation</h1><div class="operation">dst[31:0] := MEM[mem_addr+127:mem_addr+96]
dst[63:32] := MEM[mem_addr+95:mem_addr+64]
dst[95:64] := MEM[mem_addr+63:mem_addr+32]
dst[127:96] := MEM[mem_addr+31:mem_addr]</div></div></div><div class="intrinsic SSE2" id="3392"><div class="instruction">movupd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_loadu_pd</span> (<span class="param_type">double const*</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_loadu_pd</span> (<span class="param_type">double const*</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: movupd xmm, m128<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Load 128-bits (composed of 2 packed double-precision (64-bit) floating-point elements) from memory into <span class="desc_var dst">dst</span>.
	<span class="desc_var mem_addr">mem_addr</span> does not need to be aligned on any particular boundary.</div><h1>Operation</h1><div class="operation">dst[127:0] := MEM[mem_addr+127:mem_addr]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="3395"><div class="instruction">vmovupd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_loadu_pd</span> (<span class="param_type">double const *</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_loadu_pd</span> (<span class="param_type">double const *</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vmovupd ymm, m256<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Load 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from memory into <span class="desc_var dst">dst</span>.
	<span class="desc_var mem_addr">mem_addr</span> does not need to be aligned on any particular boundary.</div><h1>Operation</h1><div class="operation">dst[255:0] := MEM[mem_addr+255:mem_addr]
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.25</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="3401"><div class="instruction">movups</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_loadu_ps</span> (<span class="param_type">float const*</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_loadu_ps</span> (<span class="param_type">float const*</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: movups xmm, m128<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Load 128-bits (composed of 4 packed single-precision (32-bit) floating-point elements) from memory into <span class="desc_var dst">dst</span>.
	<span class="desc_var mem_addr">mem_addr</span> does not need to be aligned on any particular boundary.</div><h1>Operation</h1><div class="operation">dst[127:0] := MEM[mem_addr+127:mem_addr]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.25</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="3404"><div class="instruction">vmovups</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_loadu_ps</span> (<span class="param_type">float const *</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_loadu_ps</span> (<span class="param_type">float const *</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vmovups ymm, m256<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Load 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from memory into <span class="desc_var dst">dst</span>.
	<span class="desc_var mem_addr">mem_addr</span> does not need to be aligned on any particular boundary.</div><h1>Operation</h1><div class="operation">dst[255:0] := MEM[mem_addr+255:mem_addr]
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.25</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="3410"><div class="instruction">movdqu</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_loadu_si128</span> (<span class="param_type">__m128i const*</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_loadu_si128</span> (<span class="param_type">__m128i const*</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: movdqu xmm, m128<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Load 128-bits of integer data from memory into <span class="desc_var dst">dst</span>.
	<span class="desc_var mem_addr">mem_addr</span> does not need to be aligned on any particular boundary.
	</div><h1>Operation</h1><div class="operation">dst[127:0] := MEM[mem_addr+127:mem_addr]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.25</td></tr><tr><td>Broadwell</td><td>1</td><td>0.33</td></tr><tr><td>Haswell</td><td>1</td><td>0.33</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="3411"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_loadu_si16</span> (<span class="param_type">void const*</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_loadu_si16</span> (<span class="param_type">void const*</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Load unaligned 16-bit integer from memory into the first element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[15:0] := MEM[mem_addr+15:mem_addr]
dst[MAX:16] := 0</div></div></div><div class="intrinsic AVX" id="3412"><div class="instruction">vmovdqu</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_loadu_si256</span> (<span class="param_type">__m256i const *</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_loadu_si256</span> (<span class="param_type">__m256i const *</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vmovdqu ymm, m256<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Load 256-bits of integer data from memory into <span class="desc_var dst">dst</span>.
	<span class="desc_var mem_addr">mem_addr</span> does not need to be aligned on any particular boundary.
	</div><h1>Operation</h1><div class="operation">dst[255:0] := MEM[mem_addr+255:mem_addr]
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.25</td></tr><tr><td>Broadwell</td><td>1</td><td>0.25</td></tr><tr><td>Haswell</td><td>1</td><td>0.25</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="3413"><div class="instruction">movd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_loadu_si32</span> (<span class="param_type">void const*</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_loadu_si32</span> (<span class="param_type">void const*</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: movd xmm, m32<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Load unaligned 32-bit integer from memory into the first element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := MEM[mem_addr+31:mem_addr]
dst[MAX:32] := 0</div></div></div><div class="intrinsic SSE" id="3415"><div class="instruction">movq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_loadu_si64</span> (<span class="param_type">void const*</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_loadu_si64</span> (<span class="param_type">void const*</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: movq xmm, m64<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Load unaligned 64-bit integer from memory into the first element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := MEM[mem_addr+63:mem_addr]
dst[MAX:64] := 0</div></div></div><div class="intrinsic AVX" id="3416"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_loadu2_m128</span> (<span class="param_type">float const*</span> <span class="param_name">hiaddr</span>, <span class="param_type">float const*</span> <span class="param_name">loaddr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_loadu2_m128</span> (<span class="param_type">float const*</span> <span class="param_name">hiaddr</span>, <span class="param_type">float const*</span> <span class="param_name">loaddr</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Load two 128-bit values (composed of 4 packed single-precision (32-bit) floating-point elements) from memory, and combine them into a 256-bit value in <span class="desc_var dst">dst</span>.
	<span class="desc_var hiaddr">hiaddr</span> and <span class="desc_var loaddr">loaddr</span> do not need to be aligned on any particular boundary.</div><h1>Operation</h1><div class="operation">dst[127:0] := MEM[loaddr+127:loaddr]
dst[255:128] := MEM[hiaddr+127:hiaddr]
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX" id="3417"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_loadu2_m128d</span> (<span class="param_type">double const*</span> <span class="param_name">hiaddr</span>, <span class="param_type">double const*</span> <span class="param_name">loaddr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_loadu2_m128d</span> (<span class="param_type">double const*</span> <span class="param_name">hiaddr</span>, <span class="param_type">double const*</span> <span class="param_name">loaddr</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Load two 128-bit values (composed of 2 packed double-precision (64-bit) floating-point elements) from memory, and combine them into a 256-bit value in <span class="desc_var dst">dst</span>.
	<span class="desc_var hiaddr">hiaddr</span> and <span class="desc_var loaddr">loaddr</span> do not need to be aligned on any particular boundary.</div><h1>Operation</h1><div class="operation">dst[127:0] := MEM[loaddr+127:loaddr]
dst[255:128] := MEM[hiaddr+127:hiaddr]
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX" id="3418"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_loadu2_m128i</span> (<span class="param_type">__m128i const*</span> <span class="param_name">hiaddr</span>, <span class="param_type">__m128i const*</span> <span class="param_name">loaddr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_loadu2_m128i</span> (<span class="param_type">__m128i const*</span> <span class="param_name">hiaddr</span>, <span class="param_type">__m128i const*</span> <span class="param_name">loaddr</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Load two 128-bit values (composed of integer data) from memory, and combine them into a 256-bit value in <span class="desc_var dst">dst</span>.
	<span class="desc_var hiaddr">hiaddr</span> and <span class="desc_var loaddr">loaddr</span> do not need to be aligned on any particular boundary.</div><h1>Operation</h1><div class="operation">dst[127:0] := MEM[loaddr+127:loaddr]
dst[255:128] := MEM[hiaddr+127:hiaddr]
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="3499"><div class="instruction">pmaddwd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_madd_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_madd_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pmaddwd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Multiply packed signed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := a[i+31:i+16]*b[i+31:i+16] + a[i+15:i]*b[i+15:i]
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>5</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>1</td></tr><tr><td>Haswell</td><td>5</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="3502"><div class="instruction">vpmaddwd</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_madd_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_madd_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmaddwd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Multiply packed signed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := a[i+31:i+16]*b[i+31:i+16] + a[i+15:i]*b[i+15:i]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>5</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>1</td></tr><tr><td>Haswell</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic MMX" id="3508"><div class="instruction">pmaddwd</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_madd_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_madd_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: pmaddwd mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Multiply packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, producing intermediate 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*32
	dst[i+31:i] := a[i+31:i+16]*b[i+31:i+16] + a[i+15:i]*b[i+15:i]
ENDFOR</div></div></div><div class="intrinsic SSSE3" id="3527"><div class="instruction">pmaddubsw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_maddubs_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_maddubs_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: pmaddubsw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Vertically multiply each unsigned 8-bit integer from <span class="desc_var a">a</span> with the corresponding signed 8-bit integer from <span class="desc_var b">b</span>, producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := Saturate_To_Int16( a[i+15:i+8]*b[i+15:i+8] + a[i+7:i]*b[i+7:i] )
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>5</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>1</td></tr><tr><td>Haswell</td><td>5</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="3530"><div class="instruction">vpmaddubsw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_maddubs_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_maddubs_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmaddubsw ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Vertically multiply each unsigned 8-bit integer from <span class="desc_var a">a</span> with the corresponding signed 8-bit integer from <span class="desc_var b">b</span>, producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := Saturate_To_Int16( a[i+15:i+8]*b[i+15:i+8] + a[i+7:i]*b[i+7:i] )
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>5</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>1</td></tr><tr><td>Haswell</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSSE3" id="3536"><div class="instruction">pmaddubsw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_maddubs_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_maddubs_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: pmaddubsw mm, mm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Vertically multiply each unsigned 8-bit integer from <span class="desc_var a">a</span> with the corresponding signed 8-bit integer from <span class="desc_var b">b</span>, producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := Saturate_To_Int16( a[i+15:i+8]*b[i+15:i+8] + a[i+7:i]*b[i+7:i] )
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>5</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>1</td></tr><tr><td>Haswell</td><td>5</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="3537"><div class="signature"><span class="sig"><span class="rettype">void*</span> <span class="name">_mm_malloc</span> (<span class="param_type">size_t</span> <span class="param_name">size</span>, <span class="param_type">size_t</span> <span class="param_name">align</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void*</span> <span class="name">_mm_malloc</span> (<span class="param_type">size_t</span> <span class="param_name">size</span>, <span class="param_type">size_t</span> <span class="param_name">align</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Allocate <span class="desc_var size">size</span> bytes of memory, aligned to the alignment specified in <span class="desc_var align">align</span>, and return a pointer to the allocated memory. <span class="desc_var _mm_free">_mm_free</span> should be used to free memory that is allocated with <span class="desc_var _mm_malloc">_mm_malloc</span>.</div></div></div><div class="intrinsic AVX2" id="3540"><div class="instruction">vpmaskmovd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_maskload_epi32</span> (<span class="param_type">int const*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">mask</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_maskload_epi32</span> (<span class="param_type">int const*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">mask</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmaskmovd xmm, xmm, m128<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Load packed 32-bit integers from memory into <span class="desc_var dst">dst</span> using <span class="desc_var mask">mask</span> (elements are zeroed out when the highest bit is not set in the corresponding element).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	IF mask[i+31]
		dst[i+31:i] := MEM[mem_addr+i+31:mem_addr+i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX2" id="3541"><div class="instruction">vpmaskmovd</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_maskload_epi32</span> (<span class="param_type">int const*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">mask</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_maskload_epi32</span> (<span class="param_type">int const*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">mask</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmaskmovd ymm, ymm, m256<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Load packed 32-bit integers from memory into <span class="desc_var dst">dst</span> using <span class="desc_var mask">mask</span> (elements are zeroed out when the highest bit is not set in the corresponding element).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	IF mask[i+31]
		dst[i+31:i] := MEM[mem_addr+i+31:mem_addr+i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>11</td><td>1</td></tr><tr><td>Broadwell</td><td>8</td><td>2</td></tr><tr><td>Haswell</td><td>8</td><td>2</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="3542"><div class="instruction">vpmaskmovq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_maskload_epi64</span> (<span class="param_type">__int64 const*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">mask</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_maskload_epi64</span> (<span class="param_type">__int64 const*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">mask</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmaskmovq xmm, xmm, m128<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Load packed 64-bit integers from memory into <span class="desc_var dst">dst</span> using <span class="desc_var mask">mask</span> (elements are zeroed out when the highest bit is not set in the corresponding element).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	IF mask[i+63]
		dst[i+63:i] := MEM[mem_addr+i+63:mem_addr+i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX2" id="3543"><div class="instruction">vpmaskmovq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_maskload_epi64</span> (<span class="param_type">__int64 const*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">mask</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_maskload_epi64</span> (<span class="param_type">__int64 const*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">mask</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmaskmovq ymm, ymm, m256<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Load packed 64-bit integers from memory into <span class="desc_var dst">dst</span> using <span class="desc_var mask">mask</span> (elements are zeroed out when the highest bit is not set in the corresponding element).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	IF mask[i+63]
		dst[i+63:i] := MEM[mem_addr+i+63:mem_addr+i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>11</td><td>1</td></tr><tr><td>Broadwell</td><td>8</td><td>2</td></tr><tr><td>Haswell</td><td>8</td><td>2</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="3544"><div class="instruction">vmaskmovpd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_maskload_pd</span> (<span class="param_type">double const *</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">mask</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_maskload_pd</span> (<span class="param_type">double const *</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">mask</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vmaskmovpd xmm, xmm, m128<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Load packed double-precision (64-bit) floating-point elements from memory into <span class="desc_var dst">dst</span> using <span class="desc_var mask">mask</span> (elements are zeroed out when the high bit of the corresponding element is not set).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	IF mask[i+63]
		dst[i+63:i] := MEM[mem_addr+i+63:mem_addr+i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX" id="3545"><div class="instruction">vmaskmovpd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_maskload_pd</span> (<span class="param_type">double const *</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">mask</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_maskload_pd</span> (<span class="param_type">double const *</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">mask</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vmaskmovpd ymm, ymm, m256<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Load packed double-precision (64-bit) floating-point elements from memory into <span class="desc_var dst">dst</span> using <span class="desc_var mask">mask</span> (elements are zeroed out when the high bit of the corresponding element is not set).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	IF mask[i+63]
		dst[i+63:i] := MEM[mem_addr+i+63:mem_addr+i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>-</td><td>1</td></tr><tr><td>Broadwell</td><td>-</td><td>2</td></tr><tr><td>Haswell</td><td>-</td><td>2</td></tr><tr><td>Ivy Bridge</td><td>-</td><td>2</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="3546"><div class="instruction">vmaskmovps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_maskload_ps</span> (<span class="param_type">float const *</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">mask</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_maskload_ps</span> (<span class="param_type">float const *</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">mask</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vmaskmovps xmm, xmm, m128<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Load packed single-precision (32-bit) floating-point elements from memory into <span class="desc_var dst">dst</span> using <span class="desc_var mask">mask</span> (elements are zeroed out when the high bit of the corresponding element is not set).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	IF mask[i+31]
		dst[i+31:i] := MEM[mem_addr+i+31:mem_addr+i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX" id="3547"><div class="instruction">vmaskmovps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_maskload_ps</span> (<span class="param_type">float const *</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">mask</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_maskload_ps</span> (<span class="param_type">float const *</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">mask</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vmaskmovps ymm, ymm, m256<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Load packed single-precision (32-bit) floating-point elements from memory into <span class="desc_var dst">dst</span> using <span class="desc_var mask">mask</span> (elements are zeroed out when the high bit of the corresponding element is not set).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	IF mask[i+31]
		dst[i+31:i] := MEM[mem_addr+i+31:mem_addr+i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>11</td><td>1</td></tr><tr><td>Broadwell</td><td>8</td><td>2</td></tr><tr><td>Haswell</td><td>8</td><td>2</td></tr><tr><td>Ivy Bridge</td><td>8</td><td>2</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="3548"><div class="instruction">maskmovq</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_maskmove_si64</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">mask</span>, <span class="param_type">char*</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_maskmove_si64</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">mask</span>, <span class="param_type">char*</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: maskmovq mm, mm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Conditionally store 8-bit integer elements from <span class="desc_var a">a</span> into memory using <span class="desc_var mask">mask</span> (elements are not stored when the highest bit is not set in the corresponding element) and a non-temporal memory hint.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	IF mask[i+7]
		MEM[mem_addr+i+7:mem_addr+i] := a[i+7:i]
	FI
ENDFOR</div></div></div><div class="intrinsic SSE2" id="3549"><div class="instruction">maskmovdqu</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_maskmoveu_si128</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">mask</span>, <span class="param_type">char*</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_maskmoveu_si128</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">mask</span>, <span class="param_type">char*</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: maskmovdqu xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Conditionally store 8-bit integer elements from <span class="desc_var a">a</span> into memory using <span class="desc_var mask">mask</span> (elements are not stored when the highest bit is not set in the corresponding element) and a non-temporal memory hint. <span class="desc_var mem_addr">mem_addr</span> does not need to be aligned on any particular boundary.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*8
	IF mask[i+7]
		MEM[mem_addr+i+7:mem_addr+i] := a[i+7:i]
	FI
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>-</td><td>7</td></tr><tr><td>Broadwell</td><td>-</td><td>6</td></tr><tr><td>Haswell</td><td>-</td><td>6</td></tr><tr><td>Ivy Bridge</td><td>-</td><td>6</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="3550"><div class="instruction">maskmovq</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_m_maskmovq</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">mask</span>, <span class="param_type">char*</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_m_maskmovq</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">mask</span>, <span class="param_type">char*</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: maskmovq mm, mm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Conditionally store 8-bit integer elements from <span class="desc_var a">a</span> into memory using <span class="desc_var mask">mask</span> (elements are not stored when the highest bit is not set in the corresponding element).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	IF mask[i+7]
		MEM[mem_addr+i+7:mem_addr+i] := a[i+7:i]
	FI
ENDFOR</div></div></div><div class="intrinsic AVX2" id="3551"><div class="instruction">vpmaskmovd</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_maskstore_epi32</span> (<span class="param_type">int*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">mask</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_maskstore_epi32</span> (<span class="param_type">int*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">mask</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmaskmovd m128, xmm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Store packed 32-bit integers from <span class="desc_var a">a</span> into memory using <span class="desc_var mask">mask</span> (elements are not stored when the highest bit is not set in the corresponding element).
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	IF mask[i+31]
		MEM[mem_addr+i+31:mem_addr+i] := a[i+31:i]
	FI
ENDFOR</div></div></div><div class="intrinsic AVX2" id="3552"><div class="instruction">vpmaskmovd</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_maskstore_epi32</span> (<span class="param_type">int*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">mask</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_maskstore_epi32</span> (<span class="param_type">int*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">mask</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmaskmovd m256, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Store packed 32-bit integers from <span class="desc_var a">a</span> into memory using <span class="desc_var mask">mask</span> (elements are not stored when the highest bit is not set in the corresponding element).
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	IF mask[i+31]
		MEM[mem_addr+i+31:mem_addr+i] := a[i+31:i]
	FI
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>-</td><td>1</td></tr><tr><td>Broadwell</td><td>-</td><td>2</td></tr><tr><td>Haswell</td><td>-</td><td>2</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="3553"><div class="instruction">vpmaskmovq</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_maskstore_epi64</span> (<span class="param_type">__int64*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">mask</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_maskstore_epi64</span> (<span class="param_type">__int64*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">mask</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmaskmovq m128, xmm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Store packed 64-bit integers from <span class="desc_var a">a</span> into memory using <span class="desc_var mask">mask</span> (elements are not stored when the highest bit is not set in the corresponding element).
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	IF mask[i+63]
		MEM[mem_addr+i+63:mem_addr+i] := a[i+63:i]
	FI
ENDFOR</div></div></div><div class="intrinsic AVX2" id="3554"><div class="instruction">vpmaskmovq</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_maskstore_epi64</span> (<span class="param_type">__int64*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">mask</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_maskstore_epi64</span> (<span class="param_type">__int64*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">mask</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmaskmovq m256, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Store packed 64-bit integers from <span class="desc_var a">a</span> into memory using <span class="desc_var mask">mask</span> (elements are not stored when the highest bit is not set in the corresponding element).
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	IF mask[i+63]
		MEM[mem_addr+i+63:mem_addr+i] := a[i+63:i]
	FI
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>-</td><td>1</td></tr><tr><td>Broadwell</td><td>-</td><td>2</td></tr><tr><td>Haswell</td><td>-</td><td>2</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="3555"><div class="instruction">vmaskmovpd</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_maskstore_pd</span> (<span class="param_type">double *</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">mask</span>, <span class="param_type">__m128d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_maskstore_pd</span> (<span class="param_type">double *</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">mask</span>, <span class="param_type">__m128d</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vmaskmovpd m128, xmm, xmm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Store packed double-precision (64-bit) floating-point elements from <span class="desc_var a">a</span> into memory using <span class="desc_var mask">mask</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	IF mask[i+63]
		MEM[mem_addr+i+63:mem_addr+i] := a[i+63:i]
	FI
ENDFOR</div></div></div><div class="intrinsic AVX" id="3556"><div class="instruction">vmaskmovpd</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_maskstore_pd</span> (<span class="param_type">double *</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">mask</span>, <span class="param_type">__m256d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_maskstore_pd</span> (<span class="param_type">double *</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">mask</span>, <span class="param_type">__m256d</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vmaskmovpd m256, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Store packed double-precision (64-bit) floating-point elements from <span class="desc_var a">a</span> into memory using <span class="desc_var mask">mask</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	IF mask[i+63]
		MEM[mem_addr+i+63:mem_addr+i] := a[i+63:i]
	FI
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>-</td><td>1</td></tr><tr><td>Broadwell</td><td>-</td><td>2</td></tr><tr><td>Haswell</td><td>-</td><td>2</td></tr><tr><td>Ivy Bridge</td><td>-</td><td>2</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="3557"><div class="instruction">vmaskmovps</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_maskstore_ps</span> (<span class="param_type">float *</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">mask</span>, <span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_maskstore_ps</span> (<span class="param_type">float *</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">mask</span>, <span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vmaskmovps m128, xmm, xmm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Store packed single-precision (32-bit) floating-point elements from <span class="desc_var a">a</span> into memory using <span class="desc_var mask">mask</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	IF mask[i+31]
		MEM[mem_addr+i+31:mem_addr+i] := a[i+31:i]
	FI
ENDFOR</div></div></div><div class="intrinsic AVX" id="3558"><div class="instruction">vmaskmovps</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_maskstore_ps</span> (<span class="param_type">float *</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">mask</span>, <span class="param_type">__m256</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_maskstore_ps</span> (<span class="param_type">float *</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">mask</span>, <span class="param_type">__m256</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vmaskmovps m256, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Store packed single-precision (32-bit) floating-point elements from <span class="desc_var a">a</span> into memory using <span class="desc_var mask">mask</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	IF mask[i+31]
		MEM[mem_addr+i+31:mem_addr+i] := a[i+31:i]
	FI
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>-</td><td>1</td></tr><tr><td>Broadwell</td><td>-</td><td>2</td></tr><tr><td>Haswell</td><td>-</td><td>2</td></tr><tr><td>Ivy Bridge</td><td>-</td><td>2</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="3561"><div class="instruction">pmaxsw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_max_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_max_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pmaxsw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed maximum values in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	IF a[i+15:i] &gt; b[i+15:i]
		dst[i+15:i] := a[i+15:i]
	ELSE
		dst[i+15:i] := b[i+15:i]
	FI
ENDFOR</div></div></div><div class="intrinsic AVX2" id="3564"><div class="instruction">vpmaxsw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_max_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_max_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmaxsw ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Compare packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed maximum values in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	IF a[i+15:i] &gt; b[i+15:i]
		dst[i+15:i] := a[i+15:i]
	ELSE
		dst[i+15:i] := b[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE4_1" id="3570"><div class="instruction">pmaxsd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_max_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_max_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: pmaxsd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Compare packed 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed maximum values in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	IF a[i+31:i] &gt; b[i+31:i]
		dst[i+31:i] := a[i+31:i]
	ELSE
		dst[i+31:i] := b[i+31:i]
	FI
ENDFOR</div></div></div><div class="intrinsic AVX2" id="3573"><div class="instruction">vpmaxsd</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_max_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_max_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmaxsd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Compare packed 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed maximum values in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	IF a[i+31:i] &gt; b[i+31:i]
		dst[i+31:i] := a[i+31:i]
	ELSE
		dst[i+31:i] := b[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSE4_1" id="3588"><div class="instruction">pmaxsb</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_max_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_max_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: pmaxsb xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Compare packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed maximum values in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*8
	IF a[i+7:i] &gt; b[i+7:i]
		dst[i+7:i] := a[i+7:i]
	ELSE
		dst[i+7:i] := b[i+7:i]
	FI
ENDFOR</div></div></div><div class="intrinsic AVX2" id="3591"><div class="instruction">vpmaxsb</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_max_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_max_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmaxsb ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Compare packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed maximum values in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*8
	IF a[i+7:i] &gt; b[i+7:i]
		dst[i+7:i] := a[i+7:i]
	ELSE
		dst[i+7:i] := b[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE4_1" id="3597"><div class="instruction">pmaxuw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_max_epu16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_max_epu16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: pmaxuw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Compare packed unsigned 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed maximum values in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	IF a[i+15:i] &gt; b[i+15:i]
		dst[i+15:i] := a[i+15:i]
	ELSE
		dst[i+15:i] := b[i+15:i]
	FI
ENDFOR</div></div></div><div class="intrinsic AVX2" id="3600"><div class="instruction">vpmaxuw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_max_epu16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_max_epu16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmaxuw ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Compare packed unsigned 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed maximum values in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	IF a[i+15:i] &gt; b[i+15:i]
		dst[i+15:i] := a[i+15:i]
	ELSE
		dst[i+15:i] := b[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE4_1" id="3606"><div class="instruction">pmaxud</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_max_epu32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_max_epu32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: pmaxud xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Compare packed unsigned 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed maximum values in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	IF a[i+31:i] &gt; b[i+31:i]
		dst[i+31:i] := a[i+31:i]
	ELSE
		dst[i+31:i] := b[i+31:i]
	FI
ENDFOR</div></div></div><div class="intrinsic AVX2" id="3609"><div class="instruction">vpmaxud</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_max_epu32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_max_epu32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmaxud ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Compare packed unsigned 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed maximum values in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	IF a[i+31:i] &gt; b[i+31:i]
		dst[i+31:i] := a[i+31:i]
	ELSE
		dst[i+31:i] := b[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="3624"><div class="instruction">pmaxub</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_max_epu8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_max_epu8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pmaxub xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare packed unsigned 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed maximum values in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*8
	IF a[i+7:i] &gt; b[i+7:i]
		dst[i+7:i] := a[i+7:i]
	ELSE
		dst[i+7:i] := b[i+7:i]
	FI
ENDFOR</div></div></div><div class="intrinsic AVX2" id="3627"><div class="instruction">vpmaxub</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_max_epu8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_max_epu8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmaxub ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Compare packed unsigned 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed maximum values in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*8
	IF a[i+7:i] &gt; b[i+7:i]
		dst[i+7:i] := a[i+7:i]
	ELSE
		dst[i+7:i] := b[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="3633"><div class="instruction">maxpd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_max_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_max_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: maxpd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed maximum values in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := MAX(a[i+63:i], b[i+63:i])
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="3636"><div class="instruction">vmaxpd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_max_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_max_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vmaxpd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compare packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed maximum values in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := MAX(a[i+63:i], b[i+63:i])
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="3640"><div class="instruction">pmaxsw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_max_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_max_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: pmaxsw mm, mm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed maximum values in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	IF a[i+15:i] &gt; b[i+15:i]
		dst[i+15:i] := a[i+15:i]
	ELSE
		dst[i+15:i] := b[i+15:i]
	FI
ENDFOR</div></div></div><div class="intrinsic SSE" id="3643"><div class="instruction">maxps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_max_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_max_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: maxps xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed maximum values in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := MAX(a[i+31:i], b[i+31:i])
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="3646"><div class="instruction">vmaxps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_max_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_max_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vmaxps ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compare packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed maximum values in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := MAX(a[i+31:i], b[i+31:i])
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="3650"><div class="instruction">pmaxub</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_max_pu8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_max_pu8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: pmaxub mm, mm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare packed unsigned 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed maximum values in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	IF a[i+7:i] &gt; b[i+7:i]
		dst[i+7:i] := a[i+7:i]
	ELSE
		dst[i+7:i] := b[i+7:i]
	FI
ENDFOR</div></div></div><div class="intrinsic SSE2" id="3665"><div class="instruction">maxsd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_max_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_max_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: maxsd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare the lower double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, store the maximum value in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := MAX(a[63:0], b[63:0])
dst[127:64] := a[127:64]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="3668"><div class="instruction">maxss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_max_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_max_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: maxss xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare the lower single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, store the maximum value in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := MAX(a[31:0], b[31:0])
dst[127:32] := a[127:32]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="3672"><div class="instruction">mfence</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_mfence</span> (<span class="param_type">void</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_mfence</span> (<span class="param_type">void</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: mfence<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Perform a serializing operation on all load-from-memory and store-to-memory instructions that were issued prior to this instruction. Guarantees that every memory access that precedes, in program order, the memory fence instruction is globally visible before any memory instruction which follows the fence in program order.</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>-</td><td>~40</td></tr><tr><td>Broadwell</td><td>-</td><td>~35</td></tr><tr><td>Haswell</td><td>-</td><td>~35</td></tr><tr><td>Ivy Bridge</td><td>-</td><td>~35</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="3675"><div class="instruction">pminsw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_min_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_min_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pminsw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed minimum values in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	IF a[i+15:i] &lt; b[i+15:i]
		dst[i+15:i] := a[i+15:i]
	ELSE
		dst[i+15:i] := b[i+15:i]
	FI
ENDFOR</div></div></div><div class="intrinsic AVX2" id="3678"><div class="instruction">vpminsw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_min_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_min_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpminsw ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Compare packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed minimum values in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	IF a[i+15:i] &lt; b[i+15:i]
		dst[i+15:i] := a[i+15:i]
	ELSE
		dst[i+15:i] := b[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE4_1" id="3684"><div class="instruction">pminsd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_min_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_min_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: pminsd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Compare packed 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed minimum values in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	IF a[i+31:i] &lt; b[i+31:i]
		dst[i+31:i] := a[i+31:i]
	ELSE
		dst[i+31:i] := b[i+31:i]
	FI
ENDFOR</div></div></div><div class="intrinsic AVX2" id="3687"><div class="instruction">vpminsd</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_min_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_min_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpminsd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Compare packed 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed minimum values in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	IF a[i+31:i] &lt; b[i+31:i]
		dst[i+31:i] := a[i+31:i]
	ELSE
		dst[i+31:i] := b[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE4_1" id="3702"><div class="instruction">pminsb</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_min_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_min_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: pminsb xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Compare packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed minimum values in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*8
	IF a[i+7:i] &lt; b[i+7:i]
		dst[i+7:i] := a[i+7:i]
	ELSE
		dst[i+7:i] := b[i+7:i]
	FI
ENDFOR</div></div></div><div class="intrinsic AVX2" id="3705"><div class="instruction">vpminsb</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_min_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_min_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpminsb ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Compare packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed minimum values in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*8
	IF a[i+7:i] &lt; b[i+7:i]
		dst[i+7:i] := a[i+7:i]
	ELSE
		dst[i+7:i] := b[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE4_1" id="3711"><div class="instruction">pminuw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_min_epu16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_min_epu16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: pminuw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Compare packed unsigned 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed minimum values in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	IF a[i+15:i] &lt; b[i+15:i]
		dst[i+15:i] := a[i+15:i]
	ELSE
		dst[i+15:i] := b[i+15:i]
	FI
ENDFOR</div></div></div><div class="intrinsic AVX2" id="3714"><div class="instruction">vpminuw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_min_epu16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_min_epu16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpminuw ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Compare packed unsigned 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed minimum values in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	IF a[i+15:i] &lt; b[i+15:i]
		dst[i+15:i] := a[i+15:i]
	ELSE
		dst[i+15:i] := b[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE4_1" id="3720"><div class="instruction">pminud</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_min_epu32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_min_epu32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: pminud xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Compare packed unsigned 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed minimum values in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	IF a[i+31:i] &lt; b[i+31:i]
		dst[i+31:i] := a[i+31:i]
	ELSE
		dst[i+31:i] := b[i+31:i]
	FI
ENDFOR</div></div></div><div class="intrinsic AVX2" id="3723"><div class="instruction">vpminud</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_min_epu32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_min_epu32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpminud ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Compare packed unsigned 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed minimum values in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	IF a[i+31:i] &lt; b[i+31:i]
		dst[i+31:i] := a[i+31:i]
	ELSE
		dst[i+31:i] := b[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="3738"><div class="instruction">pminub</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_min_epu8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_min_epu8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pminub xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare packed unsigned 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed minimum values in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*8
	IF a[i+7:i] &lt; b[i+7:i]
		dst[i+7:i] := a[i+7:i]
	ELSE
		dst[i+7:i] := b[i+7:i]
	FI
ENDFOR</div></div></div><div class="intrinsic AVX2" id="3741"><div class="instruction">vpminub</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_min_epu8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_min_epu8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpminub ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Compare packed unsigned 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed minimum values in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*8
	IF a[i+7:i] &lt; b[i+7:i]
		dst[i+7:i] := a[i+7:i]
	ELSE
		dst[i+7:i] := b[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="3747"><div class="instruction">minpd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_min_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_min_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: minpd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed minimum values in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := MIN(a[i+63:i], b[i+63:i])
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="3750"><div class="instruction">vminpd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_min_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_min_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vminpd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compare packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed minimum values in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := MIN(a[i+63:i], b[i+63:i])
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="3754"><div class="instruction">pminsw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_min_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_min_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: pminsw mm, mm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed minimum values in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	IF a[i+15:i] &lt; b[i+15:i]
		dst[i+15:i] := a[i+15:i]
	ELSE
		dst[i+15:i] := b[i+15:i]
	FI
ENDFOR</div></div></div><div class="intrinsic SSE" id="3757"><div class="instruction">minps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_min_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_min_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: minps xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed minimum values in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := MIN(a[i+31:i], b[i+31:i])
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="3760"><div class="instruction">vminps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_min_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_min_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vminps ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compare packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed minimum values in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := MIN(a[i+31:i], b[i+31:i])
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="3764"><div class="instruction">pminub</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_min_pu8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_min_pu8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: pminub mm, mm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare packed unsigned 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed minimum values in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	IF a[i+7:i] &lt; b[i+7:i]
		dst[i+7:i] := a[i+7:i]
	ELSE
		dst[i+7:i] := b[i+7:i]
	FI
ENDFOR</div></div></div><div class="intrinsic SSE2" id="3779"><div class="instruction">minsd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_min_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_min_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: minsd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare the lower double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, store the minimum value in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := MIN(a[63:0], b[63:0])
dst[127:64] := a[127:64]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="3782"><div class="instruction">minss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_min_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_min_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: minss xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare the lower single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, store the minimum value in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := MIN(a[31:0], b[31:0])
dst[127:32] := a[127:32]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE4_1" id="3783"><div class="instruction">phminposuw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_minpos_epu16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_minpos_epu16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: phminposuw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Horizontally compute the minimum amongst the packed unsigned 16-bit integers in <span class="desc_var a">a</span>, store the minimum and index in <span class="desc_var dst">dst</span>, and zero the remaining bits in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">index[2:0] := 0
min[15:0] := a[15:0]
FOR j := 0 to 7
	i := j*16
	IF a[i+15:i] &lt; min[15:0]
		index[2:0] := j
		min[15:0] := a[i+15:i]
	FI
ENDFOR
dst[15:0] := min[15:0]
dst[18:16] := index[2:0]
dst[127:19] := 0</div></div></div><div class="intrinsic SSE2" id="3822"><div class="instruction">movq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_move_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_move_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: movq xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Copy the lower 64-bit integer in <span class="desc_var a">a</span> to the lower element of <span class="desc_var dst">dst</span>, and zero the upper element.</div><h1>Operation</h1><div class="operation">dst[63:0] := a[63:0]
dst[127:64] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.33</td></tr><tr><td>Haswell</td><td>1</td><td>0.33</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.33</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="3825"><div class="instruction">movsd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_move_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_move_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: movsd xmm, xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Move the lower double-precision (64-bit) floating-point element from <span class="desc_var b">b</span> to the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := b[63:0]
dst[127:64] := a[127:64]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="3828"><div class="instruction">movss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_move_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_move_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: movss xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Move the lower single-precision (32-bit) floating-point element from <span class="desc_var b">b</span> to the lower element of <span class="desc_var dst">dst</span>, and copy the upper 3 elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := b[31:0]
dst[63:32] := a[63:32]
dst[95:64] := a[95:64]
dst[127:96] := a[127:96]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE3" id="3831"><div class="instruction">movddup</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_movedup_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_movedup_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span><br>#include &lt;pmmintrin.h&gt;<br>Instruction: movddup xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE3</span></div><h1>Description</h1><div class="description">Duplicate the low double-precision (64-bit) floating-point element from <span class="desc_var a">a</span>, and store the results in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">tmp[63:0] := a[63:0]
tmp[127:64] := a[63:0]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="3834"><div class="instruction">vmovddup</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_movedup_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_movedup_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vmovddup ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Duplicate even-indexed double-precision (64-bit) floating-point elements from <span class="desc_var a">a</span>, and store the results in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">dst[63:0] := a[63:0]
dst[127:64] := a[63:0]
dst[191:128] := a[191:128]
dst[255:192] := a[191:128]
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE3" id="3840"><div class="instruction">movshdup</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_movehdup_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_movehdup_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;pmmintrin.h&gt;<br>Instruction: movshdup xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE3</span></div><h1>Description</h1><div class="description">Duplicate odd-indexed single-precision (32-bit) floating-point elements from <span class="desc_var a">a</span>, and store the results in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">dst[31:0] := a[63:32] 
dst[63:32] := a[63:32]
dst[95:64] := a[127:96] 
dst[127:96] := a[127:96]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="3843"><div class="instruction">vmovshdup</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_movehdup_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_movehdup_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vmovshdup ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Duplicate odd-indexed single-precision (32-bit) floating-point elements from <span class="desc_var a">a</span>, and store the results in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">dst[31:0] := a[63:32] 
dst[63:32] := a[63:32] 
dst[95:64] := a[127:96] 
dst[127:96] := a[127:96]
dst[159:128] := a[191:160] 
dst[191:160] := a[191:160] 
dst[223:192] := a[255:224] 
dst[255:224] := a[255:224]
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="3847"><div class="instruction">movhlps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_movehl_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_movehl_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: movhlps xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Move the upper 2 single-precision (32-bit) floating-point elements from <span class="desc_var b">b</span> to the lower 2 elements of <span class="desc_var dst">dst</span>, and copy the upper 2 elements from <span class="desc_var a">a</span> to the upper 2 elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := b[95:64]
dst[63:32] := b[127:96]
dst[95:64] := a[95:64]
dst[127:96] := a[127:96]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE3" id="3850"><div class="instruction">movsldup</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_moveldup_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_moveldup_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;pmmintrin.h&gt;<br>Instruction: movsldup xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE3</span></div><h1>Description</h1><div class="description">Duplicate even-indexed single-precision (32-bit) floating-point elements from <span class="desc_var a">a</span>, and store the results in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">dst[31:0] := a[31:0] 
dst[63:32] := a[31:0]
dst[95:64] := a[95:64] 
dst[127:96] := a[95:64]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="3853"><div class="instruction">vmovsldup</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_moveldup_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_moveldup_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vmovsldup ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Duplicate even-indexed single-precision (32-bit) floating-point elements from <span class="desc_var a">a</span>, and store the results in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">dst[31:0] := a[31:0] 
dst[63:32] := a[31:0] 
dst[95:64] := a[95:64] 
dst[127:96] := a[95:64]
dst[159:128] := a[159:128] 
dst[191:160] := a[159:128] 
dst[223:192] := a[223:192] 
dst[255:224] := a[223:192]
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="3857"><div class="instruction">movlhps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_movelh_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_movelh_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: movlhps xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Move the lower 2 single-precision (32-bit) floating-point elements from <span class="desc_var b">b</span> to the upper 2 elements of <span class="desc_var dst">dst</span>, and copy the lower 2 elements from <span class="desc_var a">a</span> to the lower 2 elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := a[31:0]
dst[63:32] := a[63:32]
dst[95:64] := b[31:0]
dst[127:96] := b[63:32]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="3858"><div class="instruction">pmovmskb</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_movemask_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_movemask_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pmovmskb r32, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Create mask from the most significant bit of each 8-bit element in <span class="desc_var a">a</span>, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*8
	dst[j] := a[i+7]
ENDFOR
dst[MAX:16] := 0</div></div></div><div class="intrinsic AVX2" id="3859"><div class="instruction">vpmovmskb</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm256_movemask_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm256_movemask_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmovmskb r32, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">
Create mask from the most significant bit of each 8-bit element in <span class="desc_var a">a</span>, and store the result in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*8
	dst[j] := a[i+7]
ENDFOR</div></div></div><div class="intrinsic SSE2" id="3860"><div class="instruction">movmskpd</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_movemask_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_movemask_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: movmskpd r32, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Set each bit of mask <span class="desc_var dst">dst</span> based on the most significant bit of the corresponding packed double-precision (64-bit) floating-point element in <span class="desc_var a">a</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	IF a[i+63]
		dst[j] := 1
	ELSE
		dst[j] := 0
	FI
ENDFOR
dst[MAX:2] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="3861"><div class="instruction">vmovmskpd</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm256_movemask_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm256_movemask_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vmovmskpd r32, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Set each bit of mask <span class="desc_var dst">dst</span> based on the most significant bit of the corresponding packed double-precision (64-bit) floating-point element in <span class="desc_var a">a</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	IF a[i+63]
		dst[j] := 1
	ELSE
		dst[j] := 0
	FI
ENDFOR
dst[MAX:4] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="3862"><div class="instruction">pmovmskb</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_movemask_pi8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_movemask_pi8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: pmovmskb r32, mm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Create mask from the most significant bit of each 8-bit element in <span class="desc_var a">a</span>, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	dst[j] := a[i+7]
ENDFOR
dst[MAX:8] := 0</div></div></div><div class="intrinsic SSE" id="3863"><div class="instruction">movmskps</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_movemask_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_movemask_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: movmskps r32, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Set each bit of mask <span class="desc_var dst">dst</span> based on the most significant bit of the corresponding packed single-precision (32-bit) floating-point element in <span class="desc_var a">a</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	IF a[i+31]
		dst[j] := 1
	ELSE
		dst[j] := 0
	FI
ENDFOR
dst[MAX:4] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="3864"><div class="instruction">vmovmskps</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm256_movemask_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm256_movemask_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vmovmskps r32, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Set each bit of mask <span class="desc_var dst">dst</span> based on the most significant bit of the corresponding packed single-precision (32-bit) floating-point element in <span class="desc_var a">a</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	IF a[i+31]
		dst[j] := 1
	ELSE
		dst[j] := 0
	FI
ENDFOR
dst[MAX:8] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="3874"><div class="instruction">movdq2q</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_movepi64_pi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_movepi64_pi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: movdq2q mm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Copy the lower 64-bit integer in <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := a[63:0]</div></div></div><div class="intrinsic SSE2" id="3890"><div class="instruction">movq2dq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_movpi64_epi64</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_movpi64_epi64</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: movq2dq xmm, mm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Copy the 64-bit integer <span class="desc_var a">a</span> to the lower element of <span class="desc_var dst">dst</span>, and zero the upper element.</div><h1>Operation</h1><div class="operation">dst[63:0] := a[63:0]
dst[127:64] := 0</div></div></div><div class="intrinsic SSE4_1" id="3891"><div class="instruction">mpsadbw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mpsadbw_epu8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mpsadbw_epu8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: mpsadbw xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in <span class="desc_var a">a</span> compared to those in <span class="desc_var b">b</span>, and store the 16-bit results in <span class="desc_var dst">dst</span>.
	Eight SADs are performed using one quadruplet from <span class="desc_var b">b</span> and eight quadruplets from <span class="desc_var a">a</span>. One quadruplet is selected from <span class="desc_var b">b</span> starting at on the offset specified in <span class="desc_var imm8">imm8</span>. Eight quadruplets are formed from sequential 8-bit integers selected from <span class="desc_var a">a</span> starting at the offset specified in <span class="desc_var imm8">imm8</span>.</div><h1>Operation</h1><div class="operation">DEFINE MPSADBW(a[127:0], b[127:0], imm8[2:0]) {
	a_offset := imm8[2]*32
	b_offset := imm8[1:0]*32
	FOR j := 0 to 7
		i := j*8
		k := a_offset+i
		l := b_offset
		tmp[i*2+15:i*2] := ABS(a[k+7:k] - b[l+7:l]) + ABS(a[k+15:k+8] - b[l+15:l+8]) + ABS(a[k+23:k+16] - b[l+23:l+16]) + ABS(a[k+31:k+24] - b[l+31:l+24])
	ENDFOR
	RETURN tmp[127:0]
}
dst[127:0] := MPSADBW(a[127:0], b[127:0], imm8[2:0])</div></div></div><div class="intrinsic AVX2" id="3892"><div class="instruction">vmpsadbw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mpsadbw_epu8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mpsadbw_epu8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vmpsadbw ymm, ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in <span class="desc_var a">a</span> compared to those in <span class="desc_var b">b</span>, and store the 16-bit results in <span class="desc_var dst">dst</span>.
	Eight SADs are performed for each 128-bit lane using one quadruplet from <span class="desc_var b">b</span> and eight quadruplets from <span class="desc_var a">a</span>. One quadruplet is selected from <span class="desc_var b">b</span> starting at on the offset specified in <span class="desc_var imm8">imm8</span>. Eight quadruplets are formed from sequential 8-bit integers selected from <span class="desc_var a">a</span> starting at the offset specified in <span class="desc_var imm8">imm8</span>.</div><h1>Operation</h1><div class="operation">DEFINE MPSADBW(a[127:0], b[127:0], imm8[2:0]) {
	a_offset := imm8[2]*32
	b_offset := imm8[1:0]*32
	FOR j := 0 to 7
		i := j*8
		k := a_offset+i
		l := b_offset
		tmp[i+15:i] := ABS(a[k+7:k] - b[l+7:l]) + ABS(a[k+15:k+8] - b[l+15:l+8]) + ABS(a[k+23:k+16] - b[l+23:l+16]) + ABS(a[k+31:k+24] - b[l+31:l+24])
	ENDFOR
	RETURN tmp[127:0]
}
dst[127:0] := MPSADBW(a[127:0], b[127:0], imm8[2:0])
dst[255:128] := MPSADBW(a[255:128], b[255:128], imm8[5:3])
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>2</td></tr><tr><td>Broadwell</td><td>6</td><td>2</td></tr><tr><td>Haswell</td><td>6</td><td>2</td></tr></tbody></table></div></div><div class="intrinsic SSE4_1" id="3895"><div class="instruction">pmuldq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mul_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mul_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: pmuldq xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Multiply the low 32-bit integers from each packed 64-bit element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the signed 64-bit results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := a[i+31:i] * b[i+31:i]
ENDFOR</div></div></div><div class="intrinsic AVX2" id="3898"><div class="instruction">vpmuldq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mul_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mul_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmuldq ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Multiply the low 32-bit integers from each packed 64-bit element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the signed 64-bit results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[i+31:i] * b[i+31:i]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>5</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>1</td></tr><tr><td>Haswell</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="3904"><div class="instruction">pmuludq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mul_epu32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mul_epu32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pmuludq xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Multiply the low unsigned 32-bit integers from each packed 64-bit element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the unsigned 64-bit results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := a[i+31:i] * b[i+31:i]
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>5</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>1</td></tr><tr><td>Haswell</td><td>5</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="3907"><div class="instruction">vpmuludq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mul_epu32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mul_epu32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmuludq ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Multiply the low unsigned 32-bit integers from each packed 64-bit element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the unsigned 64-bit results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[i+31:i] * b[i+31:i]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>5</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>1</td></tr><tr><td>Haswell</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="3913"><div class="instruction">mulpd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_mul_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_mul_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: mulpd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Multiply packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := a[i+63:i] * b[i+63:i]
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="3916"><div class="instruction">vmulpd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_mul_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_mul_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vmulpd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Multiply packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[i+63:i] * b[i+63:i]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="3922"><div class="instruction">mulps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_mul_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_mul_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: mulps xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Multiply packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := a[i+31:i] * b[i+31:i]
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="3925"><div class="instruction">vmulps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_mul_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_mul_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vmulps ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Multiply packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := a[i+31:i] * b[i+31:i]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="3943"><div class="instruction">mulsd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_mul_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_mul_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: mulsd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Multiply the lower double-precision (64-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := a[63:0] * b[63:0]
dst[127:64] := a[127:64]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="3946"><div class="instruction">mulss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_mul_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_mul_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: mulss xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Multiply the lower single-precision (32-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := a[31:0] * b[31:0]
dst[127:32] := a[127:32]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>0.5</td></tr><tr><td>Haswell</td><td>5</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="3947"><div class="instruction">pmuludq</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_mul_su32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_mul_su32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pmuludq mm, mm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Multiply the low unsigned 32-bit integers from <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the unsigned 64-bit result in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">dst[63:0] := a[31:0] * b[31:0]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>5</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>1</td></tr><tr><td>Haswell</td><td>5</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="3950"><div class="instruction">pmulhw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mulhi_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mulhi_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pmulhw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Multiply the packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	tmp[31:0] := a[i+15:i] * b[i+15:i]
	dst[i+15:i] := tmp[31:16]
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>5</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>1</td></tr><tr><td>Haswell</td><td>5</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="3953"><div class="instruction">vpmulhw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mulhi_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mulhi_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmulhw ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Multiply the packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	tmp[31:0] := a[i+15:i] * b[i+15:i]
	dst[i+15:i] := tmp[31:16]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>5</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>1</td></tr><tr><td>Haswell</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="3961"><div class="instruction">pmulhuw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mulhi_epu16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mulhi_epu16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pmulhuw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Multiply the packed unsigned 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	tmp[31:0] := a[i+15:i] * b[i+15:i]
	dst[i+15:i] := tmp[31:16]
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>5</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>1</td></tr><tr><td>Haswell</td><td>5</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="3964"><div class="instruction">vpmulhuw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mulhi_epu16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mulhi_epu16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmulhuw ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Multiply the packed unsigned 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	tmp[31:0] := a[i+15:i] * b[i+15:i]
	dst[i+15:i] := tmp[31:16]
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic MMX" id="3970"><div class="instruction">pmulhw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_mulhi_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_mulhi_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: pmulhw mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Multiply the packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	tmp[31:0] := a[i+15:i] * b[i+15:i]
	dst[i+15:i] := tmp[31:16]
ENDFOR</div></div></div><div class="intrinsic SSE" id="3971"><div class="instruction">pmulhuw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_mulhi_pu16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_mulhi_pu16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: pmulhuw mm, mm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Multiply the packed unsigned 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	tmp[31:0] := a[i+15:i] * b[i+15:i]
	dst[i+15:i] := tmp[31:16]
ENDFOR</div></div></div><div class="intrinsic SSSE3" id="3974"><div class="instruction">pmulhrsw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mulhrs_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mulhrs_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: pmulhrsw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Multiply packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	tmp[31:0] := ((a[i+15:i] * b[i+15:i]) &gt;&gt; 14) + 1
	dst[i+15:i] := tmp[16:1]
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>5</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>1</td></tr><tr><td>Haswell</td><td>5</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="3977"><div class="instruction">vpmulhrsw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mulhrs_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mulhrs_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmulhrsw ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Multiply packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	tmp[31:0] := ((a[i+15:i] * b[i+15:i]) &gt;&gt; 14) + 1
	dst[i+15:i] := tmp[16:1]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>5</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>1</td></tr><tr><td>Haswell</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSSE3" id="3981"><div class="instruction">pmulhrsw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_mulhrs_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_mulhrs_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: pmulhrsw mm, mm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Multiply packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	tmp[31:0] := ((a[i+15:i] * b[i+15:i]) &gt;&gt; 14) + 1
	dst[i+15:i] := tmp[16:1]
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>5</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>1</td></tr><tr><td>Haswell</td><td>5</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="3984"><div class="instruction">pmullw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mullo_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mullo_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pmullw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Multiply the packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	tmp[31:0] := a[i+15:i] * b[i+15:i]
	dst[i+15:i] := tmp[15:0]
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>5</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>1</td></tr><tr><td>Haswell</td><td>5</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="3987"><div class="instruction">vpmullw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mullo_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mullo_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmullw ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Multiply the packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	tmp[31:0] := a[i+15:i] * b[i+15:i]
	dst[i+15:i] := tmp[15:0]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>5</td><td>0.5</td></tr><tr><td>Broadwell</td><td>5</td><td>1</td></tr><tr><td>Haswell</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE4_1" id="3993"><div class="instruction">pmulld</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mullo_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mullo_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: pmulld xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Multiply the packed 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	tmp[63:0] := a[i+31:i] * b[i+31:i]
	dst[i+31:i] := tmp[31:0]
ENDFOR</div></div></div><div class="intrinsic AVX2" id="3996"><div class="instruction">vpmulld</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mullo_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mullo_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmulld ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Multiply the packed 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	tmp[63:0] := a[i+31:i] * b[i+31:i]
	dst[i+31:i] := tmp[31:0]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>10</td><td>1</td></tr><tr><td>Broadwell</td><td>10</td><td>2</td></tr><tr><td>Haswell</td><td>10</td><td>2</td></tr></tbody></table></div></div><div class="intrinsic MMX" id="4009"><div class="instruction">pmullw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_mullo_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_mullo_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: pmullw mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Multiply the packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	tmp[31:0] := a[i+15:i] * b[i+15:i]
	dst[i+15:i] := tmp[15:0]
ENDFOR</div></div></div><div class="intrinsic SSE2" id="4048"><div class="instruction">orpd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_or_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_or_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: orpd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compute the bitwise OR of packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := a[i+63:i] OR b[i+63:i]
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="4051"><div class="instruction">vorpd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_or_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_or_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vorpd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compute the bitwise OR of packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[i+63:i] OR b[i+63:i]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="4057"><div class="instruction">orps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_or_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_or_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: orps xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compute the bitwise OR of packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := a[i+31:i] OR b[i+31:i]
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="4060"><div class="instruction">vorps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_or_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_or_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vorps ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compute the bitwise OR of packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := a[i+31:i] OR b[i+31:i]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="4064"><div class="instruction">por</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_or_si128</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_or_si128</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: por xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compute the bitwise OR of 128 bits (representing integer data) in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[127:0] := (a[127:0] OR b[127:0])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.33</td></tr><tr><td>Haswell</td><td>1</td><td>0.33</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.33</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="4065"><div class="instruction">vpor</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_or_si256</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_or_si256</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpor ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Compute the bitwise OR of 256 bits (representing integer data) in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[255:0] := (a[255:0] OR b[255:0])
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.33</td></tr><tr><td>Haswell</td><td>1</td><td>0.33</td></tr></tbody></table></div></div><div class="intrinsic MMX" id="4067"><div class="instruction">por</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_or_si64</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_or_si64</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: por mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Compute the bitwise OR of 64 bits (representing integer data) in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := (a[63:0] OR b[63:0])</div></div></div><div class="intrinsic SSE2" id="4070"><div class="instruction">packsswb</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_packs_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_packs_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: packsswb xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Convert packed 16-bit integers from <span class="desc_var a">a</span> and <span class="desc_var b">b</span> to packed 8-bit integers using signed saturation, and store the results in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">dst[7:0] := Saturate_Int16_To_Int8 (a[15:0])
dst[15:8] := Saturate_Int16_To_Int8 (a[31:16])
dst[23:16] := Saturate_Int16_To_Int8 (a[47:32])
dst[31:24] := Saturate_Int16_To_Int8 (a[63:48])
dst[39:32] := Saturate_Int16_To_Int8 (a[79:64])
dst[47:40] := Saturate_Int16_To_Int8 (a[95:80])
dst[55:48] := Saturate_Int16_To_Int8 (a[111:96])
dst[63:56] := Saturate_Int16_To_Int8 (a[127:112])
dst[71:64] := Saturate_Int16_To_Int8 (b[15:0])
dst[79:72] := Saturate_Int16_To_Int8 (b[31:16])
dst[87:80] := Saturate_Int16_To_Int8 (b[47:32])
dst[95:88] := Saturate_Int16_To_Int8 (b[63:48])
dst[103:96] := Saturate_Int16_To_Int8 (b[79:64])
dst[111:104] := Saturate_Int16_To_Int8 (b[95:80])
dst[119:112] := Saturate_Int16_To_Int8 (b[111:96])
dst[127:120] := Saturate_Int16_To_Int8 (b[127:112])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="4073"><div class="instruction">vpacksswb</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_packs_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_packs_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpacksswb ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Convert packed 16-bit integers from <span class="desc_var a">a</span> and <span class="desc_var b">b</span> to packed 8-bit integers using signed saturation, and store the results in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">dst[7:0] := Saturate_Int16_To_Int8 (a[15:0])
dst[15:8] := Saturate_Int16_To_Int8 (a[31:16])
dst[23:16] := Saturate_Int16_To_Int8 (a[47:32])
dst[31:24] := Saturate_Int16_To_Int8 (a[63:48])
dst[39:32] := Saturate_Int16_To_Int8 (a[79:64])
dst[47:40] := Saturate_Int16_To_Int8 (a[95:80])
dst[55:48] := Saturate_Int16_To_Int8 (a[111:96])
dst[63:56] := Saturate_Int16_To_Int8 (a[127:112])
dst[71:64] := Saturate_Int16_To_Int8 (b[15:0])
dst[79:72] := Saturate_Int16_To_Int8 (b[31:16])
dst[87:80] := Saturate_Int16_To_Int8 (b[47:32])
dst[95:88] := Saturate_Int16_To_Int8 (b[63:48])
dst[103:96] := Saturate_Int16_To_Int8 (b[79:64])
dst[111:104] := Saturate_Int16_To_Int8 (b[95:80])
dst[119:112] := Saturate_Int16_To_Int8 (b[111:96])
dst[127:120] := Saturate_Int16_To_Int8 (b[127:112])
dst[135:128] := Saturate_Int16_To_Int8 (a[143:128])
dst[143:136] := Saturate_Int16_To_Int8 (a[159:144])
dst[151:144] := Saturate_Int16_To_Int8 (a[175:160])
dst[159:152] := Saturate_Int16_To_Int8 (a[191:176])
dst[167:160] := Saturate_Int16_To_Int8 (a[207:192])
dst[175:168] := Saturate_Int16_To_Int8 (a[223:208])
dst[183:176] := Saturate_Int16_To_Int8 (a[239:224])
dst[191:184] := Saturate_Int16_To_Int8 (a[255:240])
dst[199:192] := Saturate_Int16_To_Int8 (b[143:128])
dst[207:200] := Saturate_Int16_To_Int8 (b[159:144])
dst[215:208] := Saturate_Int16_To_Int8 (b[175:160])
dst[223:216] := Saturate_Int16_To_Int8 (b[191:176])
dst[231:224] := Saturate_Int16_To_Int8 (b[207:192])
dst[239:232] := Saturate_Int16_To_Int8 (b[223:208])
dst[247:240] := Saturate_Int16_To_Int8 (b[239:224])
dst[255:248] := Saturate_Int16_To_Int8 (b[255:240])
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="4079"><div class="instruction">packssdw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_packs_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_packs_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: packssdw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Convert packed 32-bit integers from <span class="desc_var a">a</span> and <span class="desc_var b">b</span> to packed 16-bit integers using signed saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[15:0] := Saturate_Int32_To_Int16 (a[31:0])
dst[31:16] := Saturate_Int32_To_Int16 (a[63:32])
dst[47:32] := Saturate_Int32_To_Int16 (a[95:64])
dst[63:48] := Saturate_Int32_To_Int16 (a[127:96])
dst[79:64] := Saturate_Int32_To_Int16 (b[31:0])
dst[95:80] := Saturate_Int32_To_Int16 (b[63:32])
dst[111:96] := Saturate_Int32_To_Int16 (b[95:64])
dst[127:112] := Saturate_Int32_To_Int16 (b[127:96])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="4082"><div class="instruction">vpackssdw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_packs_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_packs_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpackssdw ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Convert packed 32-bit integers from <span class="desc_var a">a</span> and <span class="desc_var b">b</span> to packed 16-bit integers using signed saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[15:0] := Saturate_Int32_To_Int16 (a[31:0])
dst[31:16] := Saturate_Int32_To_Int16 (a[63:32])
dst[47:32] := Saturate_Int32_To_Int16 (a[95:64])
dst[63:48] := Saturate_Int32_To_Int16 (a[127:96])
dst[79:64] := Saturate_Int32_To_Int16 (b[31:0])
dst[95:80] := Saturate_Int32_To_Int16 (b[63:32])
dst[111:96] := Saturate_Int32_To_Int16 (b[95:64])
dst[127:112] := Saturate_Int32_To_Int16 (b[127:96])
dst[143:128] := Saturate_Int32_To_Int16 (a[159:128])
dst[159:144] := Saturate_Int32_To_Int16 (a[191:160])
dst[175:160] := Saturate_Int32_To_Int16 (a[223:192])
dst[191:176] := Saturate_Int32_To_Int16 (a[255:224])
dst[207:192] := Saturate_Int32_To_Int16 (b[159:128])
dst[223:208] := Saturate_Int32_To_Int16 (b[191:160])
dst[239:224] := Saturate_Int32_To_Int16 (b[223:192])
dst[255:240] := Saturate_Int32_To_Int16 (b[255:224])
dst[MAX:256] := 0</div></div></div><div class="intrinsic MMX" id="4086"><div class="instruction">packsswb</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_packs_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_packs_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: packsswb mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Convert packed 16-bit integers from <span class="desc_var a">a</span> and <span class="desc_var b">b</span> to packed 8-bit integers using signed saturation, and store the results in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">dst[7:0] := Saturate_Int16_To_Int8 (a[15:0])
dst[15:8] := Saturate_Int16_To_Int8 (a[31:16])
dst[23:16] := Saturate_Int16_To_Int8 (a[47:32])
dst[31:24] := Saturate_Int16_To_Int8 (a[63:48])
dst[39:32] := Saturate_Int16_To_Int8 (b[15:0])
dst[47:40] := Saturate_Int16_To_Int8 (b[31:16])
dst[55:48] := Saturate_Int16_To_Int8 (b[47:32])
dst[63:56] := Saturate_Int16_To_Int8 (b[63:48])</div></div></div><div class="intrinsic MMX" id="4087"><div class="instruction">packssdw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_packs_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_packs_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: packssdw mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Convert packed 32-bit integers from <span class="desc_var a">a</span> and <span class="desc_var b">b</span> to packed 16-bit integers using signed saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[15:0] := Saturate_Int32_To_Int16 (a[31:0])
dst[31:16] := Saturate_Int32_To_Int16 (a[63:32])
dst[47:32] := Saturate_Int32_To_Int16 (b[31:0])
dst[63:48] := Saturate_Int32_To_Int16 (b[63:32])</div></div></div><div class="intrinsic MMX" id="4088"><div class="instruction">packuswb</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_packs_pu16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_packs_pu16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: packuswb mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Convert packed 16-bit integers from <span class="desc_var a">a</span> and <span class="desc_var b">b</span> to packed 8-bit integers using unsigned saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[7:0] := Saturate_Int16_To_UnsignedInt8 (a[15:0])
dst[15:8] := Saturate_Int16_To_UnsignedInt8 (a[31:16])
dst[23:16] := Saturate_Int16_To_UnsignedInt8 (a[47:32])
dst[31:24] := Saturate_Int16_To_UnsignedInt8 (a[63:48])
dst[39:32] := Saturate_Int16_To_UnsignedInt8 (b[15:0])
dst[47:40] := Saturate_Int16_To_UnsignedInt8 (b[31:16])
dst[55:48] := Saturate_Int16_To_UnsignedInt8 (b[47:32])
dst[63:56] := Saturate_Int16_To_UnsignedInt8 (b[63:48])</div></div></div><div class="intrinsic MMX" id="4089"><div class="instruction">packssdw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_packssdw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_packssdw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: packssdw mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Convert packed 32-bit integers from <span class="desc_var a">a</span> and <span class="desc_var b">b</span> to packed 16-bit integers using signed saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[15:0] := Saturate_Int32_To_Int16 (a[31:0])
dst[31:16] := Saturate_Int32_To_Int16 (a[63:32])
dst[47:32] := Saturate_Int32_To_Int16 (b[31:0])
dst[63:48] := Saturate_Int32_To_Int16 (b[63:32])</div></div></div><div class="intrinsic MMX" id="4090"><div class="instruction">packsswb</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_packsswb</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_packsswb</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: packsswb mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Convert packed 16-bit integers from <span class="desc_var a">a</span> and <span class="desc_var b">b</span> to packed 8-bit integers using signed saturation, and store the results in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">dst[7:0] := Saturate_Int16_To_Int8 (a[15:0])
dst[15:8] := Saturate_Int16_To_Int8 (a[31:16])
dst[23:16] := Saturate_Int16_To_Int8 (a[47:32])
dst[31:24] := Saturate_Int16_To_Int8 (a[63:48])
dst[39:32] := Saturate_Int16_To_Int8 (b[15:0])
dst[47:40] := Saturate_Int16_To_Int8 (b[31:16])
dst[55:48] := Saturate_Int16_To_Int8 (b[47:32])
dst[63:56] := Saturate_Int16_To_Int8 (b[63:48])</div></div></div><div class="intrinsic SSE2" id="4109"><div class="instruction">packuswb</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_packus_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_packus_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: packuswb xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Convert packed 16-bit integers from <span class="desc_var a">a</span> and <span class="desc_var b">b</span> to packed 8-bit integers using unsigned saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[7:0] := Saturate_Int16_To_UnsignedInt8 (a[15:0])
dst[15:8] := Saturate_Int16_To_UnsignedInt8 (a[31:16])
dst[23:16] := Saturate_Int16_To_UnsignedInt8 (a[47:32])
dst[31:24] := Saturate_Int16_To_UnsignedInt8 (a[63:48])
dst[39:32] := Saturate_Int16_To_UnsignedInt8 (a[79:64])
dst[47:40] := Saturate_Int16_To_UnsignedInt8 (a[95:80])
dst[55:48] := Saturate_Int16_To_UnsignedInt8 (a[111:96])
dst[63:56] := Saturate_Int16_To_UnsignedInt8 (a[127:112])
dst[71:64] := Saturate_Int16_To_UnsignedInt8 (b[15:0])
dst[79:72] := Saturate_Int16_To_UnsignedInt8 (b[31:16])
dst[87:80] := Saturate_Int16_To_UnsignedInt8 (b[47:32])
dst[95:88] := Saturate_Int16_To_UnsignedInt8 (b[63:48])
dst[103:96] := Saturate_Int16_To_UnsignedInt8 (b[79:64])
dst[111:104] := Saturate_Int16_To_UnsignedInt8 (b[95:80])
dst[119:112] := Saturate_Int16_To_UnsignedInt8 (b[111:96])
dst[127:120] := Saturate_Int16_To_UnsignedInt8 (b[127:112])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="4112"><div class="instruction">vpackuswb</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_packus_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_packus_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpackuswb ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Convert packed 16-bit integers from <span class="desc_var a">a</span> and <span class="desc_var b">b</span> to packed 8-bit integers using unsigned saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[7:0] := Saturate_Int16_To_UnsignedInt8 (a[15:0])
dst[15:8] := Saturate_Int16_To_UnsignedInt8 (a[31:16])
dst[23:16] := Saturate_Int16_To_UnsignedInt8 (a[47:32])
dst[31:24] := Saturate_Int16_To_UnsignedInt8 (a[63:48])
dst[39:32] := Saturate_Int16_To_UnsignedInt8 (a[79:64])
dst[47:40] := Saturate_Int16_To_UnsignedInt8 (a[95:80])
dst[55:48] := Saturate_Int16_To_UnsignedInt8 (a[111:96])
dst[63:56] := Saturate_Int16_To_UnsignedInt8 (a[127:112])
dst[71:64] := Saturate_Int16_To_UnsignedInt8 (b[15:0])
dst[79:72] := Saturate_Int16_To_UnsignedInt8 (b[31:16])
dst[87:80] := Saturate_Int16_To_UnsignedInt8 (b[47:32])
dst[95:88] := Saturate_Int16_To_UnsignedInt8 (b[63:48])
dst[103:96] := Saturate_Int16_To_UnsignedInt8 (b[79:64])
dst[111:104] := Saturate_Int16_To_UnsignedInt8 (b[95:80])
dst[119:112] := Saturate_Int16_To_UnsignedInt8 (b[111:96])
dst[127:120] := Saturate_Int16_To_UnsignedInt8 (b[127:112])
dst[135:128] := Saturate_Int16_To_UnsignedInt8 (a[143:128])
dst[143:136] := Saturate_Int16_To_UnsignedInt8 (a[159:144])
dst[151:144] := Saturate_Int16_To_UnsignedInt8 (a[175:160])
dst[159:152] := Saturate_Int16_To_UnsignedInt8 (a[191:176])
dst[167:160] := Saturate_Int16_To_UnsignedInt8 (a[207:192])
dst[175:168] := Saturate_Int16_To_UnsignedInt8 (a[223:208])
dst[183:176] := Saturate_Int16_To_UnsignedInt8 (a[239:224])
dst[191:184] := Saturate_Int16_To_UnsignedInt8 (a[255:240])
dst[199:192] := Saturate_Int16_To_UnsignedInt8 (b[143:128])
dst[207:200] := Saturate_Int16_To_UnsignedInt8 (b[159:144])
dst[215:208] := Saturate_Int16_To_UnsignedInt8 (b[175:160])
dst[223:216] := Saturate_Int16_To_UnsignedInt8 (b[191:176])
dst[231:224] := Saturate_Int16_To_UnsignedInt8 (b[207:192])
dst[239:232] := Saturate_Int16_To_UnsignedInt8 (b[223:208])
dst[247:240] := Saturate_Int16_To_UnsignedInt8 (b[239:224])
dst[255:248] := Saturate_Int16_To_UnsignedInt8 (b[255:240])
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE4_1" id="4118"><div class="instruction">packusdw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_packus_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_packus_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: packusdw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Convert packed 32-bit integers from <span class="desc_var a">a</span> and <span class="desc_var b">b</span> to packed 16-bit integers using unsigned saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[15:0] := Saturate_Int32_To_UnsignedInt16 (a[31:0])
dst[31:16] := Saturate_Int32_To_UnsignedInt16 (a[63:32])
dst[47:32] := Saturate_Int32_To_UnsignedInt16 (a[95:64])
dst[63:48] := Saturate_Int32_To_UnsignedInt16 (a[127:96])
dst[79:64] := Saturate_Int32_To_UnsignedInt16 (b[31:0])
dst[95:80] := Saturate_Int32_To_UnsignedInt16 (b[63:32])
dst[111:96] := Saturate_Int32_To_UnsignedInt16 (b[95:64])
dst[127:112] := Saturate_Int32_To_UnsignedInt16 (b[127:96])</div></div></div><div class="intrinsic AVX2" id="4121"><div class="instruction">vpackusdw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_packus_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_packus_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpackusdw ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Convert packed 32-bit integers from <span class="desc_var a">a</span> and <span class="desc_var b">b</span> to packed 16-bit integers using unsigned saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[15:0] := Saturate_Int32_To_UnsignedInt16 (a[31:0])
dst[31:16] := Saturate_Int32_To_UnsignedInt16 (a[63:32])
dst[47:32] := Saturate_Int32_To_UnsignedInt16 (a[95:64])
dst[63:48] := Saturate_Int32_To_UnsignedInt16 (a[127:96])
dst[79:64] := Saturate_Int32_To_UnsignedInt16 (b[31:0])
dst[95:80] := Saturate_Int32_To_UnsignedInt16 (b[63:32])
dst[111:96] := Saturate_Int32_To_UnsignedInt16 (b[95:64])
dst[127:112] := Saturate_Int32_To_UnsignedInt16 (b[127:96])
dst[143:128] := Saturate_Int32_To_UnsignedInt16 (a[159:128])
dst[159:144] := Saturate_Int32_To_UnsignedInt16 (a[191:160])
dst[175:160] := Saturate_Int32_To_UnsignedInt16 (a[223:192])
dst[191:176] := Saturate_Int32_To_UnsignedInt16 (a[255:224])
dst[207:192] := Saturate_Int32_To_UnsignedInt16 (b[159:128])
dst[223:208] := Saturate_Int32_To_UnsignedInt16 (b[191:160])
dst[239:224] := Saturate_Int32_To_UnsignedInt16 (b[223:192])
dst[255:240] := Saturate_Int32_To_UnsignedInt16 (b[255:224])
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic MMX" id="4125"><div class="instruction">packuswb</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_packuswb</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_packuswb</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: packuswb mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Convert packed 16-bit integers from <span class="desc_var a">a</span> and <span class="desc_var b">b</span> to packed 8-bit integers using unsigned saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[7:0] := Saturate_Int16_To_UnsignedInt8 (a[15:0])
dst[15:8] := Saturate_Int16_To_UnsignedInt8 (a[31:16])
dst[23:16] := Saturate_Int16_To_UnsignedInt8 (a[47:32])
dst[31:24] := Saturate_Int16_To_UnsignedInt8 (a[63:48])
dst[39:32] := Saturate_Int16_To_UnsignedInt8 (b[15:0])
dst[47:40] := Saturate_Int16_To_UnsignedInt8 (b[31:16])
dst[55:48] := Saturate_Int16_To_UnsignedInt8 (b[47:32])
dst[63:56] := Saturate_Int16_To_UnsignedInt8 (b[63:48])</div></div></div><div class="intrinsic MMX" id="4126"><div class="instruction">paddb</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_paddb</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_paddb</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: paddb mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Add packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := a[i+7:i] + b[i+7:i]
ENDFOR</div></div></div><div class="intrinsic MMX" id="4127"><div class="instruction">paddd</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_paddd</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_paddd</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: paddd mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Add packed 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*32
	dst[i+31:i] := a[i+31:i] + b[i+31:i]
ENDFOR</div></div></div><div class="intrinsic MMX" id="4128"><div class="instruction">paddsb</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_paddsb</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_paddsb</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: paddsb mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Add packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := Saturate_To_Int8( a[i+7:i] + b[i+7:i] )
ENDFOR</div></div></div><div class="intrinsic MMX" id="4129"><div class="instruction">paddsw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_paddsw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_paddsw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: paddsw mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Add packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := Saturate_To_Int16( a[i+15:i] + b[i+15:i] )
ENDFOR</div></div></div><div class="intrinsic MMX" id="4130"><div class="instruction">paddusb</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_paddusb</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_paddusb</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: paddusb mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Add packed unsigned 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := Saturate_To_UnsignedInt8( a[i+7:i] + b[i+7:i] )
ENDFOR</div></div></div><div class="intrinsic MMX" id="4131"><div class="instruction">paddusw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_paddusw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_paddusw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: paddusw mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Add packed unsigned 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := Saturate_To_UnsignedInt16( a[i+15:i] + b[i+15:i] )
ENDFOR</div></div></div><div class="intrinsic MMX" id="4132"><div class="instruction">paddw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_paddw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_paddw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: paddw mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Add packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := a[i+15:i] + b[i+15:i]
ENDFOR</div></div></div><div class="intrinsic MMX" id="4133"><div class="instruction">pand</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pand</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pand</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: pand mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Compute the bitwise AND of 64 bits (representing integer data) in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := (a[63:0] AND b[63:0])</div></div></div><div class="intrinsic MMX" id="4134"><div class="instruction">pandn</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pandn</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pandn</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: pandn mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Compute the bitwise NOT of 64 bits (representing integer data) in <span class="desc_var a">a</span> and then AND with <span class="desc_var b">b</span>, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := ((NOT a[63:0]) AND b[63:0])</div></div></div><div class="intrinsic SSE2" id="4135"><div class="instruction">pause</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_pause</span> (<span class="param_type">void</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_pause</span> (<span class="param_type">void</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pause<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Provide a hint to the processor that the code sequence is a spin-wait loop. This can help improve the performance and power consumption of spin-wait loops.</div></div></div><div class="intrinsic SSE" id="4136"><div class="instruction">pavgb</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pavgb</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pavgb</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: pavgb mm, mm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Average packed unsigned 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := (a[i+7:i] + b[i+7:i] + 1) &gt;&gt; 1
ENDFOR</div></div></div><div class="intrinsic SSE" id="4137"><div class="instruction">pavgw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pavgw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pavgw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: pavgw mm, mm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Average packed unsigned 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := (a[i+15:i] + b[i+15:i] + 1) &gt;&gt; 1
ENDFOR</div></div></div><div class="intrinsic MMX" id="4138"><div class="instruction">pcmpeqb</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pcmpeqb</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pcmpeqb</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: pcmpeqb mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Compare packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for equality, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := ( a[i+7:i] == b[i+7:i] ) ? 0xFF : 0
ENDFOR</div></div></div><div class="intrinsic MMX" id="4139"><div class="instruction">pcmpeqd</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pcmpeqd</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pcmpeqd</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: pcmpeqd mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Compare packed 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for equality, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*32
	dst[i+31:i] := ( a[i+31:i] == b[i+31:i] ) ? 0xFFFFFFFF : 0
ENDFOR</div></div></div><div class="intrinsic MMX" id="4140"><div class="instruction">pcmpeqw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pcmpeqw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pcmpeqw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: pcmpeqw mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Compare packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for equality, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := ( a[i+15:i] == b[i+15:i] ) ? 0xFFFF : 0
ENDFOR</div></div></div><div class="intrinsic MMX" id="4141"><div class="instruction">pcmpgtb</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pcmpgtb</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pcmpgtb</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: pcmpgtb mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Compare packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for greater-than, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := ( a[i+7:i] &gt; b[i+7:i] ) ? 0xFF : 0
ENDFOR</div></div></div><div class="intrinsic MMX" id="4142"><div class="instruction">pcmpgtd</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pcmpgtd</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pcmpgtd</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: pcmpgtd mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Compare packed 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for greater-than, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*32
	dst[i+31:i] := ( a[i+31:i] &gt; b[i+31:i] ) ? 0xFFFFFFFF : 0
ENDFOR</div></div></div><div class="intrinsic MMX" id="4143"><div class="instruction">pcmpgtw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pcmpgtw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pcmpgtw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: pcmpgtw mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Compare packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for greater-than, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := ( a[i+15:i] &gt; b[i+15:i] ) ? 0xFFFF : 0
ENDFOR</div></div></div><div class="intrinsic AVX" id="4149"><div class="instruction">vpermilpd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_permute_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_permute_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpermilpd xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Shuffle double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> using the control in <span class="desc_var imm8">imm8</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">IF (imm8[0] == 0) dst[63:0] := a[63:0]; FI
IF (imm8[0] == 1) dst[63:0] := a[127:64]; FI
IF (imm8[1] == 0) dst[127:64] := a[63:0]; FI
IF (imm8[1] == 1) dst[127:64] := a[127:64]; FI
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="4152"><div class="instruction">vpermilpd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_permute_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_permute_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpermilpd ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Shuffle double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> within 128-bit lanes using the control in <span class="desc_var imm8">imm8</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">IF (imm8[0] == 0) dst[63:0] := a[63:0]; FI
IF (imm8[0] == 1) dst[63:0] := a[127:64]; FI
IF (imm8[1] == 0) dst[127:64] := a[63:0]; FI
IF (imm8[1] == 1) dst[127:64] := a[127:64]; FI
IF (imm8[2] == 0) dst[191:128] := a[191:128]; FI
IF (imm8[2] == 1) dst[191:128] := a[255:192]; FI
IF (imm8[3] == 0) dst[255:192] := a[191:128]; FI
IF (imm8[3] == 1) dst[255:192] := a[255:192]; FI
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="4158"><div class="instruction">vpermilps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_permute_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_permute_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpermilps xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Shuffle single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> using the control in <span class="desc_var imm8">imm8</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">DEFINE SELECT4(src, control) {
	CASE(control[1:0]) OF
	0:	tmp[31:0] := src[31:0]
	1:	tmp[31:0] := src[63:32]
	2:	tmp[31:0] := src[95:64]
	3:	tmp[31:0] := src[127:96]
	ESAC
	RETURN tmp[31:0]
}
dst[31:0] := SELECT4(a[127:0], imm8[1:0])
dst[63:32] := SELECT4(a[127:0], imm8[3:2])
dst[95:64] := SELECT4(a[127:0], imm8[5:4])
dst[127:96] := SELECT4(a[127:0], imm8[7:6])
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="4161"><div class="instruction">vpermilps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_permute_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_permute_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpermilps ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Shuffle single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> within 128-bit lanes using the control in <span class="desc_var imm8">imm8</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">DEFINE SELECT4(src, control) {
	CASE(control[1:0]) OF
	0:	tmp[31:0] := src[31:0]
	1:	tmp[31:0] := src[63:32]
	2:	tmp[31:0] := src[95:64]
	3:	tmp[31:0] := src[127:96]
	ESAC
	RETURN tmp[31:0]
}
dst[31:0] := SELECT4(a[127:0], imm8[1:0])
dst[63:32] := SELECT4(a[127:0], imm8[3:2])
dst[95:64] := SELECT4(a[127:0], imm8[5:4])
dst[127:96] := SELECT4(a[127:0], imm8[7:6])
dst[159:128] := SELECT4(a[255:128], imm8[1:0])
dst[191:160] := SELECT4(a[255:128], imm8[3:2])
dst[223:192] := SELECT4(a[255:128], imm8[5:4])
dst[255:224] := SELECT4(a[255:128], imm8[7:6])
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="4165"><div class="instruction">vperm2f128</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_permute2f128_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_permute2f128_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vperm2f128 ymm, ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Shuffle 128-bits (composed of 2 packed double-precision (64-bit) floating-point elements) selected by <span class="desc_var imm8">imm8</span> from <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE SELECT4(src1, src2, control) {
	CASE(control[1:0]) OF
	0:	tmp[127:0] := src1[127:0]
	1:	tmp[127:0] := src1[255:128]
	2:	tmp[127:0] := src2[127:0]
	3:	tmp[127:0] := src2[255:128]
	ESAC
	IF control[3]
		tmp[127:0] := 0
	FI
	RETURN tmp[127:0]
}
dst[127:0] := SELECT4(a[255:0], b[255:0], imm8[3:0])
dst[255:128] := SELECT4(a[255:0], b[255:0], imm8[7:4])
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>1</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="4166"><div class="instruction">vperm2f128</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_permute2f128_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_permute2f128_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vperm2f128 ymm, ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Shuffle 128-bits (composed of 4 packed single-precision (32-bit) floating-point elements) selected by <span class="desc_var imm8">imm8</span> from <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE SELECT4(src1, src2, control) {
	CASE(control[1:0]) OF
	0:	tmp[127:0] := src1[127:0]
	1:	tmp[127:0] := src1[255:128]
	2:	tmp[127:0] := src2[127:0]
	3:	tmp[127:0] := src2[255:128]
	ESAC
	IF control[3]
		tmp[127:0] := 0
	FI
	RETURN tmp[127:0]
}
dst[127:0] := SELECT4(a[255:0], b[255:0], imm8[3:0])
dst[255:128] := SELECT4(a[255:0], b[255:0], imm8[7:4])
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>1</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="4167"><div class="instruction">vperm2f128</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_permute2f128_si256</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_permute2f128_si256</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vperm2f128 ymm, ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Shuffle 128-bits (composed of integer data) selected by <span class="desc_var imm8">imm8</span> from <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE SELECT4(src1, src2, control) {
	CASE(control[1:0]) OF
	0:	tmp[127:0] := src1[127:0]
	1:	tmp[127:0] := src1[255:128]
	2:	tmp[127:0] := src2[127:0]
	3:	tmp[127:0] := src2[255:128]
	ESAC
	IF control[3]
		tmp[127:0] := 0
	FI
	RETURN tmp[127:0]
}
dst[127:0] := SELECT4(a[255:0], b[255:0], imm8[3:0])
dst[255:128] := SELECT4(a[255:0], b[255:0], imm8[7:4])
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>1</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="4168"><div class="instruction">vperm2i128</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_permute2x128_si256</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_permute2x128_si256</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vperm2i128 ymm, ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shuffle 128-bits (composed of integer data) selected by <span class="desc_var imm8">imm8</span> from <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE SELECT4(src1, src2, control) {
	CASE(control[1:0]) OF
	0:	tmp[127:0] := src1[127:0]
	1:	tmp[127:0] := src1[255:128]
	2:	tmp[127:0] := src2[127:0]
	3:	tmp[127:0] := src2[255:128]
	ESAC
	IF control[3]
		tmp[127:0] := 0
	FI
	RETURN tmp[127:0]
}
dst[127:0] := SELECT4(a[255:0], b[255:0], imm8[3:0])
dst[255:128] := SELECT4(a[255:0], b[255:0], imm8[7:4])
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX2" id="4173"><div class="instruction">vpermq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_permute4x64_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_permute4x64_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpermq ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shuffle 64-bit integers in <span class="desc_var a">a</span> across lanes using the control in <span class="desc_var imm8">imm8</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">DEFINE SELECT4(src, control) {
	CASE(control[1:0]) OF
	0:	tmp[63:0] := src[63:0]
	1:	tmp[63:0] := src[127:64]
	2:	tmp[63:0] := src[191:128]
	3:	tmp[63:0] := src[255:192]
	ESAC
	RETURN tmp[63:0]
}
dst[63:0] := SELECT4(a[255:0], imm8[1:0])
dst[127:64] := SELECT4(a[255:0], imm8[3:2])
dst[191:128] := SELECT4(a[255:0], imm8[5:4])
dst[255:192] := SELECT4(a[255:0], imm8[7:6])
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX2" id="4174"><div class="instruction">vpermpd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_permute4x64_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_permute4x64_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpermpd ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shuffle double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> across lanes using the control in <span class="desc_var imm8">imm8</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">DEFINE SELECT4(src, control) {
	CASE(control[1:0]) OF
	0:	tmp[63:0] := src[63:0]
	1:	tmp[63:0] := src[127:64]
	2:	tmp[63:0] := src[191:128]
	3:	tmp[63:0] := src[255:192]
	ESAC
	RETURN tmp[63:0]
}
dst[63:0] := SELECT4(a[255:0], imm8[1:0])
dst[127:64] := SELECT4(a[255:0], imm8[3:2])
dst[191:128] := SELECT4(a[255:0], imm8[5:4])
dst[255:192] := SELECT4(a[255:0], imm8[7:6])
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>1</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="4179"><div class="instruction">vpermilpd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_permutevar_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_permutevar_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpermilpd xmm, xmm, xmm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Shuffle double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> using the control in <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">IF (b[1] == 0) dst[63:0] := a[63:0]; FI
IF (b[1] == 1) dst[63:0] := a[127:64]; FI
IF (b[65] == 0) dst[127:64] := a[63:0]; FI
IF (b[65] == 1) dst[127:64] := a[127:64]; FI
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="4182"><div class="instruction">vpermilpd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_permutevar_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_permutevar_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpermilpd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Shuffle double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> within 128-bit lanes using the control in <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">IF (b[1] == 0) dst[63:0] := a[63:0]; FI
IF (b[1] == 1) dst[63:0] := a[127:64]; FI
IF (b[65] == 0) dst[127:64] := a[63:0]; FI
IF (b[65] == 1) dst[127:64] := a[127:64]; FI
IF (b[129] == 0) dst[191:128] := a[191:128]; FI
IF (b[129] == 1) dst[191:128] := a[255:192]; FI
IF (b[193] == 0) dst[255:192] := a[191:128]; FI
IF (b[193] == 1) dst[255:192] := a[255:192]; FI
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="4188"><div class="instruction">vpermilps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_permutevar_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_permutevar_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpermilps xmm, xmm, xmm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Shuffle single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> using the control in <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">DEFINE SELECT4(src, control) {
	CASE(control[1:0]) OF
	0:	tmp[31:0] := src[31:0]
	1:	tmp[31:0] := src[63:32]
	2:	tmp[31:0] := src[95:64]
	3:	tmp[31:0] := src[127:96]
	ESAC
	RETURN tmp[31:0]
}
dst[31:0] := SELECT4(a[127:0], b[1:0])
dst[63:32] := SELECT4(a[127:0], b[33:32])
dst[95:64] := SELECT4(a[127:0], b[65:64])
dst[127:96] := SELECT4(a[127:0], b[97:96])
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="4191"><div class="instruction">vpermilps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_permutevar_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_permutevar_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpermilps ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Shuffle single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> within 128-bit lanes using the control in <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">DEFINE SELECT4(src, control) {
	CASE(control[1:0]) OF
	0:	tmp[31:0] := src[31:0]
	1:	tmp[31:0] := src[63:32]
	2:	tmp[31:0] := src[95:64]
	3:	tmp[31:0] := src[127:96]
	ESAC
	RETURN tmp[31:0]
}
dst[31:0] := SELECT4(a[127:0], b[1:0])
dst[63:32] := SELECT4(a[127:0], b[33:32])
dst[95:64] := SELECT4(a[127:0], b[65:64])
dst[127:96] := SELECT4(a[127:0], b[97:96])
dst[159:128] := SELECT4(a[255:128], b[129:128])
dst[191:160] := SELECT4(a[255:128], b[161:160])
dst[223:192] := SELECT4(a[255:128], b[193:192])
dst[255:224] := SELECT4(a[255:128], b[225:224])
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="4195"><div class="instruction">vpermd</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_permutevar8x32_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">idx</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_permutevar8x32_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">idx</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpermd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shuffle 32-bit integers in <span class="desc_var a">a</span> across lanes using the corresponding index in <span class="desc_var idx">idx</span>, and store the results in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	id := idx[i+2:i]*32
	dst[i+31:i] := a[id+31:id]
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX2" id="4196"><div class="instruction">vpermps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_permutevar8x32_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">idx</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_permutevar8x32_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">idx</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpermps ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shuffle single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> across lanes using the corresponding index in <span class="desc_var idx">idx</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	id := idx[i+2:i]*32
	dst[i+31:i] := a[id+31:id]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>1</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="4325"><div class="instruction">pextrw</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_m_pextrw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_m_pextrw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: pextrw r32, mm, imm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Extract a 16-bit integer from <span class="desc_var a">a</span>, selected with <span class="desc_var imm8">imm8</span>, and store the result in the lower element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[15:0] := (a[63:0] &gt;&gt; (imm8[1:0] * 16))[15:0]
dst[31:16] := 0</div></div></div><div class="intrinsic SSE" id="4326"><div class="instruction">pinsrw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pinsrw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">i</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pinsrw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">i</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: pinsrw mm, r32, imm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Copy <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>, and insert the 16-bit integer <span class="desc_var i">i</span> into <span class="desc_var dst">dst</span> at the location specified by <span class="desc_var imm8">imm8</span>. </div><h1>Operation</h1><div class="operation">dst[63:0] := a[63:0]
sel := imm8[1:0]*16
dst[sel+15:sel] := i[15:0]</div></div></div><div class="intrinsic MMX" id="4327"><div class="instruction">pmaddwd</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pmaddwd</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pmaddwd</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: pmaddwd mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Multiply packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, producing intermediate 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*32
	dst[i+31:i] := a[i+31:i+16]*b[i+31:i+16] + a[i+15:i]*b[i+15:i]
ENDFOR</div></div></div><div class="intrinsic SSE" id="4328"><div class="instruction">pmaxsw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pmaxsw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pmaxsw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: pmaxsw mm, mm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed maximum values in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	IF a[i+15:i] &gt; b[i+15:i]
		dst[i+15:i] := a[i+15:i]
	ELSE
		dst[i+15:i] := b[i+15:i]
	FI
ENDFOR</div></div></div><div class="intrinsic SSE" id="4329"><div class="instruction">pmaxub</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pmaxub</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pmaxub</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: pmaxub mm, mm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare packed unsigned 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed maximum values in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	IF a[i+7:i] &gt; b[i+7:i]
		dst[i+7:i] := a[i+7:i]
	ELSE
		dst[i+7:i] := b[i+7:i]
	FI
ENDFOR</div></div></div><div class="intrinsic SSE" id="4330"><div class="instruction">pminsw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pminsw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pminsw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: pminsw mm, mm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed minimum values in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	IF a[i+15:i] &lt; b[i+15:i]
		dst[i+15:i] := a[i+15:i]
	ELSE
		dst[i+15:i] := b[i+15:i]
	FI
ENDFOR</div></div></div><div class="intrinsic SSE" id="4331"><div class="instruction">pminub</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pminub</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pminub</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: pminub mm, mm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare packed unsigned 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store packed minimum values in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	IF a[i+7:i] &lt; b[i+7:i]
		dst[i+7:i] := a[i+7:i]
	ELSE
		dst[i+7:i] := b[i+7:i]
	FI
ENDFOR</div></div></div><div class="intrinsic SSE" id="4332"><div class="instruction">pmovmskb</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_m_pmovmskb</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_m_pmovmskb</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: pmovmskb r32, mm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Create mask from the most significant bit of each 8-bit element in <span class="desc_var a">a</span>, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	dst[j] := a[i+7]
ENDFOR
dst[MAX:8] := 0</div></div></div><div class="intrinsic SSE" id="4333"><div class="instruction">pmulhuw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pmulhuw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pmulhuw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: pmulhuw mm, mm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Multiply the packed unsigned 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	tmp[31:0] := a[i+15:i] * b[i+15:i]
	dst[i+15:i] := tmp[31:16]
ENDFOR</div></div></div><div class="intrinsic MMX" id="4334"><div class="instruction">pmulhw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pmulhw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pmulhw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: pmulhw mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Multiply the packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	tmp[31:0] := a[i+15:i] * b[i+15:i]
	dst[i+15:i] := tmp[31:16]
ENDFOR</div></div></div><div class="intrinsic MMX" id="4335"><div class="instruction">pmullw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pmullw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pmullw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: pmullw mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Multiply the packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	tmp[31:0] := a[i+15:i] * b[i+15:i]
	dst[i+15:i] := tmp[15:0]
ENDFOR</div></div></div><div class="intrinsic MMX" id="4376"><div class="instruction">por</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_por</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_por</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: por mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Compute the bitwise OR of 64 bits (representing integer data) in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := (a[63:0] OR b[63:0])</div></div></div><div class="intrinsic SSE" id="4385"><div class="instruction">prefetchnta, prefetcht0, prefetcht1, prefetcht2</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_prefetch</span> (<span class="param_type">char const*</span> <span class="param_name">p</span>, <span class="param_type">int</span> <span class="param_name">i</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_prefetch</span> (<span class="param_type">char const*</span> <span class="param_name">p</span>, <span class="param_type">int</span> <span class="param_name">i</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: prefetchnta mprefetch<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prefetcht0 mprefetch<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prefetcht1 mprefetch<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prefetcht2 mprefetch<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Fetch the line of data from memory that contains address <span class="desc_var p">p</span> to a location in the cache heirarchy specified by the locality hint <span class="desc_var i">i</span>.</div></div></div><div class="intrinsic SSE" id="4408"><div class="instruction">psadbw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psadbw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psadbw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: psadbw mm, mm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compute the absolute differences of packed unsigned 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, then horizontally sum each consecutive 8 differences to produce four unsigned 16-bit integers, and pack these unsigned 16-bit integers in the low 16 bits of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	tmp[i+7:i] := ABS(a[i+7:i] - b[i+7:i])
ENDFOR
dst[15:0] := tmp[7:0] + tmp[15:8] + tmp[23:16] + tmp[31:24] + tmp[39:32] + tmp[47:40] + tmp[55:48] + tmp[63:56]
dst[63:16] := 0</div></div></div><div class="intrinsic SSE" id="4409"><div class="instruction">pshufw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pshufw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pshufw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: pshufw mm, mm, imm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Shuffle 16-bit integers in <span class="desc_var a">a</span> using the control in <span class="desc_var imm8">imm8</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">DEFINE SELECT4(src, control) {
	CASE(control[1:0]) OF
	0:	tmp[15:0] := src[15:0]
	1:	tmp[15:0] := src[31:16]
	2:	tmp[15:0] := src[47:32]
	3:	tmp[15:0] := src[63:48]
	ESAC
	RETURN tmp[15:0]
}
dst[15:0] := SELECT4(a[63:0], imm8[1:0])
dst[31:16] := SELECT4(a[63:0], imm8[3:2])
dst[47:32] := SELECT4(a[63:0], imm8[5:4])
dst[63:48] := SELECT4(a[63:0], imm8[7:6])</div></div></div><div class="intrinsic MMX" id="4410"><div class="instruction">pslld</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pslld</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pslld</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">count</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: pslld mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Shift packed 32-bit integers in <span class="desc_var a">a</span> left by <span class="desc_var count">count</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend(a[i+31:i] &lt;&lt; count[63:0])
	FI
ENDFOR</div></div></div><div class="intrinsic MMX" id="4411"><div class="instruction">pslld</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pslldi</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pslldi</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: pslld mm, imm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Shift packed 32-bit integers in <span class="desc_var a">a</span> left by <span class="desc_var imm8">imm8</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend(a[i+31:i] &lt;&lt; imm8[7:0])
	FI
ENDFOR</div></div></div><div class="intrinsic MMX" id="4412"><div class="instruction">psllq</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psllq</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psllq</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">count</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psllq mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Shift 64-bit integer <span class="desc_var a">a</span> left by <span class="desc_var count">count</span> while shifting in zeros, and store the result in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">IF count[63:0] &gt; 63
	dst[63:0] := 0
ELSE
	dst[63:0] := ZeroExtend(a[63:0] &lt;&lt; count[63:0])
FI</div></div></div><div class="intrinsic MMX" id="4413"><div class="instruction">psllq</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psllqi</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psllqi</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psllq mm, imm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Shift 64-bit integer <span class="desc_var a">a</span> left by <span class="desc_var imm8">imm8</span> while shifting in zeros, and store the result in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">IF imm8[7:0] &gt; 63
	dst[63:0] := 0
ELSE
	dst[63:0] := ZeroExtend(a[63:0] &lt;&lt; imm8[7:0])
FI</div></div></div><div class="intrinsic MMX" id="4414"><div class="instruction">psllw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psllw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psllw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">count</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psllw mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Shift packed 16-bit integers in <span class="desc_var a">a</span> left by <span class="desc_var count">count</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend(a[i+15:i] &lt;&lt; count[63:0])
	FI
ENDFOR</div></div></div><div class="intrinsic MMX" id="4415"><div class="instruction">psllw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psllwi</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psllwi</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psllw mm, imm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Shift packed 16-bit integers in <span class="desc_var a">a</span> left by <span class="desc_var imm8">imm8</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend(a[i+15:i] &lt;&lt; imm8[7:0])
	FI
ENDFOR</div></div></div><div class="intrinsic MMX" id="4416"><div class="instruction">psrad</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psrad</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psrad</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">count</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psrad mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Shift packed 32-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var count">count</span> while shifting in sign bits, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := SignBit
	ELSE
		dst[i+31:i] := SignExtend(a[i+31:i] &gt;&gt; count[63:0])
	FI
ENDFOR</div></div></div><div class="intrinsic MMX" id="4417"><div class="instruction">psrad</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psradi</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psradi</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psrad mm, imm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Shift packed 32-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var imm8">imm8</span> while shifting in sign bits, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := SignBit
	ELSE
		dst[i+31:i] := SignExtend(a[i+31:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR</div></div></div><div class="intrinsic MMX" id="4418"><div class="instruction">psraw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psraw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psraw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">count</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psraw mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Shift packed 16-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var count">count</span> while shifting in sign bits, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := SignBit
	ELSE
		dst[i+15:i] := SignExtend(a[i+15:i] &gt;&gt; count[63:0])
	FI
ENDFOR</div></div></div><div class="intrinsic MMX" id="4419"><div class="instruction">psraw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psrawi</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psrawi</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psraw mm, imm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Shift packed 16-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var imm8">imm8</span> while shifting in sign bits, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := SignBit
	ELSE
		dst[i+15:i] := SignExtend(a[i+15:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR</div></div></div><div class="intrinsic MMX" id="4420"><div class="instruction">psrld</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psrld</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psrld</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">count</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psrld mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Shift packed 32-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var count">count</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend(a[i+31:i] &gt;&gt; count[63:0])
	FI
ENDFOR</div></div></div><div class="intrinsic MMX" id="4421"><div class="instruction">psrld</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psrldi</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psrldi</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psrld mm, imm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Shift packed 32-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var imm8">imm8</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend(a[i+31:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR</div></div></div><div class="intrinsic MMX" id="4422"><div class="instruction">psrlq</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psrlq</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psrlq</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">count</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psrlq mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Shift 64-bit integer <span class="desc_var a">a</span> right by <span class="desc_var count">count</span> while shifting in zeros, and store the result in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">IF count[63:0] &gt; 63
	dst[63:0] := 0
ELSE
	dst[63:0] := ZeroExtend(a[63:0] &gt;&gt; count[63:0])
FI</div></div></div><div class="intrinsic MMX" id="4423"><div class="instruction">psrlq</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psrlqi</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psrlqi</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psrlq mm, imm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Shift 64-bit integer <span class="desc_var a">a</span> right by <span class="desc_var imm8">imm8</span> while shifting in zeros, and store the result in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">IF imm8[7:0] &gt; 63
	dst[63:0] := 0
ELSE
	dst[63:0] := ZeroExtend(a[63:0] &gt;&gt; imm8[7:0])
FI</div></div></div><div class="intrinsic MMX" id="4424"><div class="instruction">psrlw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psrlw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psrlw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">count</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psrlw mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Shift packed 16-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var count">count</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend(a[i+15:i] &gt;&gt; count[63:0])
	FI
ENDFOR</div></div></div><div class="intrinsic MMX" id="4425"><div class="instruction">psrlw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psrlwi</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psrlwi</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psrlw mm, imm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Shift packed 16-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var imm8">imm8</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend(a[i+15:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR</div></div></div><div class="intrinsic MMX" id="4426"><div class="instruction">psubb</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psubb</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psubb</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psubb mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Subtract packed 8-bit integers in <span class="desc_var b">b</span> from packed 8-bit integers in <span class="desc_var a">a</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := a[i+7:i] - b[i+7:i]
ENDFOR</div></div></div><div class="intrinsic MMX" id="4427"><div class="instruction">psubd</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psubd</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psubd</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psubd mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Subtract packed 32-bit integers in <span class="desc_var b">b</span> from packed 32-bit integers in <span class="desc_var a">a</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*32
	dst[i+31:i] := a[i+31:i] - b[i+31:i]
ENDFOR</div></div></div><div class="intrinsic MMX" id="4428"><div class="instruction">psubsb</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psubsb</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psubsb</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psubsb mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Subtract packed 8-bit integers in <span class="desc_var b">b</span> from packed 8-bit integers in <span class="desc_var a">a</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := Saturate_To_Int8(a[i+7:i] - b[i+7:i])	
ENDFOR</div></div></div><div class="intrinsic MMX" id="4429"><div class="instruction">psubsw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psubsw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psubsw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psubsw mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Subtract packed 16-bit integers in <span class="desc_var b">b</span> from packed 16-bit integers in <span class="desc_var a">a</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := Saturate_To_Int16(a[i+15:i] - b[i+15:i])
ENDFOR</div></div></div><div class="intrinsic MMX" id="4430"><div class="instruction">psubusb</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psubusb</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psubusb</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psubusb mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Subtract packed unsigned 8-bit integers in <span class="desc_var b">b</span> from packed unsigned 8-bit integers in <span class="desc_var a">a</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := Saturate_To_UnsignedInt8(a[i+7:i] - b[i+7:i])	
ENDFOR</div></div></div><div class="intrinsic MMX" id="4431"><div class="instruction">psubusw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psubusw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psubusw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psubusw mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Subtract packed unsigned 16-bit integers in <span class="desc_var b">b</span> from packed unsigned 16-bit integers in <span class="desc_var a">a</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := Saturate_To_UnsignedInt16(a[i+15:i] - b[i+15:i])	
ENDFOR</div></div></div><div class="intrinsic MMX" id="4432"><div class="instruction">psubw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psubw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_psubw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psubw mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Subtract packed 16-bit integers in <span class="desc_var b">b</span> from packed 16-bit integers in <span class="desc_var a">a</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := a[i+15:i] - b[i+15:i]
ENDFOR</div></div></div><div class="intrinsic MMX" id="4435"><div class="instruction">punpckhbw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_punpckhbw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_punpckhbw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: punpckhbw mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Unpack and interleave 8-bit integers from the high half of <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE INTERLEAVE_HIGH_BYTES(src1[63:0], src2[63:0]) {
	dst[7:0] := src1[39:32]
	dst[15:8] := src2[39:32] 
	dst[23:16] := src1[47:40]
	dst[31:24] := src2[47:40]
	dst[39:32] := src1[55:48]
	dst[47:40] := src2[55:48]
	dst[55:48] := src1[63:56]
	dst[63:56] := src2[63:56]
	RETURN dst[63:0]
}
dst[63:0] := INTERLEAVE_HIGH_BYTES(a[63:0], b[63:0])</div></div></div><div class="intrinsic MMX" id="4436"><div class="instruction">punpckhdq</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_punpckhdq</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_punpckhdq</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: punpckhdq mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Unpack and interleave 32-bit integers from the high half of <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := a[63:32]
dst[63:32] := b[63:32]</div></div></div><div class="intrinsic MMX" id="4437"><div class="instruction">punpcklbw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_punpckhwd</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_punpckhwd</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: punpcklbw mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Unpack and interleave 16-bit integers from the high half of <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE INTERLEAVE_HIGH_WORDS(src1[63:0], src2[63:0]) {
	dst[15:0] := src1[47:32]
	dst[31:16] := src2[47:32]
	dst[47:32] := src1[63:48]
	dst[63:48] := src2[63:48]
	RETURN dst[63:0]
}
dst[63:0] := INTERLEAVE_HIGH_WORDS(a[63:0], b[63:0])</div></div></div><div class="intrinsic MMX" id="4438"><div class="instruction">punpcklbw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_punpcklbw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_punpcklbw</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: punpcklbw mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Unpack and interleave 8-bit integers from the low half of <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE INTERLEAVE_BYTES(src1[63:0], src2[63:0]) {
	dst[7:0] := src1[7:0] 
	dst[15:8] := src2[7:0] 
	dst[23:16] := src1[15:8] 
	dst[31:24] := src2[15:8] 
	dst[39:32] := src1[23:16] 
	dst[47:40] := src2[23:16] 
	dst[55:48] := src1[31:24] 
	dst[63:56] := src2[31:24] 
	RETURN dst[63:0]	
}
dst[63:0] := INTERLEAVE_BYTES(a[63:0], b[63:0])</div></div></div><div class="intrinsic MMX" id="4439"><div class="instruction">punpckldq</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_punpckldq</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_punpckldq</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: punpckldq mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Unpack and interleave 32-bit integers from the low half of <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">dst[31:0] := a[31:0]
dst[63:32] := b[31:0]</div></div></div><div class="intrinsic MMX" id="4440"><div class="instruction">punpcklwd</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_punpcklwd</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_punpcklwd</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: punpcklwd mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Unpack and interleave 16-bit integers from the low half of <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE INTERLEAVE_WORDS(src1[63:0], src2[63:0]) {
	dst[15:0] := src1[15:0] 
	dst[31:16] := src2[15:0] 
	dst[47:32] := src1[31:16] 
	dst[63:48] := src2[31:16] 
	RETURN dst[63:0]	
}
dst[63:0] := INTERLEAVE_WORDS(a[63:0], b[63:0])</div></div></div><div class="intrinsic MMX" id="4441"><div class="instruction">pxor</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pxor</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_m_pxor</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: pxor mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Compute the bitwise OR of 64 bits (representing integer data) in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := (a[63:0] XOR b[63:0])</div></div></div><div class="intrinsic SSE" id="4476"><div class="instruction">rcpps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_rcp_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_rcp_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: rcpps xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span>, and store the results in <span class="desc_var dst">dst</span>. The maximum relative error for this approximation is less than 1.5*2^-12.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := APPROXIMATE(1.0/a[i+31:i])
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>1</td></tr><tr><td>Broadwell</td><td>5</td><td>1</td></tr><tr><td>Haswell</td><td>5</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="4477"><div class="instruction">vrcpps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_rcp_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_rcp_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vrcpps ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span>, and store the results in <span class="desc_var dst">dst</span>. The maximum relative error for this approximation is less than 1.5*2^-12.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := APPROXIMATE(1.0/a[i+31:i])
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>1</td></tr><tr><td>Broadwell</td><td>7</td><td>2</td></tr><tr><td>Haswell</td><td>7</td><td>2</td></tr><tr><td>Ivy Bridge</td><td>7</td><td>2</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="4478"><div class="instruction">rcpss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_rcp_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_rcp_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: rcpss xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compute the approximate reciprocal of the lower single-precision (32-bit) floating-point element in <span class="desc_var a">a</span>, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>. The maximum relative error for this approximation is less than 1.5*2^-12.</div><h1>Operation</h1><div class="operation">dst[31:0] := APPROXIMATE(1.0/a[31:0])
dst[127:32] := a[127:32]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>1</td></tr><tr><td>Broadwell</td><td>5</td><td>1</td></tr><tr><td>Haswell</td><td>5</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE4_1" id="4749"><div class="instruction">roundpd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_round_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_round_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: roundpd xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Round the packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> using the <span class="desc_var rounding">rounding</span> parameter, and store the results as packed double-precision floating-point elements in <span class="desc_var dst">dst</span>.
	<br>Rounding is done according to the <span class="desc_var rounding">rounding</span> parameter, which can be one of:<div class="desc_note">    (_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions
    (_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions
    (_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions
    (_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions
    _MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div>
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := ROUND(a[i+63:i], rounding)
ENDFOR</div></div></div><div class="intrinsic AVX" id="4750"><div class="instruction">vroundpd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_round_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_round_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vroundpd ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Round the packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> using the <span class="desc_var rounding">rounding</span> parameter, and store the results as packed double-precision floating-point elements in <span class="desc_var dst">dst</span>.
	<br>Rounding is done according to the <span class="desc_var rounding">rounding</span> parameter, which can be one of:<div class="desc_note">    (_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions
    (_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions
    (_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions
    (_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions
    _MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div>
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := ROUND(a[i+63:i], rounding)
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>8</td><td>1</td></tr><tr><td>Broadwell</td><td>6</td><td>2</td></tr><tr><td>Haswell</td><td>6</td><td>2</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE4_1" id="4751"><div class="instruction">roundps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_round_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_round_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: roundps xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Round the packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> using the <span class="desc_var rounding">rounding</span> parameter, and store the results as packed single-precision floating-point elements in <span class="desc_var dst">dst</span>.
	<br>Rounding is done according to the <span class="desc_var rounding">rounding</span> parameter, which can be one of:<div class="desc_note">    (_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions
    (_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions
    (_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions
    (_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions
    _MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div>
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := ROUND(a[i+31:i], rounding)
ENDFOR</div></div></div><div class="intrinsic AVX" id="4752"><div class="instruction">vroundps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_round_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_round_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vroundps ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Round the packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> using the <span class="desc_var rounding">rounding</span> parameter, and store the results as packed single-precision floating-point elements in <span class="desc_var dst">dst</span>.
	<br>Rounding is done according to the <span class="desc_var rounding">rounding</span> parameter, which can be one of:<div class="desc_note">    (_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions
    (_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions
    (_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions
    (_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions
    _MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div>
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := ROUND(a[i+31:i], rounding)
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>8</td><td>1</td></tr><tr><td>Broadwell</td><td>6</td><td>2</td></tr><tr><td>Haswell</td><td>6</td><td>2</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE4_1" id="4755"><div class="instruction">roundsd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_round_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_round_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: roundsd xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Round the lower double-precision (64-bit) floating-point element in <span class="desc_var b">b</span> using the <span class="desc_var rounding">rounding</span> parameter, store the result as a double-precision floating-point element in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>.
	<br>Rounding is done according to the <span class="desc_var rounding">rounding</span> parameter, which can be one of:<div class="desc_note">    (_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions
    (_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions
    (_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions
    (_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions
    _MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div>
	</div><h1>Operation</h1><div class="operation">dst[63:0] := ROUND(b[63:0], rounding)
dst[127:64] := a[127:64]</div></div></div><div class="intrinsic SSE4_1" id="4756"><div class="instruction">roundss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_round_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_round_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: roundss xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Round the lower single-precision (32-bit) floating-point element in <span class="desc_var b">b</span> using the <span class="desc_var rounding">rounding</span> parameter, store the result as a single-precision floating-point element in the lower element of <span class="desc_var dst">dst</span>, and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>.
	<br>Rounding is done according to the <span class="desc_var rounding">rounding</span> parameter, which can be one of:<div class="desc_note">    (_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions
    (_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions
    (_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions
    (_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions
    _MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div>
	</div><h1>Operation</h1><div class="operation">dst[31:0] := ROUND(b[31:0], rounding)
dst[127:32] := a[127:32]</div></div></div><div class="intrinsic SSE" id="4797"><div class="instruction">rsqrtps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_rsqrt_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_rsqrt_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: rsqrtps xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span>, and store the results in <span class="desc_var dst">dst</span>. The maximum relative error for this approximation is less than 1.5*2^-12.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := APPROXIMATE(1.0 / SQRT(a[i+31:i]))
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>1</td></tr><tr><td>Broadwell</td><td>5</td><td>1</td></tr><tr><td>Haswell</td><td>5</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="4798"><div class="instruction">vrsqrtps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_rsqrt_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_rsqrt_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vrsqrtps ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span>, and store the results in <span class="desc_var dst">dst</span>. The maximum relative error for this approximation is less than 1.5*2^-12.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := APPROXIMATE(1.0 / SQRT(a[i+31:i]))
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>1</td></tr><tr><td>Broadwell</td><td>7</td><td>2</td></tr><tr><td>Haswell</td><td>7</td><td>2</td></tr><tr><td>Ivy Bridge</td><td>7</td><td>2</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="4799"><div class="instruction">rsqrtss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_rsqrt_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_rsqrt_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: rsqrtss xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compute the approximate reciprocal square root of the lower single-precision (32-bit) floating-point element in <span class="desc_var a">a</span>, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>. The maximum relative error for this approximation is less than 1.5*2^-12.</div><h1>Operation</h1><div class="operation">dst[31:0] := APPROXIMATE(1.0 / SQRT(a[31:0]))
dst[127:32] := a[127:32]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>1</td></tr><tr><td>Broadwell</td><td>5</td><td>1</td></tr><tr><td>Haswell</td><td>5</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="4847"><div class="instruction">psadbw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_sad_epu8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_sad_epu8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: psadbw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compute the absolute differences of packed unsigned 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, then horizontally sum each consecutive 8 differences to produce two unsigned 16-bit integers, and pack these unsigned 16-bit integers in the low 16 bits of 64-bit elements in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*8
	tmp[i+7:i] := ABS(a[i+7:i] - b[i+7:i])
ENDFOR
FOR j := 0 to 1
	i := j*64
	dst[i+15:i] := tmp[i+7:i] + tmp[i+15:i+8] + tmp[i+23:i+16] + tmp[i+31:i+24] + 
	               tmp[i+39:i+32] + tmp[i+47:i+40] + tmp[i+55:i+48] + tmp[i+63:i+56]
	dst[i+63:i+16] := 0
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>1</td></tr><tr><td>Broadwell</td><td>5</td><td>1</td></tr><tr><td>Haswell</td><td>5</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="4848"><div class="instruction">vpsadbw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_sad_epu8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_sad_epu8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsadbw ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Compute the absolute differences of packed unsigned 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, then horizontally sum each consecutive 8 differences to produce four unsigned 16-bit integers, and pack these unsigned 16-bit integers in the low 16 bits of 64-bit elements in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*8
	tmp[i+7:i] := ABS(a[i+7:i] - b[i+7:i])
ENDFOR
FOR j := 0 to 4
	i := j*64
	dst[i+15:i] := tmp[i+7:i] + tmp[i+15:i+8] + tmp[i+23:i+16] + tmp[i+31:i+24] + tmp[i+39:i+32] + tmp[i+47:i+40] + tmp[i+55:i+48] + tmp[i+63:i+56]
	dst[i+63:i+16] := 0
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>1</td></tr><tr><td>Broadwell</td><td>5</td><td>1</td></tr><tr><td>Haswell</td><td>5</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="4850"><div class="instruction">psadbw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_sad_pu8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_sad_pu8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: psadbw mm, mm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compute the absolute differences of packed unsigned 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, then horizontally sum each consecutive 8 differences to produce four unsigned 16-bit integers, and pack these unsigned 16-bit integers in the low 16 bits of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	tmp[i+7:i] := ABS(a[i+7:i] - b[i+7:i])
ENDFOR
dst[15:0] := tmp[7:0] + tmp[15:8] + tmp[23:16] + tmp[31:24] + tmp[39:32] + tmp[47:40] + tmp[55:48] + tmp[63:56]
dst[63:16] := 0</div></div></div><div class="intrinsic SSE2" id="4896"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_set_epi16</span> (<span class="param_type">short</span> <span class="param_name">e7</span>, <span class="param_type">short</span> <span class="param_name">e6</span>, <span class="param_type">short</span> <span class="param_name">e5</span>, <span class="param_type">short</span> <span class="param_name">e4</span>, <span class="param_type">short</span> <span class="param_name">e3</span>, <span class="param_type">short</span> <span class="param_name">e2</span>, <span class="param_type">short</span> <span class="param_name">e1</span>, <span class="param_type">short</span> <span class="param_name">e0</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_set_epi16</span> (<span class="param_type">short</span> <span class="param_name">e7</span>, <span class="param_type">short</span> <span class="param_name">e6</span>, <span class="param_type">short</span> <span class="param_name">e5</span>, <span class="param_type">short</span> <span class="param_name">e4</span>, <span class="param_type">short</span> <span class="param_name">e3</span>, <span class="param_type">short</span> <span class="param_name">e2</span>, <span class="param_type">short</span> <span class="param_name">e1</span>, <span class="param_type">short</span> <span class="param_name">e0</span>)</span><br>#include &lt;emmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Set packed 16-bit integers in <span class="desc_var dst">dst</span> with the supplied values.</div><h1>Operation</h1><div class="operation">dst[15:0] := e0
dst[31:16] := e1
dst[47:32] := e2
dst[63:48] := e3
dst[79:64] := e4
dst[95:80] := e5
dst[111:96] := e6
dst[127:112] := e7</div></div></div><div class="intrinsic AVX" id="4897"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_set_epi16</span> (<span class="param_type">short</span> <span class="param_name">e15</span>, <span class="param_type">short</span> <span class="param_name">e14</span>, <span class="param_type">short</span> <span class="param_name">e13</span>, <span class="param_type">short</span> <span class="param_name">e12</span>, <span class="param_type">short</span> <span class="param_name">e11</span>, <span class="param_type">short</span> <span class="param_name">e10</span>, <span class="param_type">short</span> <span class="param_name">e9</span>, <span class="param_type">short</span> <span class="param_name">e8</span>, <span class="param_type">short</span> <span class="param_name">e7</span>, <span class="param_type">short</span> <span class="param_name">e6</span>, <span class="param_type">short</span> <span class="param_name">e5</span>, <span class="param_type">short</span> <span class="param_name">e4</span>, <span class="param_type">short</span> <span class="param_name">e3</span>, <span class="param_type">short</span> <span class="param_name">e2</span>, <span class="param_type">short</span> <span class="param_name">e1</span>, <span class="param_type">short</span> <span class="param_name">e0</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_set_epi16</span> (<span class="param_type">short</span> <span class="param_name">e15</span>, <span class="param_type">short</span> <span class="param_name">e14</span>, <span class="param_type">short</span> <span class="param_name">e13</span>, <span class="param_type">short</span> <span class="param_name">e12</span>, <span class="param_type">short</span> <span class="param_name">e11</span>, <span class="param_type">short</span> <span class="param_name">e10</span>, <span class="param_type">short</span> <span class="param_name">e9</span>, <span class="param_type">short</span> <span class="param_name">e8</span>, <span class="param_type">short</span> <span class="param_name">e7</span>, <span class="param_type">short</span> <span class="param_name">e6</span>, <span class="param_type">short</span> <span class="param_name">e5</span>, <span class="param_type">short</span> <span class="param_name">e4</span>, <span class="param_type">short</span> <span class="param_name">e3</span>, <span class="param_type">short</span> <span class="param_name">e2</span>, <span class="param_type">short</span> <span class="param_name">e1</span>, <span class="param_type">short</span> <span class="param_name">e0</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Set packed 16-bit integers in <span class="desc_var dst">dst</span> with the supplied values.</div><h1>Operation</h1><div class="operation">dst[15:0] := e0
dst[31:16] := e1
dst[47:32] := e2
dst[63:48] := e3
dst[79:64] := e4
dst[95:80] := e5
dst[111:96] := e6
dst[127:112] := e7
dst[143:128] := e8
dst[159:144] := e9
dst[175:160] := e10
dst[191:176] := e11
dst[207:192] := e12
dst[223:208] := e13
dst[239:224] := e14
dst[255:240] := e15
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="4899"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_set_epi32</span> (<span class="param_type">int</span> <span class="param_name">e3</span>, <span class="param_type">int</span> <span class="param_name">e2</span>, <span class="param_type">int</span> <span class="param_name">e1</span>, <span class="param_type">int</span> <span class="param_name">e0</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_set_epi32</span> (<span class="param_type">int</span> <span class="param_name">e3</span>, <span class="param_type">int</span> <span class="param_name">e2</span>, <span class="param_type">int</span> <span class="param_name">e1</span>, <span class="param_type">int</span> <span class="param_name">e0</span>)</span><br>#include &lt;emmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Set packed 32-bit integers in <span class="desc_var dst">dst</span> with the supplied values.</div><h1>Operation</h1><div class="operation">dst[31:0] := e0
dst[63:32] := e1
dst[95:64] := e2
dst[127:96] := e3</div></div></div><div class="intrinsic AVX" id="4900"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_set_epi32</span> (<span class="param_type">int</span> <span class="param_name">e7</span>, <span class="param_type">int</span> <span class="param_name">e6</span>, <span class="param_type">int</span> <span class="param_name">e5</span>, <span class="param_type">int</span> <span class="param_name">e4</span>, <span class="param_type">int</span> <span class="param_name">e3</span>, <span class="param_type">int</span> <span class="param_name">e2</span>, <span class="param_type">int</span> <span class="param_name">e1</span>, <span class="param_type">int</span> <span class="param_name">e0</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_set_epi32</span> (<span class="param_type">int</span> <span class="param_name">e7</span>, <span class="param_type">int</span> <span class="param_name">e6</span>, <span class="param_type">int</span> <span class="param_name">e5</span>, <span class="param_type">int</span> <span class="param_name">e4</span>, <span class="param_type">int</span> <span class="param_name">e3</span>, <span class="param_type">int</span> <span class="param_name">e2</span>, <span class="param_type">int</span> <span class="param_name">e1</span>, <span class="param_type">int</span> <span class="param_name">e0</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Set packed 32-bit integers in <span class="desc_var dst">dst</span> with the supplied values.</div><h1>Operation</h1><div class="operation">dst[31:0] := e0
dst[63:32] := e1
dst[95:64] := e2
dst[127:96] := e3
dst[159:128] := e4
dst[191:160] := e5
dst[223:192] := e6
dst[255:224] := e7
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="4902"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_set_epi64</span> (<span class="param_type">__m64</span> <span class="param_name">e1</span>, <span class="param_type">__m64</span> <span class="param_name">e0</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_set_epi64</span> (<span class="param_type">__m64</span> <span class="param_name">e1</span>, <span class="param_type">__m64</span> <span class="param_name">e0</span>)</span><br>#include &lt;emmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Set packed 64-bit integers in <span class="desc_var dst">dst</span> with the supplied values.</div><h1>Operation</h1><div class="operation">dst[63:0] := e0
dst[127:64] := e1</div></div></div><div class="intrinsic SSE2" id="4904"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_set_epi64x</span> (<span class="param_type">__int64</span> <span class="param_name">e1</span>, <span class="param_type">__int64</span> <span class="param_name">e0</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_set_epi64x</span> (<span class="param_type">__int64</span> <span class="param_name">e1</span>, <span class="param_type">__int64</span> <span class="param_name">e0</span>)</span><br>#include &lt;emmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Set packed 64-bit integers in <span class="desc_var dst">dst</span> with the supplied values.</div><h1>Operation</h1><div class="operation">dst[63:0] := e0
dst[127:64] := e1</div></div></div><div class="intrinsic AVX" id="4905"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_set_epi64x</span> (<span class="param_type">__int64</span> <span class="param_name">e3</span>, <span class="param_type">__int64</span> <span class="param_name">e2</span>, <span class="param_type">__int64</span> <span class="param_name">e1</span>, <span class="param_type">__int64</span> <span class="param_name">e0</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_set_epi64x</span> (<span class="param_type">__int64</span> <span class="param_name">e3</span>, <span class="param_type">__int64</span> <span class="param_name">e2</span>, <span class="param_type">__int64</span> <span class="param_name">e1</span>, <span class="param_type">__int64</span> <span class="param_name">e0</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Set packed 64-bit integers in <span class="desc_var dst">dst</span> with the supplied values.</div><h1>Operation</h1><div class="operation">dst[63:0] := e0
dst[127:64] := e1
dst[191:128] := e2
dst[255:192] := e3
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="4906"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_set_epi8</span> (<span class="param_type">char</span> <span class="param_name">e15</span>, <span class="param_type">char</span> <span class="param_name">e14</span>, <span class="param_type">char</span> <span class="param_name">e13</span>, <span class="param_type">char</span> <span class="param_name">e12</span>, <span class="param_type">char</span> <span class="param_name">e11</span>, <span class="param_type">char</span> <span class="param_name">e10</span>, <span class="param_type">char</span> <span class="param_name">e9</span>, <span class="param_type">char</span> <span class="param_name">e8</span>, <span class="param_type">char</span> <span class="param_name">e7</span>, <span class="param_type">char</span> <span class="param_name">e6</span>, <span class="param_type">char</span> <span class="param_name">e5</span>, <span class="param_type">char</span> <span class="param_name">e4</span>, <span class="param_type">char</span> <span class="param_name">e3</span>, <span class="param_type">char</span> <span class="param_name">e2</span>, <span class="param_type">char</span> <span class="param_name">e1</span>, <span class="param_type">char</span> <span class="param_name">e0</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_set_epi8</span> (<span class="param_type">char</span> <span class="param_name">e15</span>, <span class="param_type">char</span> <span class="param_name">e14</span>, <span class="param_type">char</span> <span class="param_name">e13</span>, <span class="param_type">char</span> <span class="param_name">e12</span>, <span class="param_type">char</span> <span class="param_name">e11</span>, <span class="param_type">char</span> <span class="param_name">e10</span>, <span class="param_type">char</span> <span class="param_name">e9</span>, <span class="param_type">char</span> <span class="param_name">e8</span>, <span class="param_type">char</span> <span class="param_name">e7</span>, <span class="param_type">char</span> <span class="param_name">e6</span>, <span class="param_type">char</span> <span class="param_name">e5</span>, <span class="param_type">char</span> <span class="param_name">e4</span>, <span class="param_type">char</span> <span class="param_name">e3</span>, <span class="param_type">char</span> <span class="param_name">e2</span>, <span class="param_type">char</span> <span class="param_name">e1</span>, <span class="param_type">char</span> <span class="param_name">e0</span>)</span><br>#include &lt;emmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Set packed 8-bit integers in <span class="desc_var dst">dst</span> with the supplied values in reverse order.</div><h1>Operation</h1><div class="operation">dst[7:0] := e0
dst[15:8] := e1
dst[23:16] := e2
dst[31:24] := e3
dst[39:32] := e4
dst[47:40] := e5
dst[55:48] := e6
dst[63:56] := e7
dst[71:64] := e8
dst[79:72] := e9
dst[87:80] := e10
dst[95:88] := e11
dst[103:96] := e12
dst[111:104] := e13
dst[119:112] := e14
dst[127:120] := e15</div></div></div><div class="intrinsic AVX" id="4907"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_set_epi8</span> (<span class="param_type">char</span> <span class="param_name">e31</span>, <span class="param_type">char</span> <span class="param_name">e30</span>, <span class="param_type">char</span> <span class="param_name">e29</span>, <span class="param_type">char</span> <span class="param_name">e28</span>, <span class="param_type">char</span> <span class="param_name">e27</span>, <span class="param_type">char</span> <span class="param_name">e26</span>, <span class="param_type">char</span> <span class="param_name">e25</span>, <span class="param_type">char</span> <span class="param_name">e24</span>, <span class="param_type">char</span> <span class="param_name">e23</span>, <span class="param_type">char</span> <span class="param_name">e22</span>, <span class="param_type">char</span> <span class="param_name">e21</span>, <span class="param_type">char</span> <span class="param_name">e20</span>, <span class="param_type">char</span> <span class="param_name">e19</span>, <span class="param_type">char</span> <span class="param_name">e18</span>, <span class="param_type">char</span> <span class="param_name">e17</span>, <span class="param_type">char</span> <span class="param_name">e16</span>, <span class="param_type">char</span> <span class="param_name">e15</span>, <span class="param_type">char</span> <span class="param_name">e14</span>, <span class="param_type">char</span> <span class="param_name">e13</span>, <span class="param_type">char</span> <span class="param_name">e12</span>, <span class="param_type">char</span> <span class="param_name">e11</span>, <span class="param_type">char</span> <span class="param_name">e10</span>, <span class="param_type">char</span> <span class="param_name">e9</span>, <span class="param_type">char</span> <span class="param_name">e8</span>, <span class="param_type">char</span> <span class="param_name">e7</span>, <span class="param_type">char</span> <span class="param_name">e6</span>, <span class="param_type">char</span> <span class="param_name">e5</span>, <span class="param_type">char</span> <span class="param_name">e4</span>, <span class="param_type">char</span> <span class="param_name">e3</span>, <span class="param_type">char</span> <span class="param_name">e2</span>, <span class="param_type">char</span> <span class="param_name">e1</span>, <span class="param_type">char</span> <span class="param_name">e0</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_set_epi8</span> (<span class="param_type">char</span> <span class="param_name">e31</span>, <span class="param_type">char</span> <span class="param_name">e30</span>, <span class="param_type">char</span> <span class="param_name">e29</span>, <span class="param_type">char</span> <span class="param_name">e28</span>, <span class="param_type">char</span> <span class="param_name">e27</span>, <span class="param_type">char</span> <span class="param_name">e26</span>, <span class="param_type">char</span> <span class="param_name">e25</span>, <span class="param_type">char</span> <span class="param_name">e24</span>, <span class="param_type">char</span> <span class="param_name">e23</span>, <span class="param_type">char</span> <span class="param_name">e22</span>, <span class="param_type">char</span> <span class="param_name">e21</span>, <span class="param_type">char</span> <span class="param_name">e20</span>, <span class="param_type">char</span> <span class="param_name">e19</span>, <span class="param_type">char</span> <span class="param_name">e18</span>, <span class="param_type">char</span> <span class="param_name">e17</span>, <span class="param_type">char</span> <span class="param_name">e16</span>, <span class="param_type">char</span> <span class="param_name">e15</span>, <span class="param_type">char</span> <span class="param_name">e14</span>, <span class="param_type">char</span> <span class="param_name">e13</span>, <span class="param_type">char</span> <span class="param_name">e12</span>, <span class="param_type">char</span> <span class="param_name">e11</span>, <span class="param_type">char</span> <span class="param_name">e10</span>, <span class="param_type">char</span> <span class="param_name">e9</span>, <span class="param_type">char</span> <span class="param_name">e8</span>, <span class="param_type">char</span> <span class="param_name">e7</span>, <span class="param_type">char</span> <span class="param_name">e6</span>, <span class="param_type">char</span> <span class="param_name">e5</span>, <span class="param_type">char</span> <span class="param_name">e4</span>, <span class="param_type">char</span> <span class="param_name">e3</span>, <span class="param_type">char</span> <span class="param_name">e2</span>, <span class="param_type">char</span> <span class="param_name">e1</span>, <span class="param_type">char</span> <span class="param_name">e0</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Set packed 8-bit integers in <span class="desc_var dst">dst</span> with the supplied values in reverse order.</div><h1>Operation</h1><div class="operation">dst[7:0] := e0
dst[15:8] := e1
dst[23:16] := e2
dst[31:24] := e3
dst[39:32] := e4
dst[47:40] := e5
dst[55:48] := e6
dst[63:56] := e7
dst[71:64] := e8
dst[79:72] := e9
dst[87:80] := e10
dst[95:88] := e11
dst[103:96] := e12
dst[111:104] := e13
dst[119:112] := e14
dst[127:120] := e15
dst[135:128] := e16
dst[143:136] := e17
dst[151:144] := e18
dst[159:152] := e19
dst[167:160] := e20
dst[175:168] := e21
dst[183:176] := e22
dst[191:184] := e23
dst[199:192] := e24
dst[207:200] := e25
dst[215:208] := e26
dst[223:216] := e27
dst[231:224] := e28
dst[239:232] := e29
dst[247:240] := e30
dst[255:248] := e31
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE" id="4909"><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_MM_SET_EXCEPTION_MASK</span> (<span class="param_type">unsigned int</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_MM_SET_EXCEPTION_MASK</span> (<span class="param_type">unsigned int</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Macro: Set the exception mask bits of the MXCSR control and status register to the value in unsigned 32-bit integer <span class="desc_var a">a</span>. The exception mask may contain any of the following flags: _MM_MASK_INVALID, _MM_MASK_DIV_ZERO, _MM_MASK_DENORM, _MM_MASK_OVERFLOW, _MM_MASK_UNDERFLOW, _MM_MASK_INEXACT</div><h1>Operation</h1><div class="operation">MXCSR := a[31:0] AND ~_MM_MASK_MASK</div></div></div><div class="intrinsic SSE" id="4910"><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_MM_SET_EXCEPTION_STATE</span> (<span class="param_type">unsigned int</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_MM_SET_EXCEPTION_STATE</span> (<span class="param_type">unsigned int</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Macro: Set the exception state bits of the MXCSR control and status register to the value in unsigned 32-bit integer <span class="desc_var a">a</span>. The exception state may contain any of the following flags: _MM_EXCEPT_INVALID, _MM_EXCEPT_DIV_ZERO, _MM_EXCEPT_DENORM, _MM_EXCEPT_OVERFLOW, _MM_EXCEPT_UNDERFLOW, _MM_EXCEPT_INEXACT</div><h1>Operation</h1><div class="operation">MXCSR := a[31:0] AND ~_MM_EXCEPT_MASK</div></div></div><div class="intrinsic SSE" id="4911"><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_MM_SET_FLUSH_ZERO_MODE</span> (<span class="param_type">unsigned int</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_MM_SET_FLUSH_ZERO_MODE</span> (<span class="param_type">unsigned int</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Macro: Set the flush zero bits of the MXCSR control and status register to the value in unsigned 32-bit integer <span class="desc_var a">a</span>. The flush zero may contain any of the following flags: _MM_FLUSH_ZERO_ON or _MM_FLUSH_ZERO_OFF</div><h1>Operation</h1><div class="operation">MXCSR := a[31:0] AND ~_MM_FLUSH_MASK</div></div></div><div class="intrinsic AVX" id="4912"><div class="instruction">vinsertf128</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_set_m128</span> (<span class="param_type">__m128</span> <span class="param_name">hi</span>, <span class="param_type">__m128</span> <span class="param_name">lo</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_set_m128</span> (<span class="param_type">__m128</span> <span class="param_name">hi</span>, <span class="param_type">__m128</span> <span class="param_name">lo</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vinsertf128 ymm, ymm, xmm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Set packed __m256 vector <span class="desc_var dst">dst</span> with the supplied values.</div><h1>Operation</h1><div class="operation">dst[127:0] := lo[127:0]
dst[255:128] := hi[127:0]
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>1</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="4913"><div class="instruction">vinsertf128</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_set_m128d</span> (<span class="param_type">__m128d</span> <span class="param_name">hi</span>, <span class="param_type">__m128d</span> <span class="param_name">lo</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_set_m128d</span> (<span class="param_type">__m128d</span> <span class="param_name">hi</span>, <span class="param_type">__m128d</span> <span class="param_name">lo</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vinsertf128 ymm, ymm, xmm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Set packed __m256d vector <span class="desc_var dst">dst</span> with the supplied values.</div><h1>Operation</h1><div class="operation">dst[127:0] := lo[127:0]
dst[255:128] := hi[127:0]
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>1</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="4914"><div class="instruction">vinsertf128</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_set_m128i</span> (<span class="param_type">__m128i</span> <span class="param_name">hi</span>, <span class="param_type">__m128i</span> <span class="param_name">lo</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_set_m128i</span> (<span class="param_type">__m128i</span> <span class="param_name">hi</span>, <span class="param_type">__m128i</span> <span class="param_name">lo</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vinsertf128 ymm, ymm, xmm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Set packed __m256i vector <span class="desc_var dst">dst</span> with the supplied values.</div><h1>Operation</h1><div class="operation">dst[127:0] := lo[127:0]
dst[255:128] := hi[127:0]
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>1</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="4915"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_set_pd</span> (<span class="param_type">double</span> <span class="param_name">e1</span>, <span class="param_type">double</span> <span class="param_name">e0</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_set_pd</span> (<span class="param_type">double</span> <span class="param_name">e1</span>, <span class="param_type">double</span> <span class="param_name">e0</span>)</span><br>#include &lt;emmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Set packed double-precision (64-bit) floating-point elements in <span class="desc_var dst">dst</span> with the supplied values.</div><h1>Operation</h1><div class="operation">dst[63:0] := e0
dst[127:64] := e1</div></div></div><div class="intrinsic AVX" id="4916"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_set_pd</span> (<span class="param_type">double</span> <span class="param_name">e3</span>, <span class="param_type">double</span> <span class="param_name">e2</span>, <span class="param_type">double</span> <span class="param_name">e1</span>, <span class="param_type">double</span> <span class="param_name">e0</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_set_pd</span> (<span class="param_type">double</span> <span class="param_name">e3</span>, <span class="param_type">double</span> <span class="param_name">e2</span>, <span class="param_type">double</span> <span class="param_name">e1</span>, <span class="param_type">double</span> <span class="param_name">e0</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Set packed double-precision (64-bit) floating-point elements in <span class="desc_var dst">dst</span> with the supplied values.</div><h1>Operation</h1><div class="operation">dst[63:0] := e0
dst[127:64] := e1
dst[191:128] := e2
dst[255:192] := e3
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="4918"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_set_pd1</span> (<span class="param_type">double</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_set_pd1</span> (<span class="param_type">double</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Broadcast double-precision (64-bit) floating-point value <span class="desc_var a">a</span> to all elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := a[63:0]
ENDFOR</div></div></div><div class="intrinsic MMX" id="4919"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_set_pi16</span> (<span class="param_type">short</span> <span class="param_name">e3</span>, <span class="param_type">short</span> <span class="param_name">e2</span>, <span class="param_type">short</span> <span class="param_name">e1</span>, <span class="param_type">short</span> <span class="param_name">e0</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_set_pi16</span> (<span class="param_type">short</span> <span class="param_name">e3</span>, <span class="param_type">short</span> <span class="param_name">e2</span>, <span class="param_type">short</span> <span class="param_name">e1</span>, <span class="param_type">short</span> <span class="param_name">e0</span>)</span><br>#include &lt;mmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Set packed 16-bit integers in <span class="desc_var dst">dst</span> with the supplied values.</div><h1>Operation</h1><div class="operation">dst[15:0] := e0
dst[31:16] := e1
dst[47:32] := e2
dst[63:48] := e3</div></div></div><div class="intrinsic MMX" id="4920"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_set_pi32</span> (<span class="param_type">int</span> <span class="param_name">e1</span>, <span class="param_type">int</span> <span class="param_name">e0</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_set_pi32</span> (<span class="param_type">int</span> <span class="param_name">e1</span>, <span class="param_type">int</span> <span class="param_name">e0</span>)</span><br>#include &lt;mmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Set packed 32-bit integers in <span class="desc_var dst">dst</span> with the supplied values.</div><h1>Operation</h1><div class="operation">dst[31:0] := e0
dst[63:32] := e1</div></div></div><div class="intrinsic MMX" id="4921"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_set_pi8</span> (<span class="param_type">char</span> <span class="param_name">e7</span>, <span class="param_type">char</span> <span class="param_name">e6</span>, <span class="param_type">char</span> <span class="param_name">e5</span>, <span class="param_type">char</span> <span class="param_name">e4</span>, <span class="param_type">char</span> <span class="param_name">e3</span>, <span class="param_type">char</span> <span class="param_name">e2</span>, <span class="param_type">char</span> <span class="param_name">e1</span>, <span class="param_type">char</span> <span class="param_name">e0</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_set_pi8</span> (<span class="param_type">char</span> <span class="param_name">e7</span>, <span class="param_type">char</span> <span class="param_name">e6</span>, <span class="param_type">char</span> <span class="param_name">e5</span>, <span class="param_type">char</span> <span class="param_name">e4</span>, <span class="param_type">char</span> <span class="param_name">e3</span>, <span class="param_type">char</span> <span class="param_name">e2</span>, <span class="param_type">char</span> <span class="param_name">e1</span>, <span class="param_type">char</span> <span class="param_name">e0</span>)</span><br>#include &lt;mmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Set packed 8-bit integers in <span class="desc_var dst">dst</span> with the supplied values in reverse order.</div><h1>Operation</h1><div class="operation">dst[7:0] := e0
dst[15:8] := e1
dst[23:16] := e2
dst[31:24] := e3
dst[39:32] := e4
dst[47:40] := e5
dst[55:48] := e6
dst[63:56] := e7</div></div></div><div class="intrinsic SSE" id="4922"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_set_ps</span> (<span class="param_type">float</span> <span class="param_name">e3</span>, <span class="param_type">float</span> <span class="param_name">e2</span>, <span class="param_type">float</span> <span class="param_name">e1</span>, <span class="param_type">float</span> <span class="param_name">e0</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_set_ps</span> (<span class="param_type">float</span> <span class="param_name">e3</span>, <span class="param_type">float</span> <span class="param_name">e2</span>, <span class="param_type">float</span> <span class="param_name">e1</span>, <span class="param_type">float</span> <span class="param_name">e0</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Set packed single-precision (32-bit) floating-point elements in <span class="desc_var dst">dst</span> with the supplied values.</div><h1>Operation</h1><div class="operation">dst[31:0] := e0
dst[63:32] := e1
dst[95:64] := e2
dst[127:96] := e3</div></div></div><div class="intrinsic AVX" id="4923"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_set_ps</span> (<span class="param_type">float</span> <span class="param_name">e7</span>, <span class="param_type">float</span> <span class="param_name">e6</span>, <span class="param_type">float</span> <span class="param_name">e5</span>, <span class="param_type">float</span> <span class="param_name">e4</span>, <span class="param_type">float</span> <span class="param_name">e3</span>, <span class="param_type">float</span> <span class="param_name">e2</span>, <span class="param_type">float</span> <span class="param_name">e1</span>, <span class="param_type">float</span> <span class="param_name">e0</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_set_ps</span> (<span class="param_type">float</span> <span class="param_name">e7</span>, <span class="param_type">float</span> <span class="param_name">e6</span>, <span class="param_type">float</span> <span class="param_name">e5</span>, <span class="param_type">float</span> <span class="param_name">e4</span>, <span class="param_type">float</span> <span class="param_name">e3</span>, <span class="param_type">float</span> <span class="param_name">e2</span>, <span class="param_type">float</span> <span class="param_name">e1</span>, <span class="param_type">float</span> <span class="param_name">e0</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Set packed single-precision (32-bit) floating-point elements in <span class="desc_var dst">dst</span> with the supplied values.</div><h1>Operation</h1><div class="operation">dst[31:0] := e0
dst[63:32] := e1
dst[95:64] := e2
dst[127:96] := e3
dst[159:128] := e4
dst[191:160] := e5
dst[223:192] := e6
dst[255:224] := e7
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE" id="4925"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_set_ps1</span> (<span class="param_type">float</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_set_ps1</span> (<span class="param_type">float</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Broadcast single-precision (32-bit) floating-point value <span class="desc_var a">a</span> to all elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := a[31:0]
ENDFOR</div></div></div><div class="intrinsic SSE" id="4926"><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_MM_SET_ROUNDING_MODE</span> (<span class="param_type">unsigned int</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_MM_SET_ROUNDING_MODE</span> (<span class="param_type">unsigned int</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Macro: Set the rounding mode bits of the MXCSR control and status register to the value in unsigned 32-bit integer <span class="desc_var a">a</span>. The rounding mode may contain any of the following flags: _MM_ROUND_NEAREST, _MM_ROUND_DOWN, _MM_ROUND_UP, _MM_ROUND_TOWARD_ZERO</div><h1>Operation</h1><div class="operation">MXCSR := a[31:0] AND ~_MM_ROUND_MASK</div></div></div><div class="intrinsic SSE2" id="4927"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_set_sd</span> (<span class="param_type">double</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_set_sd</span> (<span class="param_type">double</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Copy double-precision (64-bit) floating-point element <span class="desc_var a">a</span> to the lower element of <span class="desc_var dst">dst</span>, and zero the upper element.</div><h1>Operation</h1><div class="operation">dst[63:0] := a[63:0]
dst[127:64] := 0</div></div></div><div class="intrinsic SSE" id="4928"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_set_ss</span> (<span class="param_type">float</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_set_ss</span> (<span class="param_type">float</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Copy single-precision (32-bit) floating-point element <span class="desc_var a">a</span> to the lower element of <span class="desc_var dst">dst</span>, and zero the upper 3 elements.</div><h1>Operation</h1><div class="operation">dst[31:0] := a[31:0]
dst[127:32] := 0</div></div></div><div class="intrinsic SSE2" id="4931"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_set1_epi16</span> (<span class="param_type">short</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_set1_epi16</span> (<span class="param_type">short</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Broadcast 16-bit integer <span class="desc_var a">a</span> to all all elements of <span class="desc_var dst">dst</span>. This intrinsic may generate <span class="desc_var vpbroadcastw">vpbroadcastw</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := a[15:0]
ENDFOR</div></div></div><div class="intrinsic AVX" id="4934"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_set1_epi16</span> (<span class="param_type">short</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_set1_epi16</span> (<span class="param_type">short</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Broadcast 16-bit integer <span class="desc_var a">a</span> to all all elements of <span class="desc_var dst">dst</span>. This intrinsic may generate the <span class="desc_var vpbroadcastw">vpbroadcastw</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := a[15:0]
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="4940"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_set1_epi32</span> (<span class="param_type">int</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_set1_epi32</span> (<span class="param_type">int</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Broadcast 32-bit integer <span class="desc_var a">a</span> to all elements of <span class="desc_var dst">dst</span>. This intrinsic may generate <span class="desc_var vpbroadcastd">vpbroadcastd</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := a[31:0]
ENDFOR</div></div></div><div class="intrinsic AVX" id="4943"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_set1_epi32</span> (<span class="param_type">int</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_set1_epi32</span> (<span class="param_type">int</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Broadcast 32-bit integer <span class="desc_var a">a</span> to all elements of <span class="desc_var dst">dst</span>. This intrinsic may generate the <span class="desc_var vpbroadcastd">vpbroadcastd</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := a[31:0]
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="4949"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_set1_epi64</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_set1_epi64</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Broadcast 64-bit integer <span class="desc_var a">a</span> to all elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := a[63:0]
ENDFOR</div></div></div><div class="intrinsic SSE2" id="4955"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_set1_epi64x</span> (<span class="param_type">__int64</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_set1_epi64x</span> (<span class="param_type">__int64</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Broadcast 64-bit integer <span class="desc_var a">a</span> to all elements of <span class="desc_var dst">dst</span>. This intrinsic may generate the <span class="desc_var vpbroadcastq">vpbroadcastq</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := a[63:0]
ENDFOR</div></div></div><div class="intrinsic AVX" id="4956"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_set1_epi64x</span> (<span class="param_type">long long</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_set1_epi64x</span> (<span class="param_type">long long</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Broadcast 64-bit integer <span class="desc_var a">a</span> to all elements of <span class="desc_var dst">dst</span>. This intrinsic may generate the <span class="desc_var vpbroadcastq">vpbroadcastq</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[63:0]
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="4959"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_set1_epi8</span> (<span class="param_type">char</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_set1_epi8</span> (<span class="param_type">char</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Broadcast 8-bit integer <span class="desc_var a">a</span> to all elements of <span class="desc_var dst">dst</span>. This intrinsic may generate <span class="desc_var vpbroadcastb">vpbroadcastb</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := a[7:0]
ENDFOR</div></div></div><div class="intrinsic AVX" id="4962"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_set1_epi8</span> (<span class="param_type">char</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_set1_epi8</span> (<span class="param_type">char</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Broadcast 8-bit integer <span class="desc_var a">a</span> to all elements of <span class="desc_var dst">dst</span>. This intrinsic may generate the <span class="desc_var vpbroadcastb">vpbroadcastb</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := a[7:0]
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="4966"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_set1_pd</span> (<span class="param_type">double</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_set1_pd</span> (<span class="param_type">double</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Broadcast double-precision (64-bit) floating-point value <span class="desc_var a">a</span> to all elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := a[63:0]
ENDFOR</div></div></div><div class="intrinsic AVX" id="4967"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_set1_pd</span> (<span class="param_type">double</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_set1_pd</span> (<span class="param_type">double</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Broadcast double-precision (64-bit) floating-point value <span class="desc_var a">a</span> to all elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[63:0]
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic MMX" id="4969"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_set1_pi16</span> (<span class="param_type">short</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_set1_pi16</span> (<span class="param_type">short</span> <span class="param_name">a</span>)</span><br>#include &lt;mmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Broadcast 16-bit integer <span class="desc_var a">a</span> to all all elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := a[15:0]
ENDFOR</div></div></div><div class="intrinsic MMX" id="4970"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_set1_pi32</span> (<span class="param_type">int</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_set1_pi32</span> (<span class="param_type">int</span> <span class="param_name">a</span>)</span><br>#include &lt;mmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Broadcast 32-bit integer <span class="desc_var a">a</span> to all elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*32
	dst[i+31:i] := a[31:0]
ENDFOR</div></div></div><div class="intrinsic MMX" id="4971"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_set1_pi8</span> (<span class="param_type">char</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_set1_pi8</span> (<span class="param_type">char</span> <span class="param_name">a</span>)</span><br>#include &lt;mmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Broadcast 8-bit integer <span class="desc_var a">a</span> to all elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := a[7:0]
ENDFOR</div></div></div><div class="intrinsic SSE" id="4972"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_set1_ps</span> (<span class="param_type">float</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_set1_ps</span> (<span class="param_type">float</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Broadcast single-precision (32-bit) floating-point value <span class="desc_var a">a</span> to all elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := a[31:0]
ENDFOR</div></div></div><div class="intrinsic AVX" id="4973"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_set1_ps</span> (<span class="param_type">float</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_set1_ps</span> (<span class="param_type">float</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Broadcast single-precision (32-bit) floating-point value <span class="desc_var a">a</span> to all elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := a[31:0]
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE" id="4979"><div class="instruction">ldmxcsr</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_setcsr</span> (<span class="param_type">unsigned int</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_setcsr</span> (<span class="param_type">unsigned int</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: ldmxcsr MEMd<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Set the MXCSR control and status register with the value in unsigned 32-bit integer <span class="desc_var a">a</span>.</div><h1>Operation</h1><div class="operation">MXCSR := a[31:0]</div></div></div><div class="intrinsic SSE2" id="4980"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_setr_epi16</span> (<span class="param_type">short</span> <span class="param_name">e7</span>, <span class="param_type">short</span> <span class="param_name">e6</span>, <span class="param_type">short</span> <span class="param_name">e5</span>, <span class="param_type">short</span> <span class="param_name">e4</span>, <span class="param_type">short</span> <span class="param_name">e3</span>, <span class="param_type">short</span> <span class="param_name">e2</span>, <span class="param_type">short</span> <span class="param_name">e1</span>, <span class="param_type">short</span> <span class="param_name">e0</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_setr_epi16</span> (<span class="param_type">short</span> <span class="param_name">e7</span>, <span class="param_type">short</span> <span class="param_name">e6</span>, <span class="param_type">short</span> <span class="param_name">e5</span>, <span class="param_type">short</span> <span class="param_name">e4</span>, <span class="param_type">short</span> <span class="param_name">e3</span>, <span class="param_type">short</span> <span class="param_name">e2</span>, <span class="param_type">short</span> <span class="param_name">e1</span>, <span class="param_type">short</span> <span class="param_name">e0</span>)</span><br>#include &lt;emmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Set packed 16-bit integers in <span class="desc_var dst">dst</span> with the supplied values in reverse order.</div><h1>Operation</h1><div class="operation">dst[15:0] := e7
dst[31:16] := e6
dst[47:32] := e5
dst[63:48] := e4
dst[79:64] := e3
dst[95:80] := e2
dst[111:96] := e1
dst[127:112] := e0</div></div></div><div class="intrinsic AVX" id="4981"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_setr_epi16</span> (<span class="param_type">short</span> <span class="param_name">e15</span>, <span class="param_type">short</span> <span class="param_name">e14</span>, <span class="param_type">short</span> <span class="param_name">e13</span>, <span class="param_type">short</span> <span class="param_name">e12</span>, <span class="param_type">short</span> <span class="param_name">e11</span>, <span class="param_type">short</span> <span class="param_name">e10</span>, <span class="param_type">short</span> <span class="param_name">e9</span>, <span class="param_type">short</span> <span class="param_name">e8</span>, <span class="param_type">short</span> <span class="param_name">e7</span>, <span class="param_type">short</span> <span class="param_name">e6</span>, <span class="param_type">short</span> <span class="param_name">e5</span>, <span class="param_type">short</span> <span class="param_name">e4</span>, <span class="param_type">short</span> <span class="param_name">e3</span>, <span class="param_type">short</span> <span class="param_name">e2</span>, <span class="param_type">short</span> <span class="param_name">e1</span>, <span class="param_type">short</span> <span class="param_name">e0</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_setr_epi16</span> (<span class="param_type">short</span> <span class="param_name">e15</span>, <span class="param_type">short</span> <span class="param_name">e14</span>, <span class="param_type">short</span> <span class="param_name">e13</span>, <span class="param_type">short</span> <span class="param_name">e12</span>, <span class="param_type">short</span> <span class="param_name">e11</span>, <span class="param_type">short</span> <span class="param_name">e10</span>, <span class="param_type">short</span> <span class="param_name">e9</span>, <span class="param_type">short</span> <span class="param_name">e8</span>, <span class="param_type">short</span> <span class="param_name">e7</span>, <span class="param_type">short</span> <span class="param_name">e6</span>, <span class="param_type">short</span> <span class="param_name">e5</span>, <span class="param_type">short</span> <span class="param_name">e4</span>, <span class="param_type">short</span> <span class="param_name">e3</span>, <span class="param_type">short</span> <span class="param_name">e2</span>, <span class="param_type">short</span> <span class="param_name">e1</span>, <span class="param_type">short</span> <span class="param_name">e0</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Set packed 16-bit integers in <span class="desc_var dst">dst</span> with the supplied values in reverse order.</div><h1>Operation</h1><div class="operation">dst[15:0] := e15
dst[31:16] := e14
dst[47:32] := e13
dst[63:48] := e12
dst[79:64] := e11
dst[95:80] := e10
dst[111:96] := e9
dst[127:112] := e8
dst[143:128] := e7
dst[159:144] := e6
dst[175:160] := e5
dst[191:176] := e4
dst[207:192] := e3
dst[223:208] := e2
dst[239:224] := e1
dst[255:240] := e0
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="4982"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_setr_epi32</span> (<span class="param_type">int</span> <span class="param_name">e3</span>, <span class="param_type">int</span> <span class="param_name">e2</span>, <span class="param_type">int</span> <span class="param_name">e1</span>, <span class="param_type">int</span> <span class="param_name">e0</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_setr_epi32</span> (<span class="param_type">int</span> <span class="param_name">e3</span>, <span class="param_type">int</span> <span class="param_name">e2</span>, <span class="param_type">int</span> <span class="param_name">e1</span>, <span class="param_type">int</span> <span class="param_name">e0</span>)</span><br>#include &lt;emmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Set packed 32-bit integers in <span class="desc_var dst">dst</span> with the supplied values in reverse order.</div><h1>Operation</h1><div class="operation">dst[31:0] := e3
dst[63:32] := e2
dst[95:64] := e1
dst[127:96] := e0</div></div></div><div class="intrinsic AVX" id="4983"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_setr_epi32</span> (<span class="param_type">int</span> <span class="param_name">e7</span>, <span class="param_type">int</span> <span class="param_name">e6</span>, <span class="param_type">int</span> <span class="param_name">e5</span>, <span class="param_type">int</span> <span class="param_name">e4</span>, <span class="param_type">int</span> <span class="param_name">e3</span>, <span class="param_type">int</span> <span class="param_name">e2</span>, <span class="param_type">int</span> <span class="param_name">e1</span>, <span class="param_type">int</span> <span class="param_name">e0</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_setr_epi32</span> (<span class="param_type">int</span> <span class="param_name">e7</span>, <span class="param_type">int</span> <span class="param_name">e6</span>, <span class="param_type">int</span> <span class="param_name">e5</span>, <span class="param_type">int</span> <span class="param_name">e4</span>, <span class="param_type">int</span> <span class="param_name">e3</span>, <span class="param_type">int</span> <span class="param_name">e2</span>, <span class="param_type">int</span> <span class="param_name">e1</span>, <span class="param_type">int</span> <span class="param_name">e0</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Set packed 32-bit integers in <span class="desc_var dst">dst</span> with the supplied values in reverse order.</div><h1>Operation</h1><div class="operation">dst[31:0] := e7
dst[63:32] := e6
dst[95:64] := e5
dst[127:96] := e4
dst[159:128] := e3
dst[191:160] := e2
dst[223:192] := e1
dst[255:224] := e0
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="4985"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_setr_epi64</span> (<span class="param_type">__m64</span> <span class="param_name">e1</span>, <span class="param_type">__m64</span> <span class="param_name">e0</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_setr_epi64</span> (<span class="param_type">__m64</span> <span class="param_name">e1</span>, <span class="param_type">__m64</span> <span class="param_name">e0</span>)</span><br>#include &lt;emmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Set packed 64-bit integers in <span class="desc_var dst">dst</span> with the supplied values in reverse order.</div><h1>Operation</h1><div class="operation">dst[63:0] := e1
dst[127:64] := e0</div></div></div><div class="intrinsic AVX" id="4987"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_setr_epi64x</span> (<span class="param_type">__int64</span> <span class="param_name">e3</span>, <span class="param_type">__int64</span> <span class="param_name">e2</span>, <span class="param_type">__int64</span> <span class="param_name">e1</span>, <span class="param_type">__int64</span> <span class="param_name">e0</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_setr_epi64x</span> (<span class="param_type">__int64</span> <span class="param_name">e3</span>, <span class="param_type">__int64</span> <span class="param_name">e2</span>, <span class="param_type">__int64</span> <span class="param_name">e1</span>, <span class="param_type">__int64</span> <span class="param_name">e0</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Set packed 64-bit integers in <span class="desc_var dst">dst</span> with the supplied values in reverse order.</div><h1>Operation</h1><div class="operation">dst[63:0] := e3
dst[127:64] := e2
dst[191:128] := e1
dst[255:192] := e0
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="4988"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_setr_epi8</span> (<span class="param_type">char</span> <span class="param_name">e15</span>, <span class="param_type">char</span> <span class="param_name">e14</span>, <span class="param_type">char</span> <span class="param_name">e13</span>, <span class="param_type">char</span> <span class="param_name">e12</span>, <span class="param_type">char</span> <span class="param_name">e11</span>, <span class="param_type">char</span> <span class="param_name">e10</span>, <span class="param_type">char</span> <span class="param_name">e9</span>, <span class="param_type">char</span> <span class="param_name">e8</span>, <span class="param_type">char</span> <span class="param_name">e7</span>, <span class="param_type">char</span> <span class="param_name">e6</span>, <span class="param_type">char</span> <span class="param_name">e5</span>, <span class="param_type">char</span> <span class="param_name">e4</span>, <span class="param_type">char</span> <span class="param_name">e3</span>, <span class="param_type">char</span> <span class="param_name">e2</span>, <span class="param_type">char</span> <span class="param_name">e1</span>, <span class="param_type">char</span> <span class="param_name">e0</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_setr_epi8</span> (<span class="param_type">char</span> <span class="param_name">e15</span>, <span class="param_type">char</span> <span class="param_name">e14</span>, <span class="param_type">char</span> <span class="param_name">e13</span>, <span class="param_type">char</span> <span class="param_name">e12</span>, <span class="param_type">char</span> <span class="param_name">e11</span>, <span class="param_type">char</span> <span class="param_name">e10</span>, <span class="param_type">char</span> <span class="param_name">e9</span>, <span class="param_type">char</span> <span class="param_name">e8</span>, <span class="param_type">char</span> <span class="param_name">e7</span>, <span class="param_type">char</span> <span class="param_name">e6</span>, <span class="param_type">char</span> <span class="param_name">e5</span>, <span class="param_type">char</span> <span class="param_name">e4</span>, <span class="param_type">char</span> <span class="param_name">e3</span>, <span class="param_type">char</span> <span class="param_name">e2</span>, <span class="param_type">char</span> <span class="param_name">e1</span>, <span class="param_type">char</span> <span class="param_name">e0</span>)</span><br>#include &lt;emmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Set packed 8-bit integers in <span class="desc_var dst">dst</span> with the supplied values in reverse order.</div><h1>Operation</h1><div class="operation">dst[7:0] := e15
dst[15:8] := e14
dst[23:16] := e13
dst[31:24] := e12
dst[39:32] := e11
dst[47:40] := e10
dst[55:48] := e9
dst[63:56] := e8
dst[71:64] := e7
dst[79:72] := e6
dst[87:80] := e5
dst[95:88] := e4
dst[103:96] := e3
dst[111:104] := e2
dst[119:112] := e1
dst[127:120] := e0</div></div></div><div class="intrinsic AVX" id="4989"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_setr_epi8</span> (<span class="param_type">char</span> <span class="param_name">e31</span>, <span class="param_type">char</span> <span class="param_name">e30</span>, <span class="param_type">char</span> <span class="param_name">e29</span>, <span class="param_type">char</span> <span class="param_name">e28</span>, <span class="param_type">char</span> <span class="param_name">e27</span>, <span class="param_type">char</span> <span class="param_name">e26</span>, <span class="param_type">char</span> <span class="param_name">e25</span>, <span class="param_type">char</span> <span class="param_name">e24</span>, <span class="param_type">char</span> <span class="param_name">e23</span>, <span class="param_type">char</span> <span class="param_name">e22</span>, <span class="param_type">char</span> <span class="param_name">e21</span>, <span class="param_type">char</span> <span class="param_name">e20</span>, <span class="param_type">char</span> <span class="param_name">e19</span>, <span class="param_type">char</span> <span class="param_name">e18</span>, <span class="param_type">char</span> <span class="param_name">e17</span>, <span class="param_type">char</span> <span class="param_name">e16</span>, <span class="param_type">char</span> <span class="param_name">e15</span>, <span class="param_type">char</span> <span class="param_name">e14</span>, <span class="param_type">char</span> <span class="param_name">e13</span>, <span class="param_type">char</span> <span class="param_name">e12</span>, <span class="param_type">char</span> <span class="param_name">e11</span>, <span class="param_type">char</span> <span class="param_name">e10</span>, <span class="param_type">char</span> <span class="param_name">e9</span>, <span class="param_type">char</span> <span class="param_name">e8</span>, <span class="param_type">char</span> <span class="param_name">e7</span>, <span class="param_type">char</span> <span class="param_name">e6</span>, <span class="param_type">char</span> <span class="param_name">e5</span>, <span class="param_type">char</span> <span class="param_name">e4</span>, <span class="param_type">char</span> <span class="param_name">e3</span>, <span class="param_type">char</span> <span class="param_name">e2</span>, <span class="param_type">char</span> <span class="param_name">e1</span>, <span class="param_type">char</span> <span class="param_name">e0</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_setr_epi8</span> (<span class="param_type">char</span> <span class="param_name">e31</span>, <span class="param_type">char</span> <span class="param_name">e30</span>, <span class="param_type">char</span> <span class="param_name">e29</span>, <span class="param_type">char</span> <span class="param_name">e28</span>, <span class="param_type">char</span> <span class="param_name">e27</span>, <span class="param_type">char</span> <span class="param_name">e26</span>, <span class="param_type">char</span> <span class="param_name">e25</span>, <span class="param_type">char</span> <span class="param_name">e24</span>, <span class="param_type">char</span> <span class="param_name">e23</span>, <span class="param_type">char</span> <span class="param_name">e22</span>, <span class="param_type">char</span> <span class="param_name">e21</span>, <span class="param_type">char</span> <span class="param_name">e20</span>, <span class="param_type">char</span> <span class="param_name">e19</span>, <span class="param_type">char</span> <span class="param_name">e18</span>, <span class="param_type">char</span> <span class="param_name">e17</span>, <span class="param_type">char</span> <span class="param_name">e16</span>, <span class="param_type">char</span> <span class="param_name">e15</span>, <span class="param_type">char</span> <span class="param_name">e14</span>, <span class="param_type">char</span> <span class="param_name">e13</span>, <span class="param_type">char</span> <span class="param_name">e12</span>, <span class="param_type">char</span> <span class="param_name">e11</span>, <span class="param_type">char</span> <span class="param_name">e10</span>, <span class="param_type">char</span> <span class="param_name">e9</span>, <span class="param_type">char</span> <span class="param_name">e8</span>, <span class="param_type">char</span> <span class="param_name">e7</span>, <span class="param_type">char</span> <span class="param_name">e6</span>, <span class="param_type">char</span> <span class="param_name">e5</span>, <span class="param_type">char</span> <span class="param_name">e4</span>, <span class="param_type">char</span> <span class="param_name">e3</span>, <span class="param_type">char</span> <span class="param_name">e2</span>, <span class="param_type">char</span> <span class="param_name">e1</span>, <span class="param_type">char</span> <span class="param_name">e0</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Set packed 8-bit integers in <span class="desc_var dst">dst</span> with the supplied values in reverse order.</div><h1>Operation</h1><div class="operation">dst[7:0] := e31
dst[15:8] := e30
dst[23:16] := e29
dst[31:24] := e28
dst[39:32] := e27
dst[47:40] := e26
dst[55:48] := e25
dst[63:56] := e24
dst[71:64] := e23
dst[79:72] := e22
dst[87:80] := e21
dst[95:88] := e20
dst[103:96] := e19
dst[111:104] := e18
dst[119:112] := e17
dst[127:120] := e16
dst[135:128] := e15
dst[143:136] := e14
dst[151:144] := e13
dst[159:152] := e12
dst[167:160] := e11
dst[175:168] := e10
dst[183:176] := e9
dst[191:184] := e8
dst[199:192] := e7
dst[207:200] := e6
dst[215:208] := e5
dst[223:216] := e4
dst[231:224] := e3
dst[239:232] := e2
dst[247:240] := e1
dst[255:248] := e0
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX" id="4990"><div class="instruction">vinsertf128</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_setr_m128</span> (<span class="param_type">__m128</span> <span class="param_name">lo</span>, <span class="param_type">__m128</span> <span class="param_name">hi</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_setr_m128</span> (<span class="param_type">__m128</span> <span class="param_name">lo</span>, <span class="param_type">__m128</span> <span class="param_name">hi</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vinsertf128 ymm, ymm, xmm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Set packed __m256 vector <span class="desc_var dst">dst</span> with the supplied values.</div><h1>Operation</h1><div class="operation">dst[127:0] := lo[127:0]
dst[255:128] := hi[127:0]
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>1</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="4991"><div class="instruction">vinsertf128</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_setr_m128d</span> (<span class="param_type">__m128d</span> <span class="param_name">lo</span>, <span class="param_type">__m128d</span> <span class="param_name">hi</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_setr_m128d</span> (<span class="param_type">__m128d</span> <span class="param_name">lo</span>, <span class="param_type">__m128d</span> <span class="param_name">hi</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vinsertf128 ymm, ymm, xmm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Set packed __m256d vector <span class="desc_var dst">dst</span> with the supplied values.</div><h1>Operation</h1><div class="operation">dst[127:0] := lo[127:0]
dst[255:128] := hi[127:0]
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>1</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="4992"><div class="instruction">vinsertf128</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_setr_m128i</span> (<span class="param_type">__m128i</span> <span class="param_name">lo</span>, <span class="param_type">__m128i</span> <span class="param_name">hi</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_setr_m128i</span> (<span class="param_type">__m128i</span> <span class="param_name">lo</span>, <span class="param_type">__m128i</span> <span class="param_name">hi</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vinsertf128 ymm, ymm, xmm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Set packed __m256i vector <span class="desc_var dst">dst</span> with the supplied values.</div><h1>Operation</h1><div class="operation">dst[127:0] := lo[127:0]
dst[255:128] := hi[127:0]
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>1</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="4993"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_setr_pd</span> (<span class="param_type">double</span> <span class="param_name">e1</span>, <span class="param_type">double</span> <span class="param_name">e0</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_setr_pd</span> (<span class="param_type">double</span> <span class="param_name">e1</span>, <span class="param_type">double</span> <span class="param_name">e0</span>)</span><br>#include &lt;emmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Set packed double-precision (64-bit) floating-point elements in <span class="desc_var dst">dst</span> with the supplied values in reverse order.</div><h1>Operation</h1><div class="operation">dst[63:0] := e1
dst[127:64] := e0</div></div></div><div class="intrinsic AVX" id="4994"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_setr_pd</span> (<span class="param_type">double</span> <span class="param_name">e3</span>, <span class="param_type">double</span> <span class="param_name">e2</span>, <span class="param_type">double</span> <span class="param_name">e1</span>, <span class="param_type">double</span> <span class="param_name">e0</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_setr_pd</span> (<span class="param_type">double</span> <span class="param_name">e3</span>, <span class="param_type">double</span> <span class="param_name">e2</span>, <span class="param_type">double</span> <span class="param_name">e1</span>, <span class="param_type">double</span> <span class="param_name">e0</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Set packed double-precision (64-bit) floating-point elements in <span class="desc_var dst">dst</span> with the supplied values in reverse order.</div><h1>Operation</h1><div class="operation">dst[63:0] := e3
dst[127:64] := e2
dst[191:128] := e1
dst[255:192] := e0
dst[MAX:256] := 0</div></div></div><div class="intrinsic MMX" id="4996"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_setr_pi16</span> (<span class="param_type">short</span> <span class="param_name">e3</span>, <span class="param_type">short</span> <span class="param_name">e2</span>, <span class="param_type">short</span> <span class="param_name">e1</span>, <span class="param_type">short</span> <span class="param_name">e0</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_setr_pi16</span> (<span class="param_type">short</span> <span class="param_name">e3</span>, <span class="param_type">short</span> <span class="param_name">e2</span>, <span class="param_type">short</span> <span class="param_name">e1</span>, <span class="param_type">short</span> <span class="param_name">e0</span>)</span><br>#include &lt;mmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Set packed 16-bit integers in <span class="desc_var dst">dst</span> with the supplied values in reverse order.</div><h1>Operation</h1><div class="operation">dst[15:0] := e3
dst[31:16] := e2
dst[47:32] := e1
dst[63:48] := e0</div></div></div><div class="intrinsic MMX" id="4997"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_setr_pi32</span> (<span class="param_type">int</span> <span class="param_name">e1</span>, <span class="param_type">int</span> <span class="param_name">e0</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_setr_pi32</span> (<span class="param_type">int</span> <span class="param_name">e1</span>, <span class="param_type">int</span> <span class="param_name">e0</span>)</span><br>#include &lt;mmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Set packed 32-bit integers in <span class="desc_var dst">dst</span> with the supplied values in reverse order.</div><h1>Operation</h1><div class="operation">dst[31:0] := e1
dst[63:32] := e0</div></div></div><div class="intrinsic MMX" id="4998"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_setr_pi8</span> (<span class="param_type">char</span> <span class="param_name">e7</span>, <span class="param_type">char</span> <span class="param_name">e6</span>, <span class="param_type">char</span> <span class="param_name">e5</span>, <span class="param_type">char</span> <span class="param_name">e4</span>, <span class="param_type">char</span> <span class="param_name">e3</span>, <span class="param_type">char</span> <span class="param_name">e2</span>, <span class="param_type">char</span> <span class="param_name">e1</span>, <span class="param_type">char</span> <span class="param_name">e0</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_setr_pi8</span> (<span class="param_type">char</span> <span class="param_name">e7</span>, <span class="param_type">char</span> <span class="param_name">e6</span>, <span class="param_type">char</span> <span class="param_name">e5</span>, <span class="param_type">char</span> <span class="param_name">e4</span>, <span class="param_type">char</span> <span class="param_name">e3</span>, <span class="param_type">char</span> <span class="param_name">e2</span>, <span class="param_type">char</span> <span class="param_name">e1</span>, <span class="param_type">char</span> <span class="param_name">e0</span>)</span><br>#include &lt;mmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Set packed 8-bit integers in <span class="desc_var dst">dst</span> with the supplied values in reverse order.</div><h1>Operation</h1><div class="operation">dst[7:0] := e7
dst[15:8] := e6
dst[23:16] := e5
dst[31:24] := e4
dst[39:32] := e3
dst[47:40] := e2
dst[55:48] := e1
dst[63:56] := e0</div></div></div><div class="intrinsic SSE" id="4999"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_setr_ps</span> (<span class="param_type">float</span> <span class="param_name">e3</span>, <span class="param_type">float</span> <span class="param_name">e2</span>, <span class="param_type">float</span> <span class="param_name">e1</span>, <span class="param_type">float</span> <span class="param_name">e0</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_setr_ps</span> (<span class="param_type">float</span> <span class="param_name">e3</span>, <span class="param_type">float</span> <span class="param_name">e2</span>, <span class="param_type">float</span> <span class="param_name">e1</span>, <span class="param_type">float</span> <span class="param_name">e0</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Set packed single-precision (32-bit) floating-point elements in <span class="desc_var dst">dst</span> with the supplied values in reverse order.</div><h1>Operation</h1><div class="operation">dst[31:0] := e3
dst[63:32] := e2
dst[95:64] := e1
dst[127:96] := e0</div></div></div><div class="intrinsic AVX" id="5000"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_setr_ps</span> (<span class="param_type">float</span> <span class="param_name">e7</span>, <span class="param_type">float</span> <span class="param_name">e6</span>, <span class="param_type">float</span> <span class="param_name">e5</span>, <span class="param_type">float</span> <span class="param_name">e4</span>, <span class="param_type">float</span> <span class="param_name">e3</span>, <span class="param_type">float</span> <span class="param_name">e2</span>, <span class="param_type">float</span> <span class="param_name">e1</span>, <span class="param_type">float</span> <span class="param_name">e0</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_setr_ps</span> (<span class="param_type">float</span> <span class="param_name">e7</span>, <span class="param_type">float</span> <span class="param_name">e6</span>, <span class="param_type">float</span> <span class="param_name">e5</span>, <span class="param_type">float</span> <span class="param_name">e4</span>, <span class="param_type">float</span> <span class="param_name">e3</span>, <span class="param_type">float</span> <span class="param_name">e2</span>, <span class="param_type">float</span> <span class="param_name">e1</span>, <span class="param_type">float</span> <span class="param_name">e0</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Set packed single-precision (32-bit) floating-point elements in <span class="desc_var dst">dst</span> with the supplied values in reverse order.</div><h1>Operation</h1><div class="operation">dst[31:0] := e7
dst[63:32] := e6
dst[95:64] := e5
dst[127:96] := e4
dst[159:128] := e3
dst[191:160] := e2
dst[223:192] := e1
dst[255:224] := e0
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="5009"><div class="instruction">xorpd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_setzero_pd</span> (<span class="param_type">void</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_setzero_pd</span> (<span class="param_type">void</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: xorpd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Return vector of type __m128d with all elements set to zero.</div><h1>Operation</h1><div class="operation">dst[MAX:0] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="5010"><div class="instruction">vxorpd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_setzero_pd</span> (<span class="param_type">void</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_setzero_pd</span> (<span class="param_type">void</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vxorpd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Return vector of type __m256d with all elements set to zero.</div><h1>Operation</h1><div class="operation">dst[MAX:0] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="5012"><div class="instruction">xorps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_setzero_ps</span> (<span class="param_type">void</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_setzero_ps</span> (<span class="param_type">void</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: xorps xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Return vector of type __m128 with all elements set to zero.</div><h1>Operation</h1><div class="operation">dst[MAX:0] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="5013"><div class="instruction">vxorps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_setzero_ps</span> (<span class="param_type">void</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_setzero_ps</span> (<span class="param_type">void</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vxorps ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Return vector of type __m256 with all elements set to zero.</div><h1>Operation</h1><div class="operation">dst[MAX:0] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="5015"><div class="instruction">pxor</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_setzero_si128</span> ()</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_setzero_si128</span> ()</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pxor xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Return vector of type __m128i with all elements set to zero.</div><h1>Operation</h1><div class="operation">dst[MAX:0] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.33</td></tr><tr><td>Haswell</td><td>1</td><td>0.33</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.33</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="5016"><div class="instruction">vpxor</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_setzero_si256</span> (<span class="param_type">void</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_setzero_si256</span> (<span class="param_type">void</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpxor ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Return vector of type __m256i with all elements set to zero.</div><h1>Operation</h1><div class="operation">dst[MAX:0] := 0</div></div></div><div class="intrinsic MMX" id="5018"><div class="instruction">pxor</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_setzero_si64</span> (<span class="param_type">void</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_setzero_si64</span> (<span class="param_type">void</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: pxor mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Return vector of type __m64 with all elements set to zero.</div><h1>Operation</h1><div class="operation">dst[MAX:0] := 0</div></div></div><div class="intrinsic SSE" id="5019"><div class="instruction">sfence</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_sfence</span> (<span class="param_type">void</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_sfence</span> (<span class="param_type">void</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: sfence<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Perform a serializing operation on all store-to-memory instructions that were issued prior to this instruction. Guarantees that every store instruction that precedes, in program order, is globally visible before any store instruction which follows the fence in program order.</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>-</td><td>7</td></tr><tr><td>Broadwell</td><td>-</td><td>6</td></tr><tr><td>Haswell</td><td>-</td><td>6</td></tr><tr><td>Ivy Bridge</td><td>-</td><td>5</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="5137"><div class="instruction">pshufd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_shuffle_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_shuffle_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pshufd xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Shuffle 32-bit integers in <span class="desc_var a">a</span> using the control in <span class="desc_var imm8">imm8</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">DEFINE SELECT4(src, control) {
	CASE(control[1:0]) OF
	0:	tmp[31:0] := src[31:0]
	1:	tmp[31:0] := src[63:32]
	2:	tmp[31:0] := src[95:64]
	3:	tmp[31:0] := src[127:96]
	ESAC
	RETURN tmp[31:0]
}
dst[31:0] := SELECT4(a[127:0], imm8[1:0])
dst[63:32] := SELECT4(a[127:0], imm8[3:2])
dst[95:64] := SELECT4(a[127:0], imm8[5:4])
dst[127:96] := SELECT4(a[127:0], imm8[7:6])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5140"><div class="instruction">vpshufd</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_shuffle_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_shuffle_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpshufd ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shuffle 32-bit integers in <span class="desc_var a">a</span> within 128-bit lanes using the control in <span class="desc_var imm8">imm8</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">DEFINE SELECT4(src, control) {
	CASE(control[1:0]) OF
	0:	tmp[31:0] := src[31:0]
	1:	tmp[31:0] := src[63:32]
	2:	tmp[31:0] := src[95:64]
	3:	tmp[31:0] := src[127:96]
	ESAC
	RETURN tmp[31:0]
}
dst[31:0] := SELECT4(a[127:0], imm8[1:0])
dst[63:32] := SELECT4(a[127:0], imm8[3:2])
dst[95:64] := SELECT4(a[127:0], imm8[5:4])
dst[127:96] := SELECT4(a[127:0], imm8[7:6])
dst[159:128] := SELECT4(a[255:128], imm8[1:0])
dst[191:160] := SELECT4(a[255:128], imm8[3:2])
dst[223:192] := SELECT4(a[255:128], imm8[5:4])
dst[255:224] := SELECT4(a[255:128], imm8[7:6])
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSSE3" id="5146"><div class="instruction">pshufb</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_shuffle_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_shuffle_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: pshufb mm, mm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Shuffle packed 8-bit integers in <span class="desc_var a">a</span> according to shuffle control mask in the corresponding 8-bit element of <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*8
	IF b[i+7] == 1
		dst[i+7:i] := 0
	ELSE
		index[3:0] := b[i+3:i]
		dst[i+7:i] := a[index*8+7:index*8]
	FI
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5149"><div class="instruction">vpshufb</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_shuffle_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_shuffle_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpshufb ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shuffle 8-bit integers in <span class="desc_var a">a</span> within 128-bit lanes according to shuffle control mask in the corresponding 8-bit element of <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*8
	IF b[i+7] == 1
		dst[i+7:i] := 0
	ELSE
		index[3:0] := b[i+3:i]
		dst[i+7:i] := a[index*8+7:index*8]
	FI
	IF b[128+i+7] == 1
		dst[128+i+7:128+i] := 0
	ELSE
		index[3:0] := b[128+i+3:128+i]
		dst[128+i+7:128+i] := a[128+index*8+7:128+index*8]
	FI
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="5179"><div class="instruction">shufpd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_shuffle_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_shuffle_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: shufpd xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Shuffle double-precision (64-bit) floating-point elements using the control in <span class="desc_var imm8">imm8</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">dst[63:0] := (imm8[0] == 0) ? a[63:0] : a[127:64]
dst[127:64] := (imm8[1] == 0) ? b[63:0] : b[127:64]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="5182"><div class="instruction">vshufpd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_shuffle_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_shuffle_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vshufpd ymm, ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Shuffle double-precision (64-bit) floating-point elements within 128-bit lanes using the control in <span class="desc_var imm8">imm8</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">dst[63:0] := (imm8[0] == 0) ? a[63:0] : a[127:64]
dst[127:64] := (imm8[1] == 0) ? b[63:0] : b[127:64]
dst[191:128] := (imm8[2] == 0) ? a[191:128] : a[255:192]
dst[255:192] := (imm8[3] == 0) ? b[191:128] : b[255:192]
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="5186"><div class="instruction">pshufw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_shuffle_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_shuffle_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: pshufw mm, mm, imm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Shuffle 16-bit integers in <span class="desc_var a">a</span> using the control in <span class="desc_var imm8">imm8</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">DEFINE SELECT4(src, control) {
	CASE(control[1:0]) OF
	0:	tmp[15:0] := src[15:0]
	1:	tmp[15:0] := src[31:16]
	2:	tmp[15:0] := src[47:32]
	3:	tmp[15:0] := src[63:48]
	ESAC
	RETURN tmp[15:0]
}
dst[15:0] := SELECT4(a[63:0], imm8[1:0])
dst[31:16] := SELECT4(a[63:0], imm8[3:2])
dst[47:32] := SELECT4(a[63:0], imm8[5:4])
dst[63:48] := SELECT4(a[63:0], imm8[7:6])</div></div></div><div class="intrinsic SSSE3" id="5187"><div class="instruction">pshufb</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_shuffle_pi8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_shuffle_pi8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: pshufb mm, mm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Shuffle packed 8-bit integers in <span class="desc_var a">a</span> according to shuffle control mask in the corresponding 8-bit element of <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	IF b[i+7] == 1
		dst[i+7:i] := 0
	ELSE
		index[2:0] := b[i+2:i]
		dst[i+7:i] := a[index*8+7:index*8]
	FI
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="5190"><div class="instruction">shufps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_shuffle_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">unsigned int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_shuffle_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">unsigned int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: shufps xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Shuffle single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> using the control in <span class="desc_var imm8">imm8</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">DEFINE SELECT4(src, control) {
	CASE(control[1:0]) OF
	0:	tmp[31:0] := src[31:0]
	1:	tmp[31:0] := src[63:32]
	2:	tmp[31:0] := src[95:64]
	3:	tmp[31:0] := src[127:96]
	ESAC
	RETURN tmp[31:0]
}
dst[31:0] := SELECT4(a[127:0], imm8[1:0])
dst[63:32] := SELECT4(a[127:0], imm8[3:2])
dst[95:64] := SELECT4(b[127:0], imm8[5:4])
dst[127:96] := SELECT4(b[127:0], imm8[7:6])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="5193"><div class="instruction">vshufps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_shuffle_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_shuffle_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vshufps ymm, ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Shuffle single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> within 128-bit lanes using the control in <span class="desc_var imm8">imm8</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">DEFINE SELECT4(src, control) {
	CASE(control[1:0]) OF
	0:	tmp[31:0] := src[31:0]
	1:	tmp[31:0] := src[63:32]
	2:	tmp[31:0] := src[95:64]
	3:	tmp[31:0] := src[127:96]
	ESAC
	RETURN tmp[31:0]
}
dst[31:0] := SELECT4(a[127:0], imm8[1:0])
dst[63:32] := SELECT4(a[127:0], imm8[3:2])
dst[95:64] := SELECT4(b[127:0], imm8[5:4])
dst[127:96] := SELECT4(b[127:0], imm8[7:6])
dst[159:128] := SELECT4(a[255:128], imm8[1:0])
dst[191:160] := SELECT4(a[255:128], imm8[3:2])
dst[223:192] := SELECT4(b[255:128], imm8[5:4])
dst[255:224] := SELECT4(b[255:128], imm8[7:6])
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="5199"><div class="instruction">pshufhw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_shufflehi_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_shufflehi_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pshufhw xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Shuffle 16-bit integers in the high 64 bits of <span class="desc_var a">a</span> using the control in <span class="desc_var imm8">imm8</span>. Store the results in the high 64 bits of <span class="desc_var dst">dst</span>, with the low 64 bits being copied from from <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := a[63:0]
dst[79:64] := (a &gt;&gt; (imm8[1:0] * 16))[79:64]
dst[95:80] := (a &gt;&gt; (imm8[3:2] * 16))[79:64]
dst[111:96] := (a &gt;&gt; (imm8[5:4] * 16))[79:64]
dst[127:112] := (a &gt;&gt; (imm8[7:6] * 16))[79:64]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5202"><div class="instruction">vpshufhw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_shufflehi_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_shufflehi_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpshufhw ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shuffle 16-bit integers in the high 64 bits of 128-bit lanes of <span class="desc_var a">a</span> using the control in <span class="desc_var imm8">imm8</span>. Store the results in the high 64 bits of 128-bit lanes of <span class="desc_var dst">dst</span>, with the low 64 bits of 128-bit lanes being copied from from <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := a[63:0]
dst[79:64] := (a &gt;&gt; (imm8[1:0] * 16))[79:64]
dst[95:80] := (a &gt;&gt; (imm8[3:2] * 16))[79:64]
dst[111:96] := (a &gt;&gt; (imm8[5:4] * 16))[79:64]
dst[127:112] := (a &gt;&gt; (imm8[7:6] * 16))[79:64]
dst[191:128] := a[191:128]
dst[207:192] := (a &gt;&gt; (imm8[1:0] * 16))[207:192]
dst[223:208] := (a &gt;&gt; (imm8[3:2] * 16))[207:192]
dst[239:224] := (a &gt;&gt; (imm8[5:4] * 16))[207:192]
dst[255:240] := (a &gt;&gt; (imm8[7:6] * 16))[207:192]
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="5208"><div class="instruction">pshuflw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_shufflelo_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_shufflelo_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pshuflw xmm, xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Shuffle 16-bit integers in the low 64 bits of <span class="desc_var a">a</span> using the control in <span class="desc_var imm8">imm8</span>. Store the results in the low 64 bits of <span class="desc_var dst">dst</span>, with the high 64 bits being copied from from <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[15:0] := (a &gt;&gt; (imm8[1:0] * 16))[15:0]
dst[31:16] := (a &gt;&gt; (imm8[3:2] * 16))[15:0]
dst[47:32] := (a &gt;&gt; (imm8[5:4] * 16))[15:0]
dst[63:48] := (a &gt;&gt; (imm8[7:6] * 16))[15:0]
dst[127:64] := a[127:64]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5211"><div class="instruction">vpshuflw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_shufflelo_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_shufflelo_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpshuflw ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shuffle 16-bit integers in the low 64 bits of 128-bit lanes of <span class="desc_var a">a</span> using the control in <span class="desc_var imm8">imm8</span>. Store the results in the low 64 bits of 128-bit lanes of <span class="desc_var dst">dst</span>, with the high 64 bits of 128-bit lanes being copied from from <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[15:0] := (a &gt;&gt; (imm8[1:0] * 16))[15:0]
dst[31:16] := (a &gt;&gt; (imm8[3:2] * 16))[15:0]
dst[47:32] := (a &gt;&gt; (imm8[5:4] * 16))[15:0]
dst[63:48] := (a &gt;&gt; (imm8[7:6] * 16))[15:0]
dst[127:64] := a[127:64]
dst[143:128] := (a &gt;&gt; (imm8[1:0] * 16))[143:128]
dst[159:144] := (a &gt;&gt; (imm8[3:2] * 16))[143:128]
dst[175:160] := (a &gt;&gt; (imm8[5:4] * 16))[143:128]
dst[191:176] := (a &gt;&gt; (imm8[7:6] * 16))[143:128]
dst[255:192] := a[255:192]
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSSE3" id="5215"><div class="instruction">psignw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_sign_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_sign_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: psignw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Negate packed 16-bit integers in <span class="desc_var a">a</span> when the corresponding signed 16-bit integer in <span class="desc_var b">b</span> is negative, and store the results in <span class="desc_var dst">dst</span>. Element in <span class="desc_var dst">dst</span> are zeroed out when the corresponding element in <span class="desc_var b">b</span> is zero.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	IF b[i+15:i] &lt; 0
		dst[i+15:i] := -(a[i+15:i])
	ELSE IF b[i+15:i] == 0
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := a[i+15:i]
	FI
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5216"><div class="instruction">vpsignw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_sign_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_sign_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsignw ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Negate packed 16-bit integers in <span class="desc_var a">a</span> when the corresponding signed 16-bit integer in <span class="desc_var b">b</span> is negative, and store the results in <span class="desc_var dst">dst</span>. Element in <span class="desc_var dst">dst</span> are zeroed out when the corresponding element in <span class="desc_var b">b</span> is zero.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	IF b[i+15:i] &lt; 0
		dst[i+15:i] := -(a[i+15:i])
	ELSE IF b[i+15:i] == 0
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := a[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSSE3" id="5217"><div class="instruction">psignd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_sign_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_sign_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: psignd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Negate packed 32-bit integers in <span class="desc_var a">a</span> when the corresponding signed 32-bit integer in <span class="desc_var b">b</span> is negative, and store the results in <span class="desc_var dst">dst</span>. Element in <span class="desc_var dst">dst</span> are zeroed out when the corresponding element in <span class="desc_var b">b</span> is zero.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	IF b[i+31:i] &lt; 0
		dst[i+31:i] := -(a[i+31:i])
	ELSE IF b[i+31:i] == 0
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5218"><div class="instruction">vpsignd</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_sign_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_sign_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsignd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Negate packed 32-bit integers in <span class="desc_var a">a</span> when the corresponding signed 32-bit integer in <span class="desc_var b">b</span> is negative, and store the results in <span class="desc_var dst">dst</span>. Element in <span class="desc_var dst">dst</span> are zeroed out when the corresponding element in <span class="desc_var b">b</span> is zero.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	IF b[i+31:i] &lt; 0
		dst[i+31:i] := -(a[i+31:i])
	ELSE IF b[i+31:i] == 0
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSSE3" id="5219"><div class="instruction">psignb</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_sign_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_sign_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: psignb xmm, xmm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Negate packed 8-bit integers in <span class="desc_var a">a</span> when the corresponding signed 8-bit integer in <span class="desc_var b">b</span> is negative, and store the results in <span class="desc_var dst">dst</span>. Element in <span class="desc_var dst">dst</span> are zeroed out when the corresponding element in <span class="desc_var b">b</span> is zero.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*8
	IF b[i+7:i] &lt; 0
		dst[i+7:i] := -(a[i+7:i])
	ELSE IF b[i+7:i] == 0
		dst[i+7:i] := 0
	ELSE
		dst[i+7:i] := a[i+7:i]
	FI
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5220"><div class="instruction">vpsignb</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_sign_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_sign_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsignb ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Negate packed 8-bit integers in <span class="desc_var a">a</span> when the corresponding signed 8-bit integer in <span class="desc_var b">b</span> is negative, and store the results in <span class="desc_var dst">dst</span>. Element in <span class="desc_var dst">dst</span> are zeroed out when the corresponding element in <span class="desc_var b">b</span> is zero.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*8
	IF b[i+7:i] &lt; 0
		dst[i+7:i] := -(a[i+7:i])
	ELSE IF b[i+7:i] == 0
		dst[i+7:i] := 0
	ELSE
		dst[i+7:i] := a[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSSE3" id="5221"><div class="instruction">psignw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_sign_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_sign_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: psignw mm, mm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Negate packed 16-bit integers in <span class="desc_var a">a</span> when the corresponding signed 16-bit integer in <span class="desc_var b">b</span> is negative, and store the results in <span class="desc_var dst">dst</span>. Element in <span class="desc_var dst">dst</span> are zeroed out when the corresponding element in <span class="desc_var b">b</span> is zero.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	IF b[i+15:i] &lt; 0
		dst[i+15:i] := -(a[i+15:i])
	ELSE IF b[i+15:i] == 0
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := a[i+15:i]
	FI
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSSE3" id="5222"><div class="instruction">psignd</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_sign_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_sign_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: psignd mm, mm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Negate packed 32-bit integers in <span class="desc_var a">a</span> when the corresponding signed 32-bit integer in <span class="desc_var b">b</span> is negative, and store the results in <span class="desc_var dst">dst</span>. Element in <span class="desc_var dst">dst</span> are zeroed out when the corresponding element in <span class="desc_var b">b</span> is zero.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*32
	IF b[i+31:i] &lt; 0
		dst[i+31:i] := -(a[i+31:i])
	ELSE IF b[i+31:i] == 0
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSSE3" id="5223"><div class="instruction">psignb</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_sign_pi8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_sign_pi8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: psignb mm, mm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Negate packed 8-bit integers in <span class="desc_var a">a</span> when the corresponding signed 8-bit integer in <span class="desc_var b">b</span> is negative, and store the results in <span class="desc_var dst">dst</span>. Element in <span class="desc_var dst">dst</span> are zeroed out when the corresponding element in <span class="desc_var b">b</span> is zero.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	IF b[i+7:i] &lt; 0
		dst[i+7:i] := -(a[i+7:i])
	ELSE IF b[i+7:i] == 0
		dst[i+7:i] := 0
	ELSE
		dst[i+7:i] := a[i+7:i]
	FI
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="5258"><div class="instruction">psllw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_sll_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_sll_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: psllw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Shift packed 16-bit integers in <span class="desc_var a">a</span> left by <span class="desc_var count">count</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend(a[i+15:i] &lt;&lt; count[63:0])
	FI
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5261"><div class="instruction">vpsllw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_sll_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_sll_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsllw ymm, ymm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shift packed 16-bit integers in <span class="desc_var a">a</span> left by <span class="desc_var count">count</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend(a[i+15:i] &lt;&lt; count[63:0])
	FI
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>1</td></tr><tr><td>Broadwell</td><td>4</td><td>1</td></tr><tr><td>Haswell</td><td>4</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="5267"><div class="instruction">pslld</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_sll_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_sll_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pslld xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Shift packed 32-bit integers in <span class="desc_var a">a</span> left by <span class="desc_var count">count</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend(a[i+31:i] &lt;&lt; count[63:0])
	FI
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5270"><div class="instruction">vpslld</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_sll_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_sll_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpslld ymm, ymm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shift packed 32-bit integers in <span class="desc_var a">a</span> left by <span class="desc_var count">count</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend(a[i+31:i] &lt;&lt; count[63:0])
	FI
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>1</td></tr><tr><td>Broadwell</td><td>4</td><td>1</td></tr><tr><td>Haswell</td><td>4</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="5276"><div class="instruction">psllq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_sll_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_sll_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: psllq xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Shift packed 64-bit integers in <span class="desc_var a">a</span> left by <span class="desc_var count">count</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	IF count[63:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend(a[i+63:i] &lt;&lt; count[63:0])
	FI
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5279"><div class="instruction">vpsllq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_sll_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_sll_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsllq ymm, ymm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shift packed 64-bit integers in <span class="desc_var a">a</span> left by <span class="desc_var count">count</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	IF count[63:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend(a[i+63:i] &lt;&lt; count[63:0])
	FI
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>1</td></tr><tr><td>Broadwell</td><td>4</td><td>1</td></tr><tr><td>Haswell</td><td>4</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic MMX" id="5283"><div class="instruction">psllw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_sll_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_sll_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">count</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psllw mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Shift packed 16-bit integers in <span class="desc_var a">a</span> left by <span class="desc_var count">count</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend(a[i+15:i] &lt;&lt; count[63:0])
	FI
ENDFOR</div></div></div><div class="intrinsic MMX" id="5284"><div class="instruction">pslld</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_sll_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_sll_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">count</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: pslld mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Shift packed 32-bit integers in <span class="desc_var a">a</span> left by <span class="desc_var count">count</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend(a[i+31:i] &lt;&lt; count[63:0])
	FI
ENDFOR</div></div></div><div class="intrinsic MMX" id="5285"><div class="instruction">psllq</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_sll_si64</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_sll_si64</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">count</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psllq mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Shift 64-bit integer <span class="desc_var a">a</span> left by <span class="desc_var count">count</span> while shifting in zeros, and store the result in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">IF count[63:0] &gt; 63
	dst[63:0] := 0
ELSE
	dst[63:0] := ZeroExtend(a[63:0] &lt;&lt; count[63:0])
FI</div></div></div><div class="intrinsic SSE2" id="5288"><div class="instruction">psllw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_slli_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_slli_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: psllw xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Shift packed 16-bit integers in <span class="desc_var a">a</span> left by <span class="desc_var imm8">imm8</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend(a[i+15:i] &lt;&lt; imm8[7:0])
	FI
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5291"><div class="instruction">vpsllw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_slli_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_slli_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsllw ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shift packed 16-bit integers in <span class="desc_var a">a</span> left by <span class="desc_var imm8">imm8</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend(a[i+15:i] &lt;&lt; imm8[7:0])
	FI
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="5297"><div class="instruction">pslld</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_slli_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_slli_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pslld xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Shift packed 32-bit integers in <span class="desc_var a">a</span> left by <span class="desc_var imm8">imm8</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend(a[i+31:i] &lt;&lt; imm8[7:0])
	FI
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5300"><div class="instruction">vpslld</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_slli_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_slli_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpslld ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shift packed 32-bit integers in <span class="desc_var a">a</span> left by <span class="desc_var imm8">imm8</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend(a[i+31:i] &lt;&lt; imm8[7:0])
	FI
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="5306"><div class="instruction">psllq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_slli_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_slli_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: psllq xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Shift packed 64-bit integers in <span class="desc_var a">a</span> left by <span class="desc_var imm8">imm8</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	IF imm8[7:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend(a[i+63:i] &lt;&lt; imm8[7:0])
	FI
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5309"><div class="instruction">vpsllq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_slli_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_slli_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsllq ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shift packed 64-bit integers in <span class="desc_var a">a</span> left by <span class="desc_var imm8">imm8</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	IF imm8[7:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend(a[i+63:i] &lt;&lt; imm8[7:0])
	FI
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic MMX" id="5313"><div class="instruction">psllw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_slli_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_slli_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psllw mm, imm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Shift packed 16-bit integers in <span class="desc_var a">a</span> left by <span class="desc_var imm8">imm8</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend(a[i+15:i] &lt;&lt; imm8[7:0])
	FI
ENDFOR</div></div></div><div class="intrinsic MMX" id="5314"><div class="instruction">pslld</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_slli_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_slli_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: pslld mm, imm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Shift packed 32-bit integers in <span class="desc_var a">a</span> left by <span class="desc_var imm8">imm8</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend(a[i+31:i] &lt;&lt; imm8[7:0])
	FI
ENDFOR</div></div></div><div class="intrinsic SSE2" id="5315"><div class="instruction">pslldq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_slli_si128</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_slli_si128</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pslldq xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Shift <span class="desc_var a">a</span> left by <span class="desc_var imm8">imm8</span> bytes while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">tmp := imm8[7:0]
IF tmp &gt; 15
	tmp := 16
FI
dst[127:0] := a[127:0] &lt;&lt; (tmp*8)</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5316"><div class="instruction">vpslldq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_slli_si256</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_slli_si256</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpslldq ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shift 128-bit lanes in <span class="desc_var a">a</span> left by <span class="desc_var imm8">imm8</span> bytes while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">tmp := imm8[7:0]
IF tmp &gt; 15
	tmp := 16
FI
dst[127:0] := a[127:0] &lt;&lt; (tmp*8)
dst[255:128] := a[255:128] &lt;&lt; (tmp*8)
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic MMX" id="5317"><div class="instruction">psllq</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_slli_si64</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_slli_si64</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psllq mm, imm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Shift 64-bit integer <span class="desc_var a">a</span> left by <span class="desc_var imm8">imm8</span> while shifting in zeros, and store the result in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">IF imm8[7:0] &gt; 63
	dst[63:0] := 0
ELSE
	dst[63:0] := ZeroExtend(a[63:0] &lt;&lt; imm8[7:0])
FI</div></div></div><div class="intrinsic AVX2" id="5329"><div class="instruction">vpsllvd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_sllv_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_sllv_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsllvd xmm, xmm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shift packed 32-bit integers in <span class="desc_var a">a</span> left by the amount specified by the corresponding element in <span class="desc_var count">count</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := ZeroExtend(a[i+31:i] &lt;&lt; count[i+31:i])
ENDFOR
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>0.5</td></tr><tr><td>Broadwell</td><td>2</td><td>2</td></tr><tr><td>Haswell</td><td>2</td><td>2</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5332"><div class="instruction">vpsllvd</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_sllv_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_sllv_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">count</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsllvd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shift packed 32-bit integers in <span class="desc_var a">a</span> left by the amount specified by the corresponding element in <span class="desc_var count">count</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := ZeroExtend(a[i+31:i] &lt;&lt; count[i+31:i])
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>0.5</td></tr><tr><td>Broadwell</td><td>2</td><td>2</td></tr><tr><td>Haswell</td><td>2</td><td>2</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5338"><div class="instruction">vpsllvq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_sllv_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_sllv_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsllvq xmm, xmm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shift packed 64-bit integers in <span class="desc_var a">a</span> left by the amount specified by the corresponding element in <span class="desc_var count">count</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := ZeroExtend(a[i+63:i] &lt;&lt; count[i+63:i])
ENDFOR
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>0.5</td></tr><tr><td>Broadwell</td><td>2</td><td>2</td></tr><tr><td>Haswell</td><td>2</td><td>2</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5341"><div class="instruction">vpsllvq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_sllv_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_sllv_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">count</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsllvq ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shift packed 64-bit integers in <span class="desc_var a">a</span> left by the amount specified by the corresponding element in <span class="desc_var count">count</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := ZeroExtend(a[i+63:i] &lt;&lt; count[i+63:i])
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>0.5</td></tr><tr><td>Broadwell</td><td>2</td><td>2</td></tr><tr><td>Haswell</td><td>2</td><td>2</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="5349"><div class="instruction">sqrtpd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_sqrt_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_sqrt_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: sqrtpd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compute the square root of packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := SQRT(a[i+63:i])
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>38</td><td>~10</td></tr><tr><td>Skylake</td><td>18</td><td>6</td></tr><tr><td>Broadwell</td><td>20</td><td>13</td></tr><tr><td>Haswell</td><td>20</td><td>13</td></tr><tr><td>Ivy Bridge</td><td>21</td><td>14</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="5352"><div class="instruction">vsqrtpd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_sqrt_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_sqrt_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vsqrtpd ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compute the square root of packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := SQRT(a[i+63:i])
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>38</td><td>~10</td></tr><tr><td>Skylake</td><td>&lt;18</td><td>&lt;12</td></tr><tr><td>Broadwell</td><td>19-35</td><td>16-27</td></tr><tr><td>Haswell</td><td>19-35</td><td>16-27</td></tr><tr><td>Ivy Bridge</td><td>19-35</td><td>28</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="5358"><div class="instruction">sqrtps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_sqrt_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_sqrt_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: sqrtps xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compute the square root of packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := SQRT(a[i+31:i])
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>38</td><td>~10</td></tr><tr><td>Skylake</td><td>13</td><td>3</td></tr><tr><td>Broadwell</td><td>13</td><td>7</td></tr><tr><td>Haswell</td><td>13</td><td>7</td></tr><tr><td>Ivy Bridge</td><td>14</td><td>7</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="5361"><div class="instruction">vsqrtps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_sqrt_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_sqrt_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vsqrtps ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compute the square root of packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := SQRT(a[i+31:i])
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>38</td><td>~10</td></tr><tr><td>Skylake</td><td>12</td><td>&lt;6</td></tr><tr><td>Broadwell</td><td>18-21</td><td>13</td></tr><tr><td>Haswell</td><td>18-21</td><td>13</td></tr><tr><td>Ivy Bridge</td><td>18-21</td><td>14</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="5379"><div class="instruction">sqrtsd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_sqrt_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_sqrt_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: sqrtsd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compute the square root of the lower double-precision (64-bit) floating-point element in <span class="desc_var b">b</span>, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := SQRT(b[63:0])
dst[127:64] := a[127:64]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>40</td><td>~33</td></tr><tr><td>Skylake</td><td>18</td><td>6</td></tr><tr><td>Broadwell</td><td>20</td><td>7</td></tr><tr><td>Haswell</td><td>20</td><td>13</td></tr><tr><td>Ivy Bridge</td><td>21</td><td>14</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="5382"><div class="instruction">sqrtss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_sqrt_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_sqrt_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: sqrtss xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compute the square root of the lower single-precision (32-bit) floating-point element in <span class="desc_var a">a</span>, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := SQRT(a[31:0])
dst[127:32] := a[127:32]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Knights Landing</td><td>25</td><td>~20</td></tr><tr><td>Skylake</td><td>13</td><td>3</td></tr><tr><td>Broadwell</td><td>13</td><td>4</td></tr><tr><td>Haswell</td><td>13</td><td>7</td></tr><tr><td>Ivy Bridge</td><td>14</td><td>7</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="5385"><div class="instruction">psraw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_sra_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_sra_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: psraw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Shift packed 16-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var count">count</span> while shifting in sign bits, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := SignBit
	ELSE
		dst[i+15:i] := SignExtend(a[i+15:i] &gt;&gt; count[63:0])
	FI
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5388"><div class="instruction">vpsraw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_sra_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_sra_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsraw ymm, ymm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shift packed 16-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var count">count</span> while shifting in sign bits, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := SignBit
	ELSE
		dst[i+15:i] := SignExtend(a[i+15:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="5394"><div class="instruction">psrad</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_sra_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_sra_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: psrad xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Shift packed 32-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var count">count</span> while shifting in sign bits, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := SignBit
	ELSE
		dst[i+31:i] := SignExtend(a[i+31:i] &gt;&gt; count[63:0])
	FI
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5397"><div class="instruction">vpsrad</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_sra_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_sra_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsrad ymm, ymm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shift packed 32-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var count">count</span> while shifting in sign bits, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := SignBit
	ELSE
		dst[i+31:i] := SignExtend(a[i+31:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic MMX" id="5410"><div class="instruction">psraw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_sra_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_sra_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">count</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psraw mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Shift packed 16-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var count">count</span> while shifting in sign bits, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := SignBit
	ELSE
		dst[i+15:i] := SignExtend(a[i+15:i] &gt;&gt; count[63:0])
	FI
ENDFOR</div></div></div><div class="intrinsic MMX" id="5411"><div class="instruction">psrad</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_sra_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_sra_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">count</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psrad mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Shift packed 32-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var count">count</span> while shifting in sign bits, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := SignBit
	ELSE
		dst[i+31:i] := SignExtend(a[i+31:i] &gt;&gt; count[63:0])
	FI
ENDFOR</div></div></div><div class="intrinsic SSE2" id="5414"><div class="instruction">psraw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_srai_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_srai_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: psraw xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Shift packed 16-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var imm8">imm8</span> while shifting in sign bits, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := SignBit
	ELSE
		dst[i+15:i] := SignExtend(a[i+15:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5417"><div class="instruction">vpsraw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_srai_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_srai_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsraw ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shift packed 16-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var imm8">imm8</span> while shifting in sign bits, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := SignBit
	ELSE
		dst[i+15:i] := SignExtend(a[i+15:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="5423"><div class="instruction">psrad</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_srai_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_srai_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: psrad xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Shift packed 32-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var imm8">imm8</span> while shifting in sign bits, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := SignBit
	ELSE
		dst[i+31:i] := SignExtend(a[i+31:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5426"><div class="instruction">vpsrad</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_srai_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_srai_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsrad ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shift packed 32-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var imm8">imm8</span> while shifting in sign bits, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := SignBit
	ELSE
		dst[i+31:i] := SignExtend(a[i+31:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic MMX" id="5439"><div class="instruction">psraw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_srai_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_srai_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psraw mm, imm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Shift packed 16-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var imm8">imm8</span> while shifting in sign bits, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := SignBit
	ELSE
		dst[i+15:i] := SignExtend(a[i+15:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR</div></div></div><div class="intrinsic MMX" id="5440"><div class="instruction">psrad</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_srai_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_srai_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psrad mm, imm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Shift packed 32-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var imm8">imm8</span> while shifting in sign bits, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := SignBit
	ELSE
		dst[i+31:i] := SignExtend(a[i+31:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR</div></div></div><div class="intrinsic AVX2" id="5452"><div class="instruction">vpsravd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_srav_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_srav_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsravd xmm, xmm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shift packed 32-bit integers in <span class="desc_var a">a</span> right by the amount specified by the corresponding element in <span class="desc_var count">count</span> while shifting in sign bits, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := SignExtend(a[i+31:i] &gt;&gt; count[i+31:i])
ENDFOR
dst[MAX:128] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>0.5</td></tr><tr><td>Broadwell</td><td>2</td><td>2</td></tr><tr><td>Haswell</td><td>2</td><td>2</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5455"><div class="instruction">vpsravd</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_srav_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_srav_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">count</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsravd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shift packed 32-bit integers in <span class="desc_var a">a</span> right by the amount specified by the corresponding element in <span class="desc_var count">count</span> while shifting in sign bits, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := SignExtend(a[i+31:i] &gt;&gt; count[i+31:i])
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>0.5</td></tr><tr><td>Broadwell</td><td>2</td><td>2</td></tr><tr><td>Haswell</td><td>2</td><td>2</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="5470"><div class="instruction">psrlw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_srl_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_srl_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: psrlw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Shift packed 16-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var count">count</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend(a[i+15:i] &gt;&gt; count[63:0])
	FI
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5473"><div class="instruction">vpsrlw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_srl_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_srl_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsrlw ymm, ymm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shift packed 16-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var count">count</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend(a[i+15:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="5479"><div class="instruction">psrld</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_srl_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_srl_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: psrld xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Shift packed 32-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var count">count</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend(a[i+31:i] &gt;&gt; count[63:0])
	FI
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5482"><div class="instruction">vpsrld</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_srl_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_srl_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsrld ymm, ymm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shift packed 32-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var count">count</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend(a[i+31:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="5488"><div class="instruction">psrlq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_srl_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_srl_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: psrlq xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Shift packed 64-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var count">count</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	IF count[63:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend(a[i+63:i] &gt;&gt; count[63:0])
	FI
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5491"><div class="instruction">vpsrlq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_srl_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_srl_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsrlq ymm, ymm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shift packed 64-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var count">count</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	IF count[63:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend(a[i+63:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic MMX" id="5495"><div class="instruction">psrlw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_srl_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_srl_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">count</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psrlw mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Shift packed 16-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var count">count</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend(a[i+15:i] &gt;&gt; count[63:0])
	FI
ENDFOR</div></div></div><div class="intrinsic MMX" id="5496"><div class="instruction">psrld</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_srl_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_srl_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">count</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psrld mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Shift packed 32-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var count">count</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend(a[i+31:i] &gt;&gt; count[63:0])
	FI
ENDFOR</div></div></div><div class="intrinsic MMX" id="5497"><div class="instruction">psrlq</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_srl_si64</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_srl_si64</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">count</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psrlq mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Shift 64-bit integer <span class="desc_var a">a</span> right by <span class="desc_var count">count</span> while shifting in zeros, and store the result in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">IF count[63:0] &gt; 63
	dst[63:0] := 0
ELSE
	dst[63:0] := ZeroExtend(a[63:0] &gt;&gt; count[63:0])
FI</div></div></div><div class="intrinsic SSE2" id="5500"><div class="instruction">psrlw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_srli_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_srli_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: psrlw xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Shift packed 16-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var imm8">imm8</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend(a[i+15:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5503"><div class="instruction">vpsrlw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_srli_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_srli_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsrlw ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shift packed 16-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var imm8">imm8</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend(a[i+15:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="5509"><div class="instruction">psrld</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_srli_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_srli_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: psrld xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Shift packed 32-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var imm8">imm8</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend(a[i+31:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5512"><div class="instruction">vpsrld</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_srli_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_srli_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsrld ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shift packed 32-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var imm8">imm8</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend(a[i+31:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="5518"><div class="instruction">psrlq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_srli_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_srli_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: psrlq xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Shift packed 64-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var imm8">imm8</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	IF imm8[7:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend(a[i+63:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5521"><div class="instruction">vpsrlq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_srli_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_srli_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsrlq ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shift packed 64-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var imm8">imm8</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	IF imm8[7:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend(a[i+63:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic MMX" id="5525"><div class="instruction">psrlw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_srli_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_srli_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psrlw mm, imm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Shift packed 16-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var imm8">imm8</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend(a[i+15:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR</div></div></div><div class="intrinsic MMX" id="5526"><div class="instruction">psrld</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_srli_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_srli_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psrld mm, imm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Shift packed 32-bit integers in <span class="desc_var a">a</span> right by <span class="desc_var imm8">imm8</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend(a[i+31:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR</div></div></div><div class="intrinsic SSE2" id="5527"><div class="instruction">psrldq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_srli_si128</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_srli_si128</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: psrldq xmm, imm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Shift <span class="desc_var a">a</span> right by <span class="desc_var imm8">imm8</span> bytes while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">tmp := imm8[7:0]
IF tmp &gt; 15
	tmp := 16
FI
dst[127:0] := a[127:0] &gt;&gt; (tmp*8)</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5528"><div class="instruction">vpsrldq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_srli_si256</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_srli_si256</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">const int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsrldq ymm, ymm, imm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shift 128-bit lanes in <span class="desc_var a">a</span> right by <span class="desc_var imm8">imm8</span> bytes while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">tmp := imm8[7:0]
IF tmp &gt; 15
	tmp := 16
FI
dst[127:0] := a[127:0] &gt;&gt; (tmp*8)
dst[255:128] := a[255:128] &gt;&gt; (tmp*8)
dst[MAX:256] := 0</div></div></div><div class="intrinsic MMX" id="5529"><div class="instruction">psrlq</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_srli_si64</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_srli_si64</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">int</span> <span class="param_name">imm8</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psrlq mm, imm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Shift 64-bit integer <span class="desc_var a">a</span> right by <span class="desc_var imm8">imm8</span> while shifting in zeros, and store the result in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">IF imm8[7:0] &gt; 63
	dst[63:0] := 0
ELSE
	dst[63:0] := ZeroExtend(a[63:0] &gt;&gt; imm8[7:0])
FI</div></div></div><div class="intrinsic AVX2" id="5541"><div class="instruction">vpsrlvd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_srlv_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_srlv_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsrlvd xmm, xmm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shift packed 32-bit integers in <span class="desc_var a">a</span> right by the amount specified by the corresponding element in <span class="desc_var count">count</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := ZeroExtend(a[i+31:i] &gt;&gt; count[i+31:i])
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX2" id="5544"><div class="instruction">vpsrlvd</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_srlv_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_srlv_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">count</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsrlvd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shift packed 32-bit integers in <span class="desc_var a">a</span> right by the amount specified by the corresponding element in <span class="desc_var count">count</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := ZeroExtend(a[i+31:i] &gt;&gt; count[i+31:i])
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX2" id="5550"><div class="instruction">vpsrlvq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_srlv_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_srlv_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">count</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsrlvq xmm, xmm, xmm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shift packed 64-bit integers in <span class="desc_var a">a</span> right by the amount specified by the corresponding element in <span class="desc_var count">count</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := ZeroExtend(a[i+63:i] &gt;&gt; count[i+63:i])
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX2" id="5553"><div class="instruction">vpsrlvq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_srlv_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">count</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_srlv_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">count</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsrlvq ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Shift packed 64-bit integers in <span class="desc_var a">a</span> right by the amount specified by the corresponding element in <span class="desc_var count">count</span> while shifting in zeros, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := ZeroExtend(a[i+63:i] &gt;&gt; count[i+63:i])
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="5574"><div class="instruction">movapd</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_store_pd</span> (<span class="param_type">double*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_store_pd</span> (<span class="param_type">double*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128d</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: movapd m128, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Store 128-bits (composed of 2 packed double-precision (64-bit) floating-point elements) from <span class="desc_var a">a</span> into memory.
	<span class="desc_var mem_addr">mem_addr</span> must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div><h1>Operation</h1><div class="operation">MEM[mem_addr+127:mem_addr] := a[127:0]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="5576"><div class="instruction">vmovapd</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_store_pd</span> (<span class="param_type">double *</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m256d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_store_pd</span> (<span class="param_type">double *</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m256d</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vmovapd m256, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Store 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from <span class="desc_var a">a</span> into memory.
	<span class="desc_var mem_addr">mem_addr</span> must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div><h1>Operation</h1><div class="operation">MEM[mem_addr+255:mem_addr] := a[255:0]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.25</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="5579"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_store_pd1</span> (<span class="param_type">double*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_store_pd1</span> (<span class="param_type">double*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128d</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Store the lower double-precision (64-bit) floating-point element from <span class="desc_var a">a</span> into 2 contiguous elements in memory. <span class="desc_var mem_addr">mem_addr</span> must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div><h1>Operation</h1><div class="operation">MEM[mem_addr+63:mem_addr] := a[63:0]
MEM[mem_addr+127:mem_addr+64] := a[63:0]</div></div></div><div class="intrinsic SSE" id="5581"><div class="instruction">movaps</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_store_ps</span> (<span class="param_type">float*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_store_ps</span> (<span class="param_type">float*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: movaps m128, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Store 128-bits (composed of 4 packed single-precision (32-bit) floating-point elements) from <span class="desc_var a">a</span> into memory.
	<span class="desc_var mem_addr">mem_addr</span> must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div><h1>Operation</h1><div class="operation">MEM[mem_addr+127:mem_addr] := a[127:0]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.25</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="5583"><div class="instruction">vmovaps</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_store_ps</span> (<span class="param_type">float *</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m256</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_store_ps</span> (<span class="param_type">float *</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m256</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vmovaps m256, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Store 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from <span class="desc_var a">a</span> into memory.
	<span class="desc_var mem_addr">mem_addr</span> must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div><h1>Operation</h1><div class="operation">MEM[mem_addr+255:mem_addr] := a[255:0]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.25</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="5586"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_store_ps1</span> (<span class="param_type">float*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_store_ps1</span> (<span class="param_type">float*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Store the lower single-precision (32-bit) floating-point element from <span class="desc_var a">a</span> into 4 contiguous elements in memory. <span class="desc_var mem_addr">mem_addr</span> must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div><h1>Operation</h1><div class="operation">MEM[mem_addr+31:mem_addr] := a[31:0]
MEM[mem_addr+63:mem_addr+32] := a[31:0]
MEM[mem_addr+95:mem_addr+64] := a[31:0]
MEM[mem_addr+127:mem_addr+96] := a[31:0]</div></div></div><div class="intrinsic SSE2" id="5588"><div class="instruction">movsd</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_store_sd</span> (<span class="param_type">double*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_store_sd</span> (<span class="param_type">double*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128d</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: movsd m64, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Store the lower double-precision (64-bit) floating-point element from <span class="desc_var a">a</span> into memory. <span class="desc_var mem_addr">mem_addr</span> does not need to be aligned on any particular boundary.</div><h1>Operation</h1><div class="operation">MEM[mem_addr+63:mem_addr] := a[63:0]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="5589"><div class="instruction">movdqa</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_store_si128</span> (<span class="param_type">__m128i*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_store_si128</span> (<span class="param_type">__m128i*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: movdqa m128, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Store 128-bits of integer data from <span class="desc_var a">a</span> into memory. 
	<span class="desc_var mem_addr">mem_addr</span> must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div><h1>Operation</h1><div class="operation">MEM[mem_addr+127:mem_addr] := a[127:0]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.25</td></tr><tr><td>Broadwell</td><td>1</td><td>0.33</td></tr><tr><td>Haswell</td><td>1</td><td>0.33</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="5590"><div class="instruction">vmovdqa</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_store_si256</span> (<span class="param_type">__m256i *</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_store_si256</span> (<span class="param_type">__m256i *</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vmovdqa m256, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Store 256-bits of integer data from <span class="desc_var a">a</span> into memory.
	<span class="desc_var mem_addr">mem_addr</span> must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div><h1>Operation</h1><div class="operation">MEM[mem_addr+255:mem_addr] := a[255:0]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.25</td></tr><tr><td>Broadwell</td><td>1</td><td>0.25</td></tr><tr><td>Haswell</td><td>1</td><td>0.25</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="5593"><div class="instruction">movss</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_store_ss</span> (<span class="param_type">float*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_store_ss</span> (<span class="param_type">float*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: movss m32, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Store the lower single-precision (32-bit) floating-point element from <span class="desc_var a">a</span> into memory. <span class="desc_var mem_addr">mem_addr</span> does not need to be aligned on any particular boundary.</div><h1>Operation</h1><div class="operation">MEM[mem_addr+31:mem_addr] := a[31:0]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="5594"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_store1_pd</span> (<span class="param_type">double*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_store1_pd</span> (<span class="param_type">double*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128d</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Store the lower double-precision (64-bit) floating-point element from <span class="desc_var a">a</span> into 2 contiguous elements in memory. <span class="desc_var mem_addr">mem_addr</span> must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div><h1>Operation</h1><div class="operation">MEM[mem_addr+63:mem_addr] := a[63:0]
MEM[mem_addr+127:mem_addr+64] := a[63:0]</div></div></div><div class="intrinsic SSE" id="5595"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_store1_ps</span> (<span class="param_type">float*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_store1_ps</span> (<span class="param_type">float*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Store the lower single-precision (32-bit) floating-point element from <span class="desc_var a">a</span> into 4 contiguous elements in memory. <span class="desc_var mem_addr">mem_addr</span> must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div><h1>Operation</h1><div class="operation">MEM[mem_addr+31:mem_addr] := a[31:0]
MEM[mem_addr+63:mem_addr+32] := a[31:0]
MEM[mem_addr+95:mem_addr+64] := a[31:0]
MEM[mem_addr+127:mem_addr+96] := a[31:0]</div></div></div><div class="intrinsic SSE2" id="5599"><div class="instruction">movhpd</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_storeh_pd</span> (<span class="param_type">double*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_storeh_pd</span> (<span class="param_type">double*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128d</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: movhpd m64, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Store the upper double-precision (64-bit) floating-point element from <span class="desc_var a">a</span> into memory.</div><h1>Operation</h1><div class="operation">MEM[mem_addr+63:mem_addr] := a[127:64]</div></div></div><div class="intrinsic SSE" id="5600"><div class="instruction">movhps</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_storeh_pi</span> (<span class="param_type">__m64*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_storeh_pi</span> (<span class="param_type">__m64*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: movhps m64, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Store the upper 2 single-precision (32-bit) floating-point elements from <span class="desc_var a">a</span> into memory.</div><h1>Operation</h1><div class="operation">MEM[mem_addr+31:mem_addr] := a[95:64]
MEM[mem_addr+63:mem_addr+32] := a[127:96]</div></div></div><div class="intrinsic SSE2" id="5601"><div class="instruction">movq</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_storel_epi64</span> (<span class="param_type">__m128i*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_storel_epi64</span> (<span class="param_type">__m128i*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: movq m64, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Store 64-bit integer from the first element of <span class="desc_var a">a</span> into memory.</div><h1>Operation</h1><div class="operation">MEM[mem_addr+63:mem_addr] := a[63:0]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.33</td></tr><tr><td>Haswell</td><td>1</td><td>0.33</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.33</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="5602"><div class="instruction">movlpd</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_storel_pd</span> (<span class="param_type">double*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_storel_pd</span> (<span class="param_type">double*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128d</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: movlpd m64, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Store the lower double-precision (64-bit) floating-point element from <span class="desc_var a">a</span> into memory.</div><h1>Operation</h1><div class="operation">MEM[mem_addr+63:mem_addr] := a[63:0]</div></div></div><div class="intrinsic SSE" id="5603"><div class="instruction">movlps</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_storel_pi</span> (<span class="param_type">__m64*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_storel_pi</span> (<span class="param_type">__m64*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: movlps m64, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Store the lower 2 single-precision (32-bit) floating-point elements from <span class="desc_var a">a</span> into memory.</div><h1>Operation</h1><div class="operation">MEM[mem_addr+31:mem_addr] := a[31:0]
MEM[mem_addr+63:mem_addr+32] := a[63:32]</div></div></div><div class="intrinsic SSE2" id="5608"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_storer_pd</span> (<span class="param_type">double*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_storer_pd</span> (<span class="param_type">double*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128d</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Store 2 double-precision (64-bit) floating-point elements from <span class="desc_var a">a</span> into memory in reverse order.
	<span class="desc_var mem_addr">mem_addr</span> must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div><h1>Operation</h1><div class="operation">MEM[mem_addr+63:mem_addr] := a[127:64]
MEM[mem_addr+127:mem_addr+64] := a[63:0]</div></div></div><div class="intrinsic SSE" id="5609"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_storer_ps</span> (<span class="param_type">float*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_storer_ps</span> (<span class="param_type">float*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: <span class="instruction_note" note-type="sequence">movups</span> m128, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Store 4 single-precision (32-bit) floating-point elements from <span class="desc_var a">a</span> into memory in reverse order.
	<span class="desc_var mem_addr">mem_addr</span> must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div><h1>Operation</h1><div class="operation">MEM[mem_addr+31:mem_addr] := a[127:96]
MEM[mem_addr+63:mem_addr+32] := a[95:64]
MEM[mem_addr+95:mem_addr+64] := a[63:32]
MEM[mem_addr+127:mem_addr+96] := a[31:0]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.25</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="5635"><div class="instruction">movupd</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_storeu_pd</span> (<span class="param_type">double*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_storeu_pd</span> (<span class="param_type">double*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128d</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: movupd m128, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Store 128-bits (composed of 2 packed double-precision (64-bit) floating-point elements) from <span class="desc_var a">a</span> into memory.
	<span class="desc_var mem_addr">mem_addr</span> does not need to be aligned on any particular boundary.</div><h1>Operation</h1><div class="operation">MEM[mem_addr+127:mem_addr] := a[127:0]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="5637"><div class="instruction">vmovupd</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_storeu_pd</span> (<span class="param_type">double *</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m256d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_storeu_pd</span> (<span class="param_type">double *</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m256d</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vmovupd m256, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Store 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from <span class="desc_var a">a</span> into memory.
	<span class="desc_var mem_addr">mem_addr</span> does not need to be aligned on any particular boundary.</div><h1>Operation</h1><div class="operation">MEM[mem_addr+255:mem_addr] := a[255:0]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.25</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="5641"><div class="instruction">movups</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_storeu_ps</span> (<span class="param_type">float*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_storeu_ps</span> (<span class="param_type">float*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: movups m128, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Store 128-bits (composed of 4 packed single-precision (32-bit) floating-point elements) from <span class="desc_var a">a</span> into memory.
	<span class="desc_var mem_addr">mem_addr</span> does not need to be aligned on any particular boundary.</div><h1>Operation</h1><div class="operation">MEM[mem_addr+127:mem_addr] := a[127:0]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.25</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="5643"><div class="instruction">vmovups</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_storeu_ps</span> (<span class="param_type">float *</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m256</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_storeu_ps</span> (<span class="param_type">float *</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m256</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vmovups m256, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Store 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from <span class="desc_var a">a</span> into memory.
	<span class="desc_var mem_addr">mem_addr</span> does not need to be aligned on any particular boundary.</div><h1>Operation</h1><div class="operation">MEM[mem_addr+255:mem_addr] := a[255:0]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.25</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="5646"><div class="instruction">movdqu</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_storeu_si128</span> (<span class="param_type">__m128i*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_storeu_si128</span> (<span class="param_type">__m128i*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: movdqu m128, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Store 128-bits of integer data from <span class="desc_var a">a</span> into memory.
	<span class="desc_var mem_addr">mem_addr</span> does not need to be aligned on any particular boundary.
	</div><h1>Operation</h1><div class="operation">MEM[mem_addr+127:mem_addr] := a[127:0]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.25</td></tr><tr><td>Broadwell</td><td>1</td><td>0.33</td></tr><tr><td>Haswell</td><td>1</td><td>0.33</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="5647"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_storeu_si16</span> (<span class="param_type">void*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_storeu_si16</span> (<span class="param_type">void*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Store 16-bit integer from the first element of <span class="desc_var a">a</span> into memory. <span class="desc_var mem_addr">mem_addr</span> does not need to be aligned on any particular boundary.</div><h1>Operation</h1><div class="operation">MEM[mem_addr+15:mem_addr] := a[15:0]</div></div></div><div class="intrinsic AVX" id="5648"><div class="instruction">vmovdqu</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_storeu_si256</span> (<span class="param_type">__m256i *</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_storeu_si256</span> (<span class="param_type">__m256i *</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vmovdqu m256, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Store 256-bits of integer data from <span class="desc_var a">a</span> into memory.
	<span class="desc_var mem_addr">mem_addr</span> does not need to be aligned on any particular boundary.
	</div><h1>Operation</h1><div class="operation">MEM[mem_addr+255:mem_addr] := a[255:0]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.25</td></tr><tr><td>Broadwell</td><td>1</td><td>0.25</td></tr><tr><td>Haswell</td><td>1</td><td>0.25</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="5649"><div class="instruction">movd</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_storeu_si32</span> (<span class="param_type">void*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_storeu_si32</span> (<span class="param_type">void*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: movd m32, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Store 32-bit integer from the first element of <span class="desc_var a">a</span> into memory. <span class="desc_var mem_addr">mem_addr</span> does not need to be aligned on any particular boundary.</div><h1>Operation</h1><div class="operation">MEM[mem_addr+31:mem_addr] := a[31:0]</div></div></div><div class="intrinsic SSE" id="5651"><div class="instruction">movq</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_storeu_si64</span> (<span class="param_type">void*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_storeu_si64</span> (<span class="param_type">void*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: movq m64, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Store 64-bit integer from the first element of <span class="desc_var a">a</span> into memory. <span class="desc_var mem_addr">mem_addr</span> does not need to be aligned on any particular boundary.</div><h1>Operation</h1><div class="operation">MEM[mem_addr+63:mem_addr] := a[63:0]</div></div></div><div class="intrinsic AVX" id="5652"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_storeu2_m128</span> (<span class="param_type">float*</span> <span class="param_name">hiaddr</span>, <span class="param_type">float*</span> <span class="param_name">loaddr</span>, <span class="param_type">__m256</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_storeu2_m128</span> (<span class="param_type">float*</span> <span class="param_name">hiaddr</span>, <span class="param_type">float*</span> <span class="param_name">loaddr</span>, <span class="param_type">__m256</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Store the high and low 128-bit halves (each composed of 4 packed single-precision (32-bit) floating-point elements) from <span class="desc_var a">a</span> into memory two different 128-bit locations.
	<span class="desc_var hiaddr">hiaddr</span> and <span class="desc_var loaddr">loaddr</span> do not need to be aligned on any particular boundary.</div><h1>Operation</h1><div class="operation">MEM[loaddr+127:loaddr] := a[127:0]
MEM[hiaddr+127:hiaddr] := a[255:128]</div></div></div><div class="intrinsic AVX" id="5653"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_storeu2_m128d</span> (<span class="param_type">double*</span> <span class="param_name">hiaddr</span>, <span class="param_type">double*</span> <span class="param_name">loaddr</span>, <span class="param_type">__m256d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_storeu2_m128d</span> (<span class="param_type">double*</span> <span class="param_name">hiaddr</span>, <span class="param_type">double*</span> <span class="param_name">loaddr</span>, <span class="param_type">__m256d</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Store the high and low 128-bit halves (each composed of 2 packed double-precision (64-bit) floating-point elements) from <span class="desc_var a">a</span> into memory two different 128-bit locations.
	<span class="desc_var hiaddr">hiaddr</span> and <span class="desc_var loaddr">loaddr</span> do not need to be aligned on any particular boundary.</div><h1>Operation</h1><div class="operation">MEM[loaddr+127:loaddr] := a[127:0]
MEM[hiaddr+127:hiaddr] := a[255:128]</div></div></div><div class="intrinsic AVX" id="5654"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_storeu2_m128i</span> (<span class="param_type">__m128i*</span> <span class="param_name">hiaddr</span>, <span class="param_type">__m128i*</span> <span class="param_name">loaddr</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_storeu2_m128i</span> (<span class="param_type">__m128i*</span> <span class="param_name">hiaddr</span>, <span class="param_type">__m128i*</span> <span class="param_name">loaddr</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Store the high and low 128-bit halves (each composed of integer data) from <span class="desc_var a">a</span> into memory two different 128-bit locations.
	<span class="desc_var hiaddr">hiaddr</span> and <span class="desc_var loaddr">loaddr</span> do not need to be aligned on any particular boundary.</div><h1>Operation</h1><div class="operation">MEM[loaddr+127:loaddr] := a[127:0]
MEM[hiaddr+127:hiaddr] := a[255:128]</div></div></div><div class="intrinsic SSE4_1" id="5655"><div class="instruction">movntdqa</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_stream_load_si128</span> (<span class="param_type">__m128i *</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_stream_load_si128</span> (<span class="param_type">__m128i *</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: movntdqa xmm, m128<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Load 128-bits of integer data from memory into <span class="desc_var dst">dst</span> using a non-temporal memory hint.
	<span class="desc_var mem_addr">mem_addr</span> must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div><h1>Operation</h1><div class="operation">dst[127:0] := MEM[mem_addr+127:mem_addr]</div></div></div><div class="intrinsic AVX2" id="5656"><div class="instruction">vmovntdqa</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_stream_load_si256</span> (<span class="param_type">__m256i const*</span> <span class="param_name">mem_addr</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_stream_load_si256</span> (<span class="param_type">__m256i const*</span> <span class="param_name">mem_addr</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vmovntdqa ymm, m256<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Load 256-bits of integer data from memory into <span class="desc_var dst">dst</span> using a non-temporal memory hint.
	<span class="desc_var mem_addr">mem_addr</span> must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div><h1>Operation</h1><div class="operation">dst[255:0] := MEM[mem_addr+255:mem_addr]
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="5658"><div class="instruction">movntpd</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_stream_pd</span> (<span class="param_type">double*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_stream_pd</span> (<span class="param_type">double*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128d</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: movntpd m128, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Store 128-bits (composed of 2 packed double-precision (64-bit) floating-point elements) from <span class="desc_var a">a</span> into memory using a non-temporal memory hint.
	<span class="desc_var mem_addr">mem_addr</span> must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div><h1>Operation</h1><div class="operation">MEM[mem_addr+127:mem_addr] := a[127:0]</div></div></div><div class="intrinsic AVX" id="5659"><div class="instruction">vmovntpd</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_stream_pd</span> (<span class="param_type">double *</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m256d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_stream_pd</span> (<span class="param_type">double *</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m256d</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vmovntpd m256, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Store 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from <span class="desc_var a">a</span> into memory using a non-temporal memory hint.
	<span class="desc_var mem_addr">mem_addr</span> must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div><h1>Operation</h1><div class="operation">MEM[mem_addr+255:mem_addr] := a[255:0]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>-</td><td>1</td></tr><tr><td>Broadwell</td><td>-</td><td>1</td></tr><tr><td>Haswell</td><td>-</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>-</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="5661"><div class="instruction">movntq</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_stream_pi</span> (<span class="param_type">__m64*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m64</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_stream_pi</span> (<span class="param_type">__m64*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m64</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: movntq m64, mm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Store 64-bits of integer data from <span class="desc_var a">a</span> into memory using a non-temporal memory hint.</div><h1>Operation</h1><div class="operation">MEM[mem_addr+63:mem_addr] := a[63:0]</div></div></div><div class="intrinsic SSE" id="5662"><div class="instruction">movntps</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_stream_ps</span> (<span class="param_type">float*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_stream_ps</span> (<span class="param_type">float*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: movntps m128, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Store 128-bits (composed of 4 packed single-precision (32-bit) floating-point elements) from <span class="desc_var a">a</span> into memory using a non-temporal memory hint.
	<span class="desc_var mem_addr">mem_addr</span> must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div><h1>Operation</h1><div class="operation">MEM[mem_addr+127:mem_addr] := a[127:0]</div></div></div><div class="intrinsic AVX" id="5663"><div class="instruction">vmovntps</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_stream_ps</span> (<span class="param_type">float *</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m256</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_stream_ps</span> (<span class="param_type">float *</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m256</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vmovntps m256, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Store 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from <span class="desc_var a">a</span> into memory using a non-temporal memory hint.
	<span class="desc_var mem_addr">mem_addr</span> must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div><h1>Operation</h1><div class="operation">MEM[mem_addr+255:mem_addr] := a[255:0]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>-</td><td>1</td></tr><tr><td>Broadwell</td><td>-</td><td>1</td></tr><tr><td>Haswell</td><td>-</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>-</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="5665"><div class="instruction">movntdq</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_stream_si128</span> (<span class="param_type">__m128i*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_stream_si128</span> (<span class="param_type">__m128i*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: movntdq m128, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Store 128-bits of integer data from <span class="desc_var a">a</span> into memory using a non-temporal memory hint. 
	<span class="desc_var mem_addr">mem_addr</span> must be aligned on a 16-byte boundary or a general-protection exception may be generated.</div><h1>Operation</h1><div class="operation">MEM[mem_addr+127:mem_addr] := a[127:0]</div></div></div><div class="intrinsic AVX" id="5666"><div class="instruction">vmovntdq</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_stream_si256</span> (<span class="param_type">__m256i *</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_stream_si256</span> (<span class="param_type">__m256i *</span> <span class="param_name">mem_addr</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vmovntdq m256, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Store 256-bits of integer data from <span class="desc_var a">a</span> into memory using a non-temporal memory hint.
	<span class="desc_var mem_addr">mem_addr</span> must be aligned on a 32-byte boundary or a general-protection exception may be generated.</div><h1>Operation</h1><div class="operation">MEM[mem_addr+255:mem_addr] := a[255:0]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>-</td><td>1</td></tr><tr><td>Broadwell</td><td>-</td><td>1</td></tr><tr><td>Haswell</td><td>-</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>-</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="5667"><div class="instruction">movnti</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_stream_si32</span> (<span class="param_type">int*</span> <span class="param_name">mem_addr</span>, <span class="param_type">int</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_stream_si32</span> (<span class="param_type">int*</span> <span class="param_name">mem_addr</span>, <span class="param_type">int</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: movnti m32, r32<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Store 32-bit integer <span class="desc_var a">a</span> into memory using a non-temporal hint to minimize cache pollution. If the cache line containing address <span class="desc_var mem_addr">mem_addr</span> is already in the cache, the cache will be updated.</div><h1>Operation</h1><div class="operation">MEM[mem_addr+31:mem_addr] := a[31:0]</div></div></div><div class="intrinsic SSE2" id="5669"><div class="instruction">movnti</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_stream_si64</span> (<span class="param_type">__int64*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__int64</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm_stream_si64</span> (<span class="param_type">__int64*</span> <span class="param_name">mem_addr</span>, <span class="param_type">__int64</span> <span class="param_name">a</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: movnti m64, r64<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Store 64-bit integer <span class="desc_var a">a</span> into memory using a non-temporal hint to minimize cache pollution. If the cache line containing address <span class="desc_var mem_addr">mem_addr</span> is already in the cache, the cache will be updated.</div><h1>Operation</h1><div class="operation">MEM[mem_addr+63:mem_addr] := a[63:0]</div></div></div><div class="intrinsic SSE2" id="5672"><div class="instruction">psubw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_sub_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_sub_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: psubw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Subtract packed 16-bit integers in <span class="desc_var b">b</span> from packed 16-bit integers in <span class="desc_var a">a</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := a[i+15:i] - b[i+15:i]
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5675"><div class="instruction">vpsubw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_sub_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_sub_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsubw ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Subtract packed 16-bit integers in <span class="desc_var b">b</span> from packed 16-bit integers in <span class="desc_var a">a</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := a[i+15:i] - b[i+15:i]
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="5681"><div class="instruction">psubd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_sub_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_sub_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: psubd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Subtract packed 32-bit integers in <span class="desc_var b">b</span> from packed 32-bit integers in <span class="desc_var a">a</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := a[i+31:i] - b[i+31:i]
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5684"><div class="instruction">vpsubd</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_sub_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_sub_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsubd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Subtract packed 32-bit integers in <span class="desc_var b">b</span> from packed 32-bit integers in <span class="desc_var a">a</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := a[i+31:i] - b[i+31:i]
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="5690"><div class="instruction">psubq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_sub_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_sub_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: psubq xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Subtract packed 64-bit integers in <span class="desc_var b">b</span> from packed 64-bit integers in <span class="desc_var a">a</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := a[i+63:i] - b[i+63:i]
ENDFOR</div></div></div><div class="intrinsic AVX2" id="5693"><div class="instruction">vpsubq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_sub_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_sub_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsubq ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Subtract packed 64-bit integers in <span class="desc_var b">b</span> from packed 64-bit integers in <span class="desc_var a">a</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[i+63:i] - b[i+63:i]
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="5699"><div class="instruction">psubb</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_sub_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_sub_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: psubb xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Subtract packed 8-bit integers in <span class="desc_var b">b</span> from packed 8-bit integers in <span class="desc_var a">a</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := a[i+7:i] - b[i+7:i]
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5702"><div class="instruction">vpsubb</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_sub_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_sub_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsubb ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Subtract packed 8-bit integers in <span class="desc_var b">b</span> from packed 8-bit integers in <span class="desc_var a">a</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := a[i+7:i] - b[i+7:i]
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="5708"><div class="instruction">subpd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_sub_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_sub_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: subpd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Subtract packed double-precision (64-bit) floating-point elements in <span class="desc_var b">b</span> from packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := a[i+63:i] - b[i+63:i]
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="5711"><div class="instruction">vsubpd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_sub_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_sub_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vsubpd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Subtract packed double-precision (64-bit) floating-point elements in <span class="desc_var b">b</span> from packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[i+63:i] - b[i+63:i]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic MMX" id="5715"><div class="instruction">psubw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_sub_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_sub_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psubw mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Subtract packed 16-bit integers in <span class="desc_var b">b</span> from packed 16-bit integers in <span class="desc_var a">a</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := a[i+15:i] - b[i+15:i]
ENDFOR</div></div></div><div class="intrinsic MMX" id="5716"><div class="instruction">psubd</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_sub_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_sub_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psubd mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Subtract packed 32-bit integers in <span class="desc_var b">b</span> from packed 32-bit integers in <span class="desc_var a">a</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*32
	dst[i+31:i] := a[i+31:i] - b[i+31:i]
ENDFOR</div></div></div><div class="intrinsic MMX" id="5717"><div class="instruction">psubb</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_sub_pi8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_sub_pi8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psubb mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Subtract packed 8-bit integers in <span class="desc_var b">b</span> from packed 8-bit integers in <span class="desc_var a">a</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := a[i+7:i] - b[i+7:i]
ENDFOR</div></div></div><div class="intrinsic SSE" id="5720"><div class="instruction">subps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_sub_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_sub_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: subps xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Subtract packed single-precision (32-bit) floating-point elements in <span class="desc_var b">b</span> from packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := a[i+31:i] - b[i+31:i]
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="5723"><div class="instruction">vsubps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_sub_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_sub_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vsubps ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Subtract packed single-precision (32-bit) floating-point elements in <span class="desc_var b">b</span> from packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := a[i+31:i] - b[i+31:i]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="5741"><div class="instruction">subsd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_sub_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_sub_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: subsd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Subtract the lower double-precision (64-bit) floating-point element in <span class="desc_var b">b</span> from the lower double-precision (64-bit) floating-point element in <span class="desc_var a">a</span>, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := a[63:0] - b[63:0]
dst[127:64] := a[127:64]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="5742"><div class="instruction">psubq</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_sub_si64</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_sub_si64</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: psubq mm, mm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Subtract 64-bit integer <span class="desc_var b">b</span> from 64-bit integer <span class="desc_var a">a</span>, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := a[63:0] - b[63:0]</div></div></div><div class="intrinsic SSE" id="5745"><div class="instruction">subss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_sub_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_sub_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: subss xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Subtract the lower single-precision (32-bit) floating-point element in <span class="desc_var b">b</span> from the lower single-precision (32-bit) floating-point element in <span class="desc_var a">a</span>, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := a[31:0] - b[31:0]
dst[127:32] := a[127:32]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="5762"><div class="instruction">psubsw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_subs_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_subs_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: psubsw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Subtract packed 16-bit integers in <span class="desc_var b">b</span> from packed 16-bit integers in <span class="desc_var a">a</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := Saturate_To_Int16(a[i+15:i] - b[i+15:i])
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5765"><div class="instruction">vpsubsw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_subs_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_subs_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsubsw ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Subtract packed 16-bit integers in <span class="desc_var b">b</span> from packed 16-bit integers in <span class="desc_var a">a</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := Saturate_To_Int16(a[i+15:i] - b[i+15:i])
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="5771"><div class="instruction">psubsb</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_subs_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_subs_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: psubsb xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Subtract packed 8-bit integers in <span class="desc_var b">b</span> from packed 8-bit integers in <span class="desc_var a">a</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := Saturate_To_Int8(a[i+7:i] - b[i+7:i])	
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5774"><div class="instruction">vpsubsb</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_subs_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_subs_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsubsb ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Subtract packed 8-bit integers in <span class="desc_var b">b</span> from packed 8-bit integers in <span class="desc_var a">a</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := Saturate_To_Int8(a[i+7:i] - b[i+7:i])	
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="5780"><div class="instruction">psubusw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_subs_epu16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_subs_epu16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: psubusw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Subtract packed unsigned 16-bit integers in <span class="desc_var b">b</span> from packed unsigned 16-bit integers in <span class="desc_var a">a</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := Saturate_To_UnsignedInt16(a[i+15:i] - b[i+15:i])	
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5783"><div class="instruction">vpsubusw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_subs_epu16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_subs_epu16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsubusw ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Subtract packed unsigned 16-bit integers in <span class="desc_var b">b</span> from packed unsigned 16-bit integers in <span class="desc_var a">a</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := Saturate_To_UnsignedInt16(a[i+15:i] - b[i+15:i])	
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SSE2" id="5789"><div class="instruction">psubusb</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_subs_epu8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_subs_epu8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: psubusb xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Subtract packed unsigned 8-bit integers in <span class="desc_var b">b</span> from packed unsigned 8-bit integers in <span class="desc_var a">a</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := Saturate_To_UnsignedInt8(a[i+7:i] - b[i+7:i])	
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5792"><div class="instruction">vpsubusb</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_subs_epu8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_subs_epu8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpsubusb ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Subtract packed unsigned 8-bit integers in <span class="desc_var b">b</span> from packed unsigned 8-bit integers in <span class="desc_var a">a</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := Saturate_To_UnsignedInt8(a[i+7:i] - b[i+7:i])	
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic MMX" id="5796"><div class="instruction">psubsw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_subs_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_subs_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psubsw mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Subtract packed 16-bit integers in <span class="desc_var b">b</span> from packed 16-bit integers in <span class="desc_var a">a</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := Saturate_To_Int16(a[i+15:i] - b[i+15:i])
ENDFOR</div></div></div><div class="intrinsic MMX" id="5797"><div class="instruction">psubsb</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_subs_pi8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_subs_pi8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psubsb mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Subtract packed 8-bit integers in <span class="desc_var b">b</span> from packed 8-bit integers in <span class="desc_var a">a</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := Saturate_To_Int8(a[i+7:i] - b[i+7:i])	
ENDFOR</div></div></div><div class="intrinsic MMX" id="5798"><div class="instruction">psubusw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_subs_pu16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_subs_pu16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psubusw mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Subtract packed unsigned 16-bit integers in <span class="desc_var b">b</span> from packed unsigned 16-bit integers in <span class="desc_var a">a</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := Saturate_To_UnsignedInt16(a[i+15:i] - b[i+15:i])	
ENDFOR</div></div></div><div class="intrinsic MMX" id="5799"><div class="instruction">psubusb</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_subs_pu8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_subs_pu8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: psubusb mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Subtract packed unsigned 8-bit integers in <span class="desc_var b">b</span> from packed unsigned 8-bit integers in <span class="desc_var a">a</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := Saturate_To_UnsignedInt8(a[i+7:i] - b[i+7:i])	
ENDFOR</div></div></div><div class="intrinsic SSE4_1" id="5870"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_test_all_ones</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_test_all_ones</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: <span class="instruction_note" note-type="sequence">pcmpeqd</span> xmm, xmm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="instruction_note" note-type="sequence">ptest</span> xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Compute the bitwise NOT of <span class="desc_var a">a</span> and then AND with a 128-bit vector containing all 1's, and return 1 if the result is zero, otherwise return 0.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 127
	tmp[j] := 1
ENDFOR
IF ((NOT a[127:0]) AND tmp[127:0] == 0)
	CF := 1
ELSE
	CF := 0
FI
dst := CF</div></div></div><div class="intrinsic SSE4_1" id="5871"><div class="instruction">ptest</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_test_all_zeros</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">mask</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_test_all_zeros</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">mask</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: ptest xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Compute the bitwise AND of 128 bits (representing integer data) in <span class="desc_var a">a</span> and <span class="desc_var mask">mask</span>, and return 1 if the result is zero, otherwise return 0.</div><h1>Operation</h1><div class="operation">IF (a[127:0] AND mask[127:0] == 0)
	ZF := 1
ELSE
	ZF := 0
FI
dst := ZF</div></div></div><div class="intrinsic SSE4_1" id="5896"><div class="instruction">ptest</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_test_mix_ones_zeros</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">mask</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_test_mix_ones_zeros</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">mask</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: ptest xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Compute the bitwise AND of 128 bits (representing integer data) in <span class="desc_var a">a</span> and <span class="desc_var mask">mask</span>, and set <span class="desc_var ZF">ZF</span> to 1 if the result is zero, otherwise set <span class="desc_var ZF">ZF</span> to 0. Compute the bitwise NOT of <span class="desc_var a">a</span> and then AND with <span class="desc_var mask">mask</span>, and set <span class="desc_var CF">CF</span> to 1 if the result is zero, otherwise set <span class="desc_var CF">CF</span> to 0. Return 1 if both the <span class="desc_var ZF">ZF</span> and <span class="desc_var CF">CF</span> values are zero, otherwise return 0.</div><h1>Operation</h1><div class="operation">IF (a[127:0] AND mask[127:0] == 0)
	ZF := 1
ELSE
	ZF := 0
FI
IF ((NOT a[127:0]) AND mask[127:0] == 0)
	CF := 1
ELSE
	CF := 0
FI
IF (ZF == 0 &amp;&amp; CF == 0)
	dst := 1
ELSE
	dst := 0
FI</div></div></div><div class="intrinsic AVX" id="5897"><div class="instruction">vtestpd</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_testc_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_testc_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vtestpd xmm, xmm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compute the bitwise AND of 128 bits (representing double-precision (64-bit) floating-point elements) in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, producing an intermediate 128-bit value, and set <span class="desc_var ZF">ZF</span> to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set <span class="desc_var ZF">ZF</span> to 0. Compute the bitwise NOT of <span class="desc_var a">a</span> and then AND with <span class="desc_var b">b</span>, producing an intermediate value, and set <span class="desc_var CF">CF</span> to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set <span class="desc_var CF">CF</span> to 0. Return the <span class="desc_var CF">CF</span> value.</div><h1>Operation</h1><div class="operation">tmp[127:0] := a[127:0] AND b[127:0]
IF (tmp[63] == tmp[127] == 0)
	ZF := 1
ELSE
	ZF := 0
FI
tmp[127:0] := (NOT a[127:0]) AND b[127:0]
IF (tmp[63] == tmp[127] == 0)
	CF := 1
ELSE
	CF := 0
FI
dst := CF</div></div></div><div class="intrinsic AVX" id="5898"><div class="instruction">vtestpd</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm256_testc_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm256_testc_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vtestpd ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compute the bitwise AND of 256 bits (representing double-precision (64-bit) floating-point elements) in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, producing an intermediate 256-bit value, and set <span class="desc_var ZF">ZF</span> to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set <span class="desc_var ZF">ZF</span> to 0. Compute the bitwise NOT of <span class="desc_var a">a</span> and then AND with <span class="desc_var b">b</span>, producing an intermediate value, and set <span class="desc_var CF">CF</span> to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set <span class="desc_var CF">CF</span> to 0. Return the <span class="desc_var CF">CF</span> value.</div><h1>Operation</h1><div class="operation">tmp[255:0] := a[255:0] AND b[255:0]
IF (tmp[63] == tmp[127] == tmp[191] == tmp[255] == 0)
	ZF := 1
ELSE
	ZF := 0
FI
tmp[255:0] := (NOT a[255:0]) AND b[255:0]
IF (tmp[63] == tmp[127] == tmp[191] == tmp[255] == 0)
	CF := 1
ELSE
	CF := 0
FI
dst := CF</div></div></div><div class="intrinsic AVX" id="5899"><div class="instruction">vtestps</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_testc_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_testc_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vtestps xmm, xmm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compute the bitwise AND of 128 bits (representing single-precision (32-bit) floating-point elements) in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, producing an intermediate 128-bit value, and set <span class="desc_var ZF">ZF</span> to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set <span class="desc_var ZF">ZF</span> to 0. Compute the bitwise NOT of <span class="desc_var a">a</span> and then AND with <span class="desc_var b">b</span>, producing an intermediate value, and set <span class="desc_var CF">CF</span> to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set <span class="desc_var CF">CF</span> to 0. Return the <span class="desc_var CF">CF</span> value.</div><h1>Operation</h1><div class="operation">tmp[127:0] := a[127:0] AND b[127:0]
IF (tmp[31] == tmp[63] == tmp[95] == tmp[127] == 0)
	ZF := 1
ELSE
	ZF := 0
FI
tmp[127:0] := (NOT a[127:0]) AND b[127:0]
IF (tmp[31] == tmp[63] == tmp[95] == tmp[127] == 0)
	CF := 1
ELSE
	CF := 0
FI
dst := CF</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="5900"><div class="instruction">vtestps</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm256_testc_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm256_testc_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vtestps ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compute the bitwise AND of 256 bits (representing single-precision (32-bit) floating-point elements) in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, producing an intermediate 256-bit value, and set <span class="desc_var ZF">ZF</span> to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set <span class="desc_var ZF">ZF</span> to 0. Compute the bitwise NOT of <span class="desc_var a">a</span> and then AND with <span class="desc_var b">b</span>, producing an intermediate value, and set <span class="desc_var CF">CF</span> to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set <span class="desc_var CF">CF</span> to 0. Return the <span class="desc_var CF">CF</span> value.</div><h1>Operation</h1><div class="operation">tmp[255:0] := a[255:0] AND b[255:0]
IF (tmp[31] == tmp[63] == tmp[95] == tmp[127] == tmp[159] == tmp[191] == tmp[223] == tmp[255] == 0)
	ZF := 1
ELSE
	ZF := 0
FI
tmp[255:0] := (NOT a[255:0]) AND b[255:0]
IF (tmp[31] == tmp[63] == tmp[95] == tmp[127] == tmp[159] == tmp[191] == tmp[223] == tmp[255] == 0)
	CF := 1
ELSE
	CF := 0
FI
dst := CF</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE4_1" id="5901"><div class="instruction">ptest</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_testc_si128</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_testc_si128</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: ptest xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Compute the bitwise AND of 128 bits (representing integer data) in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and set <span class="desc_var ZF">ZF</span> to 1 if the result is zero, otherwise set <span class="desc_var ZF">ZF</span> to 0. Compute the bitwise NOT of <span class="desc_var a">a</span> and then AND with <span class="desc_var b">b</span>, and set <span class="desc_var CF">CF</span> to 1 if the result is zero, otherwise set <span class="desc_var CF">CF</span> to 0. Return the <span class="desc_var CF">CF</span> value.</div><h1>Operation</h1><div class="operation">IF (a[127:0] AND b[127:0] == 0)
	ZF := 1
ELSE
	ZF := 0
FI
IF ((NOT a[127:0]) AND b[127:0] == 0)
	CF := 1
ELSE
	CF := 0
FI
RETURN CF</div></div></div><div class="intrinsic AVX" id="5902"><div class="instruction">vptest</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm256_testc_si256</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm256_testc_si256</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vptest ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compute the bitwise AND of 256 bits (representing integer data) in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and set <span class="desc_var ZF">ZF</span> to 1 if the result is zero, otherwise set <span class="desc_var ZF">ZF</span> to 0. Compute the bitwise NOT of <span class="desc_var a">a</span> and then AND with <span class="desc_var b">b</span>, and set <span class="desc_var CF">CF</span> to 1 if the result is zero, otherwise set <span class="desc_var CF">CF</span> to 0. Return the <span class="desc_var CF">CF</span> value.</div><h1>Operation</h1><div class="operation">IF (a[255:0] AND b[255:0] == 0)
	ZF := 1
ELSE
	ZF := 0
FI
IF ((NOT a[255:0]) AND b[255:0] == 0)
	CF := 1
ELSE
	CF := 0
FI
RETURN CF</div></div></div><div class="intrinsic AVX" id="5927"><div class="instruction">vtestpd</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_testnzc_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_testnzc_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vtestpd xmm, xmm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compute the bitwise AND of 128 bits (representing double-precision (64-bit) floating-point elements) in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, producing an intermediate 128-bit value, and set <span class="desc_var ZF">ZF</span> to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set <span class="desc_var ZF">ZF</span> to 0. Compute the bitwise NOT of <span class="desc_var a">a</span> and then AND with <span class="desc_var b">b</span>, producing an intermediate value, and set <span class="desc_var CF">CF</span> to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set <span class="desc_var CF">CF</span> to 0. Return 1 if both the <span class="desc_var ZF">ZF</span> and <span class="desc_var CF">CF</span> values are zero, otherwise return 0.</div><h1>Operation</h1><div class="operation">tmp[127:0] := a[127:0] AND b[127:0]
IF (tmp[63] == tmp[127] == 0)
	ZF := 1
ELSE
	ZF := 0
FI
tmp[127:0] := (NOT a[127:0]) AND b[127:0]
IF (tmp[63] == tmp[127] == 0)
	CF := 1
ELSE
	CF := 0
FI
IF (ZF == 0 &amp;&amp; CF == 0)
	dst := 1
ELSE
	dst := 0
FI</div></div></div><div class="intrinsic AVX" id="5928"><div class="instruction">vtestpd</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm256_testnzc_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm256_testnzc_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vtestpd ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compute the bitwise AND of 256 bits (representing double-precision (64-bit) floating-point elements) in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, producing an intermediate 256-bit value, and set <span class="desc_var ZF">ZF</span> to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set <span class="desc_var ZF">ZF</span> to 0. Compute the bitwise NOT of <span class="desc_var a">a</span> and then AND with <span class="desc_var b">b</span>, producing an intermediate value, and set <span class="desc_var CF">CF</span> to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set <span class="desc_var CF">CF</span> to 0. Return 1 if both the <span class="desc_var ZF">ZF</span> and <span class="desc_var CF">CF</span> values are zero, otherwise return 0.</div><h1>Operation</h1><div class="operation">tmp[255:0] := a[255:0] AND b[255:0]
IF (tmp[63] == tmp[127] == tmp[191] == tmp[255] == 0)
	ZF := 1
ELSE
	ZF := 0
FI
tmp[255:0] := (NOT a[255:0]) AND b[255:0]
IF (tmp[63] == tmp[127] == tmp[191] == tmp[255] == 0)
	CF := 1
ELSE
	CF := 0
FI
IF (ZF == 0 &amp;&amp; CF == 0)
	dst := 1
ELSE
	dst := 0
FI</div></div></div><div class="intrinsic AVX" id="5929"><div class="instruction">vtestps</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_testnzc_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_testnzc_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vtestps xmm, xmm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compute the bitwise AND of 128 bits (representing single-precision (32-bit) floating-point elements) in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, producing an intermediate 128-bit value, and set <span class="desc_var ZF">ZF</span> to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set <span class="desc_var ZF">ZF</span> to 0. Compute the bitwise NOT of <span class="desc_var a">a</span> and then AND with <span class="desc_var b">b</span>, producing an intermediate value, and set <span class="desc_var CF">CF</span> to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set <span class="desc_var CF">CF</span> to 0. Return 1 if both the <span class="desc_var ZF">ZF</span> and <span class="desc_var CF">CF</span> values are zero, otherwise return 0.</div><h1>Operation</h1><div class="operation">tmp[127:0] := a[127:0] AND b[127:0]
IF (tmp[31] == tmp[63] == tmp[95] == tmp[127] == 0)
	ZF := 1
ELSE
	ZF := 0
FI
tmp[127:0] := (NOT a[127:0]) AND b[127:0]
IF (tmp[31] == tmp[63] == tmp[95] == tmp[127] == 0)
	CF := 1
ELSE
	CF := 0
FI
IF (ZF == 0 &amp;&amp; CF == 0)
	dst := 1
ELSE
	dst := 0
FI</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="5930"><div class="instruction">vtestps</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm256_testnzc_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm256_testnzc_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vtestps ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compute the bitwise AND of 256 bits (representing single-precision (32-bit) floating-point elements) in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, producing an intermediate 256-bit value, and set <span class="desc_var ZF">ZF</span> to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set <span class="desc_var ZF">ZF</span> to 0. Compute the bitwise NOT of <span class="desc_var a">a</span> and then AND with <span class="desc_var b">b</span>, producing an intermediate value, and set <span class="desc_var CF">CF</span> to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set <span class="desc_var CF">CF</span> to 0. Return 1 if both the <span class="desc_var ZF">ZF</span> and <span class="desc_var CF">CF</span> values are zero, otherwise return 0.</div><h1>Operation</h1><div class="operation">tmp[255:0] := a[255:0] AND b[255:0]
IF (tmp[31] == tmp[63] == tmp[95] == tmp[127] == tmp[159] == tmp[191] == tmp[223] == tmp[255]  == 0)
	ZF := 1
ELSE
	ZF := 0
FI
tmp[255:0] := (NOT a[255:0]) AND b[255:0]
IF (tmp[31] == tmp[63] == tmp[95] == tmp[127] == tmp[159] == tmp[191] == tmp[223] == tmp[255]  == 0)
	CF := 1
ELSE
	CF := 0
FI
IF (ZF == 0 &amp;&amp; CF == 0)
	dst := 1
ELSE
	dst := 0
FI</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE4_1" id="5931"><div class="instruction">ptest</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_testnzc_si128</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_testnzc_si128</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: ptest xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Compute the bitwise AND of 128 bits (representing integer data) in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and set <span class="desc_var ZF">ZF</span> to 1 if the result is zero, otherwise set <span class="desc_var ZF">ZF</span> to 0. Compute the bitwise NOT of <span class="desc_var a">a</span> and then AND with <span class="desc_var b">b</span>, and set <span class="desc_var CF">CF</span> to 1 if the result is zero, otherwise set <span class="desc_var CF">CF</span> to 0. Return 1 if both the <span class="desc_var ZF">ZF</span> and <span class="desc_var CF">CF</span> values are zero, otherwise return 0.</div><h1>Operation</h1><div class="operation">IF (a[127:0] AND b[127:0] == 0)
	ZF := 1
ELSE
	ZF := 0
FI
IF ((NOT a[127:0]) AND b[127:0] == 0)
	CF := 1
ELSE
	CF := 0
FI
IF (ZF == 0 &amp;&amp; CF == 0)
	dst := 1
ELSE
	dst := 0
FI</div></div></div><div class="intrinsic AVX" id="5932"><div class="instruction">vptest</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm256_testnzc_si256</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm256_testnzc_si256</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vptest ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compute the bitwise AND of 256 bits (representing integer data) in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and set <span class="desc_var ZF">ZF</span> to 1 if the result is zero, otherwise set <span class="desc_var ZF">ZF</span> to 0. Compute the bitwise NOT of <span class="desc_var a">a</span> and then AND with <span class="desc_var b">b</span>, and set <span class="desc_var CF">CF</span> to 1 if the result is zero, otherwise set <span class="desc_var CF">CF</span> to 0. Return 1 if both the <span class="desc_var ZF">ZF</span> and <span class="desc_var CF">CF</span> values are zero, otherwise return 0.</div><h1>Operation</h1><div class="operation">IF (a[255:0] AND b[255:0] == 0)
	ZF := 1
ELSE
	ZF := 0
FI
IF ((NOT a[255:0]) AND b[255:0] == 0)
	CF := 1
ELSE
	CF := 0
FI
IF (ZF == 0 &amp;&amp; CF == 0)
	dst := 1
ELSE
	dst := 0
FI</div></div></div><div class="intrinsic AVX" id="5933"><div class="instruction">vtestpd</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_testz_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_testz_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vtestpd xmm, xmm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compute the bitwise AND of 128 bits (representing double-precision (64-bit) floating-point elements) in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, producing an intermediate 128-bit value, and set <span class="desc_var ZF">ZF</span> to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set <span class="desc_var ZF">ZF</span> to 0. Compute the bitwise NOT of <span class="desc_var a">a</span> and then AND with <span class="desc_var b">b</span>, producing an intermediate value, and set <span class="desc_var CF">CF</span> to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set <span class="desc_var CF">CF</span> to 0. Return the <span class="desc_var ZF">ZF</span> value.</div><h1>Operation</h1><div class="operation">tmp[127:0] := a[127:0] AND b[127:0]
IF (tmp[63] == tmp[127] == 0)
	ZF := 1
ELSE
	ZF := 0
FI
tmp[127:0] := (NOT a[127:0]) AND b[127:0]
IF (tmp[63] == tmp[127] == 0)
	CF := 1
ELSE
	CF := 0
FI
dst := ZF</div></div></div><div class="intrinsic AVX" id="5934"><div class="instruction">vtestpd</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm256_testz_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm256_testz_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vtestpd ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compute the bitwise AND of 256 bits (representing double-precision (64-bit) floating-point elements) in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, producing an intermediate 256-bit value, and set <span class="desc_var ZF">ZF</span> to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set <span class="desc_var ZF">ZF</span> to 0. Compute the bitwise NOT of <span class="desc_var a">a</span> and then AND with <span class="desc_var b">b</span>, producing an intermediate value, and set <span class="desc_var CF">CF</span> to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set <span class="desc_var CF">CF</span> to 0. Return the <span class="desc_var ZF">ZF</span> value.</div><h1>Operation</h1><div class="operation">tmp[255:0] := a[255:0] AND b[255:0]
IF (tmp[63] == tmp[127] == tmp[191] == tmp[255] == 0)
	ZF := 1
ELSE
	ZF := 0
FI
tmp[255:0] := (NOT a[255:0]) AND b[255:0]
IF (tmp[63] == tmp[127] == tmp[191] == tmp[255] == 0)
	CF := 1
ELSE
	CF := 0
FI
dst := ZF</div></div></div><div class="intrinsic AVX" id="5935"><div class="instruction">vtestps</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_testz_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_testz_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vtestps xmm, xmm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compute the bitwise AND of 128 bits (representing single-precision (32-bit) floating-point elements) in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, producing an intermediate 128-bit value, and set <span class="desc_var ZF">ZF</span> to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set <span class="desc_var ZF">ZF</span> to 0. Compute the bitwise NOT of <span class="desc_var a">a</span> and then AND with <span class="desc_var b">b</span>, producing an intermediate value, and set <span class="desc_var CF">CF</span> to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set <span class="desc_var CF">CF</span> to 0. Return the <span class="desc_var ZF">ZF</span> value.</div><h1>Operation</h1><div class="operation">tmp[127:0] := a[127:0] AND b[127:0]
IF (tmp[31] == tmp[63] == tmp[95] == tmp[127] == 0)
	ZF := 1
ELSE
	ZF := 0
FI
tmp[127:0] := (NOT a[127:0]) AND b[127:0]
IF (tmp[31] == tmp[63] == tmp[95] == tmp[127] == 0)
	CF := 1
ELSE
	CF := 0
FI
dst := ZF</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="5936"><div class="instruction">vtestps</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm256_testz_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm256_testz_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vtestps ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compute the bitwise AND of 256 bits (representing single-precision (32-bit) floating-point elements) in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, producing an intermediate 256-bit value, and set <span class="desc_var ZF">ZF</span> to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set <span class="desc_var ZF">ZF</span> to 0. Compute the bitwise NOT of <span class="desc_var a">a</span> and then AND with <span class="desc_var b">b</span>, producing an intermediate value, and set <span class="desc_var CF">CF</span> to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set <span class="desc_var CF">CF</span> to 0. Return the <span class="desc_var ZF">ZF</span> value.</div><h1>Operation</h1><div class="operation">tmp[255:0] := a[255:0] AND b[255:0]
IF (tmp[31] == tmp[63] == tmp[95] == tmp[127] == tmp[159] == tmp[191] == tmp[223] == tmp[255] == 0)
	ZF := 1
ELSE
	ZF := 0
FI
tmp[255:0] := (NOT a[255:0]) AND b[255:0]
IF (tmp[31] == tmp[63] == tmp[95] == tmp[127] == tmp[159] == tmp[191] == tmp[223] == tmp[255] == 0)
	CF := 1
ELSE
	CF := 0
FI
dst := ZF</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>3</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE4_1" id="5937"><div class="instruction">ptest</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_testz_si128</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_testz_si128</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;smmintrin.h&gt;<br>Instruction: ptest xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE4.1</span></div><h1>Description</h1><div class="description">Compute the bitwise AND of 128 bits (representing integer data) in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and set <span class="desc_var ZF">ZF</span> to 1 if the result is zero, otherwise set <span class="desc_var ZF">ZF</span> to 0. Compute the bitwise NOT of <span class="desc_var a">a</span> and then AND with <span class="desc_var b">b</span>, and set <span class="desc_var CF">CF</span> to 1 if the result is zero, otherwise set <span class="desc_var CF">CF</span> to 0. Return the <span class="desc_var ZF">ZF</span> value.</div><h1>Operation</h1><div class="operation">IF (a[127:0] AND b[127:0] == 0)
	ZF := 1
ELSE
	ZF := 0
FI
IF ((NOT a[127:0]) AND b[127:0] == 0)
	CF := 1
ELSE
	CF := 0
FI
RETURN ZF</div></div></div><div class="intrinsic AVX" id="5938"><div class="instruction">vptest</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm256_testz_si256</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm256_testz_si256</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vptest ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compute the bitwise AND of 256 bits (representing integer data) in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and set <span class="desc_var ZF">ZF</span> to 1 if the result is zero, otherwise set <span class="desc_var ZF">ZF</span> to 0. Compute the bitwise NOT of <span class="desc_var a">a</span> and then AND with <span class="desc_var b">b</span>, and set <span class="desc_var CF">CF</span> to 1 if the result is zero, otherwise set <span class="desc_var CF">CF</span> to 0. Return the <span class="desc_var ZF">ZF</span> value.</div><h1>Operation</h1><div class="operation">IF (a[255:0] AND b[255:0] == 0)
	ZF := 1
ELSE
	ZF := 0
FI
IF ((NOT a[255:0]) AND b[255:0] == 0)
	CF := 1
ELSE
	CF := 0
FI
RETURN ZF</div></div></div><div class="intrinsic MMX" id="5939"><div class="instruction">movd</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_m_to_int</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_m_to_int</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: movd r32, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Copy the lower 32-bit integer in <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := a[31:0]</div></div></div><div class="intrinsic MMX" id="5940"><div class="instruction">movq</div><div class="signature"><span class="sig"><span class="rettype">__int64</span> <span class="name">_m_to_int64</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__int64</span> <span class="name">_m_to_int64</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: movq r64, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Copy 64-bit integer <span class="desc_var a">a</span> to <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := a[63:0]</div></div></div><div class="intrinsic SSE" id="5942"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype"></span> <span class="name">_MM_TRANSPOSE4_PS</span> (<span class="param_type">__m128</span> <span class="param_name">row0</span>, <span class="param_type">__m128</span> <span class="param_name">row1</span>, <span class="param_type">__m128</span> <span class="param_name">row2</span>, <span class="param_type">__m128</span> <span class="param_name">row3</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype"></span> <span class="name">_MM_TRANSPOSE4_PS</span> (<span class="param_type">__m128</span> <span class="param_name">row0</span>, <span class="param_type">__m128</span> <span class="param_name">row1</span>, <span class="param_type">__m128</span> <span class="param_name">row2</span>, <span class="param_type">__m128</span> <span class="param_name">row3</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Macro: Transpose the 4x4 matrix formed by the 4 rows of single-precision (32-bit) floating-point elements in <span class="desc_var row0">row0</span>, <span class="desc_var row1">row1</span>, <span class="desc_var row2">row2</span>, and <span class="desc_var row3">row3</span>, and store the transposed matrix in these vectors (<span class="desc_var row0">row0</span> now contains column 0, etc.).</div><h1>Operation</h1><div class="operation">__m128 tmp3, tmp2, tmp1, tmp0;
tmp0 := _mm_unpacklo_ps(row0, row1);
tmp2 := _mm_unpacklo_ps(row2, row3);
tmp1 := _mm_unpackhi_ps(row0, row1);
tmp3 := _mm_unpackhi_ps(row2, row3);
row0 := _mm_movelh_ps(tmp0, tmp2);
row1 := _mm_movehl_ps(tmp2, tmp0);
row2 := _mm_movelh_ps(tmp1, tmp3);
row3 := _mm_movehl_ps(tmp3, tmp1);</div></div></div><div class="intrinsic SSE2" id="5957"><div class="instruction">ucomisd</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_ucomieq_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_ucomieq_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: ucomisd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare the lower double-precision (64-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for equality, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.</div><h1>Operation</h1><div class="operation">RETURN ( a[63:0] == b[63:0] ) ? 1 : 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="5958"><div class="instruction">ucomiss</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_ucomieq_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_ucomieq_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: ucomiss xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare the lower single-precision (32-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for equality, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.</div><h1>Operation</h1><div class="operation">RETURN ( a[31:0] == b[31:0] ) ? 1 : 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="5959"><div class="instruction">ucomisd</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_ucomige_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_ucomige_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: ucomisd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare the lower double-precision (64-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for greater-than-or-equal, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.</div><h1>Operation</h1><div class="operation">RETURN ( a[63:0] &gt;= b[63:0] ) ? 1 : 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="5960"><div class="instruction">ucomiss</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_ucomige_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_ucomige_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: ucomiss xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare the lower single-precision (32-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for greater-than-or-equal, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.</div><h1>Operation</h1><div class="operation">RETURN ( a[31:0] &gt;= b[31:0] ) ? 1 : 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="5961"><div class="instruction">ucomisd</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_ucomigt_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_ucomigt_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: ucomisd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare the lower double-precision (64-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for greater-than, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.</div><h1>Operation</h1><div class="operation">RETURN ( a[63:0] &gt; b[63:0] ) ? 1 : 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="5962"><div class="instruction">ucomiss</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_ucomigt_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_ucomigt_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: ucomiss xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare the lower single-precision (32-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for greater-than, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.</div><h1>Operation</h1><div class="operation">RETURN ( a[31:0] &gt; b[31:0] ) ? 1 : 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="5963"><div class="instruction">ucomisd</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_ucomile_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_ucomile_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: ucomisd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare the lower double-precision (64-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for less-than-or-equal, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.</div><h1>Operation</h1><div class="operation">RETURN ( a[63:0] &lt;= b[63:0] ) ? 1 : 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="5964"><div class="instruction">ucomiss</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_ucomile_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_ucomile_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: ucomiss xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare the lower single-precision (32-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for less-than-or-equal, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.</div><h1>Operation</h1><div class="operation">RETURN ( a[31:0] &lt;= b[31:0] ) ? 1 : 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="5965"><div class="instruction">ucomisd</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_ucomilt_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_ucomilt_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: ucomisd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare the lower double-precision (64-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for less-than, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.</div><h1>Operation</h1><div class="operation">RETURN ( a[63:0] &lt; b[63:0] ) ? 1 : 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="5966"><div class="instruction">ucomiss</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_ucomilt_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_ucomilt_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: ucomiss xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare the lower single-precision (32-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for less-than, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.</div><h1>Operation</h1><div class="operation">RETURN ( a[31:0] &lt; b[31:0] ) ? 1 : 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="5967"><div class="instruction">ucomisd</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_ucomineq_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_ucomineq_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: ucomisd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compare the lower double-precision (64-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for not-equal, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.</div><h1>Operation</h1><div class="operation">RETURN ( a[63:0] != b[63:0] ) ? 1 : 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="5968"><div class="instruction">ucomiss</div><div class="signature"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_ucomineq_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">int</span> <span class="name">_mm_ucomineq_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: ucomiss xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compare the lower single-precision (32-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> for not-equal, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.</div><h1>Operation</h1><div class="operation">RETURN ( a[31:0] != b[31:0] ) ? 1 : 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>2</td><td>1</td></tr><tr><td>Broadwell</td><td>2</td><td>1</td></tr><tr><td>Haswell</td><td>2</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>2</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="5977"><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_undefined_pd</span> (<span class="param_type">void</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_undefined_pd</span> (<span class="param_type">void</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Return vector of type __m128d with undefined elements.</div></div></div><div class="intrinsic AVX" id="5978"><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_undefined_pd</span> (<span class="param_type">void</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_undefined_pd</span> (<span class="param_type">void</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Return vector of type __m256d with undefined elements.</div></div></div><div class="intrinsic SSE" id="5980"><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_undefined_ps</span> (<span class="param_type">void</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_undefined_ps</span> (<span class="param_type">void</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Return vector of type __m128 with undefined elements.</div></div></div><div class="intrinsic AVX" id="5981"><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_undefined_ps</span> (<span class="param_type">void</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_undefined_ps</span> (<span class="param_type">void</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Return vector of type __m256 with undefined elements.</div></div></div><div class="intrinsic SSE2" id="5983"><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_undefined_si128</span> (<span class="param_type">void</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_undefined_si128</span> (<span class="param_type">void</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Return vector of type __m128i with undefined elements.</div></div></div><div class="intrinsic AVX" id="5984"><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_undefined_si256</span> (<span class="param_type">void</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_undefined_si256</span> (<span class="param_type">void</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Return vector of type __m256i with undefined elements.</div></div></div><div class="intrinsic SSE2" id="5987"><div class="instruction">punpckhwd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_unpackhi_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_unpackhi_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: punpckhwd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Unpack and interleave 16-bit integers from the high half of <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE INTERLEAVE_HIGH_WORDS(src1[127:0], src2[127:0]) {
	dst[15:0] := src1[79:64]
	dst[31:16] := src2[79:64] 
	dst[47:32] := src1[95:80] 
	dst[63:48] := src2[95:80] 
	dst[79:64] := src1[111:96] 
	dst[95:80] := src2[111:96] 
	dst[111:96] := src1[127:112] 
	dst[127:112] := src2[127:112] 
	RETURN dst[127:0]
}
dst[127:0] := INTERLEAVE_HIGH_WORDS(a[127:0], b[127:0])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5990"><div class="instruction">vpunpckhwd</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_unpackhi_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_unpackhi_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpunpckhwd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Unpack and interleave 16-bit integers from the high half of each 128-bit lane in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE INTERLEAVE_HIGH_WORDS(src1[127:0], src2[127:0]) {
	dst[15:0] := src1[79:64]
	dst[31:16] := src2[79:64] 
	dst[47:32] := src1[95:80] 
	dst[63:48] := src2[95:80] 
	dst[79:64] := src1[111:96] 
	dst[95:80] := src2[111:96] 
	dst[111:96] := src1[127:112] 
	dst[127:112] := src2[127:112] 
	RETURN dst[127:0]
}
dst[127:0] := INTERLEAVE_HIGH_WORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_HIGH_WORDS(a[255:128], b[255:128])
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="5996"><div class="instruction">punpckhdq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_unpackhi_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_unpackhi_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: punpckhdq xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Unpack and interleave 32-bit integers from the high half of <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE INTERLEAVE_HIGH_DWORDS(src1[127:0], src2[127:0]) {
	dst[31:0] := src1[95:64] 
	dst[63:32] := src2[95:64] 
	dst[95:64] := src1[127:96] 
	dst[127:96] := src2[127:96] 
	RETURN dst[127:0]	
}
dst[127:0] := INTERLEAVE_HIGH_DWORDS(a[127:0], b[127:0])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="5999"><div class="instruction">vpunpckhdq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_unpackhi_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_unpackhi_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpunpckhdq ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Unpack and interleave 32-bit integers from the high half of each 128-bit lane in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE INTERLEAVE_HIGH_DWORDS(src1[127:0], src2[127:0]) {
	dst[31:0] := src1[95:64] 
	dst[63:32] := src2[95:64] 
	dst[95:64] := src1[127:96] 
	dst[127:96] := src2[127:96] 
	RETURN dst[127:0]	
}
dst[127:0] := INTERLEAVE_HIGH_DWORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_HIGH_DWORDS(a[255:128], b[255:128])
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="6005"><div class="instruction">punpckhqdq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_unpackhi_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_unpackhi_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: punpckhqdq xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Unpack and interleave 64-bit integers from the high half of <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE INTERLEAVE_HIGH_QWORDS(src1[127:0], src2[127:0]) {
	dst[63:0] := src1[127:64] 
	dst[127:64] := src2[127:64] 
	RETURN dst[127:0]	
}
dst[127:0] := INTERLEAVE_HIGH_QWORDS(a[127:0], b[127:0])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="6008"><div class="instruction">vpunpckhqdq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_unpackhi_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_unpackhi_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpunpckhqdq ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Unpack and interleave 64-bit integers from the high half of each 128-bit lane in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE INTERLEAVE_HIGH_QWORDS(src1[127:0], src2[127:0]) {
	dst[63:0] := src1[127:64] 
	dst[127:64] := src2[127:64] 
	RETURN dst[127:0]	
}
dst[127:0] := INTERLEAVE_HIGH_QWORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_HIGH_QWORDS(a[255:128], b[255:128])
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="6014"><div class="instruction">punpckhbw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_unpackhi_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_unpackhi_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: punpckhbw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Unpack and interleave 8-bit integers from the high half of <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE INTERLEAVE_HIGH_BYTES(src1[127:0], src2[127:0]) {
	dst[7:0] := src1[71:64] 
	dst[15:8] := src2[71:64] 
	dst[23:16] := src1[79:72] 
	dst[31:24] := src2[79:72] 
	dst[39:32] := src1[87:80] 
	dst[47:40] := src2[87:80] 
	dst[55:48] := src1[95:88] 
	dst[63:56] := src2[95:88] 
	dst[71:64] := src1[103:96] 
	dst[79:72] := src2[103:96] 
	dst[87:80] := src1[111:104] 
	dst[95:88] := src2[111:104] 
	dst[103:96] := src1[119:112] 
	dst[111:104] := src2[119:112] 
	dst[119:112] := src1[127:120] 
	dst[127:120] := src2[127:120] 
	RETURN dst[127:0]	
}
dst[127:0] := INTERLEAVE_HIGH_BYTES(a[127:0], b[127:0])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="6017"><div class="instruction">vpunpckhbw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_unpackhi_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_unpackhi_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpunpckhbw ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Unpack and interleave 8-bit integers from the high half of each 128-bit lane in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE INTERLEAVE_HIGH_BYTES(src1[127:0], src2[127:0]) {
	dst[7:0] := src1[71:64] 
	dst[15:8] := src2[71:64] 
	dst[23:16] := src1[79:72] 
	dst[31:24] := src2[79:72] 
	dst[39:32] := src1[87:80] 
	dst[47:40] := src2[87:80] 
	dst[55:48] := src1[95:88] 
	dst[63:56] := src2[95:88] 
	dst[71:64] := src1[103:96] 
	dst[79:72] := src2[103:96] 
	dst[87:80] := src1[111:104] 
	dst[95:88] := src2[111:104] 
	dst[103:96] := src1[119:112] 
	dst[111:104] := src2[119:112] 
	dst[119:112] := src1[127:120] 
	dst[127:120] := src2[127:120] 
	RETURN dst[127:0]	
}
dst[127:0] := INTERLEAVE_HIGH_BYTES(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_HIGH_BYTES(a[255:128], b[255:128])
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="6023"><div class="instruction">unpckhpd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_unpackhi_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_unpackhi_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: unpckhpd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Unpack and interleave double-precision (64-bit) floating-point elements from the high half of <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE INTERLEAVE_HIGH_QWORDS(src1[127:0], src2[127:0]) {
	dst[63:0] := src1[127:64] 
	dst[127:64] := src2[127:64] 
	RETURN dst[127:0]	
}
dst[127:0] := INTERLEAVE_HIGH_QWORDS(a[127:0], b[127:0])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="6026"><div class="instruction">vunpckhpd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_unpackhi_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_unpackhi_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vunpckhpd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Unpack and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE INTERLEAVE_HIGH_QWORDS(src1[127:0], src2[127:0]) {
	dst[63:0] := src1[127:64] 
	dst[127:64] := src2[127:64] 
	RETURN dst[127:0]	
}
dst[127:0] := INTERLEAVE_HIGH_QWORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_HIGH_QWORDS(a[255:128], b[255:128])
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic MMX" id="6030"><div class="instruction">punpcklbw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_unpackhi_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_unpackhi_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: punpcklbw mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Unpack and interleave 16-bit integers from the high half of <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE INTERLEAVE_HIGH_WORDS(src1[63:0], src2[63:0]) {
	dst[15:0] := src1[47:32]
	dst[31:16] := src2[47:32]
	dst[47:32] := src1[63:48]
	dst[63:48] := src2[63:48]
	RETURN dst[63:0]
}
dst[63:0] := INTERLEAVE_HIGH_WORDS(a[63:0], b[63:0])</div></div></div><div class="intrinsic MMX" id="6031"><div class="instruction">punpckhdq</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_unpackhi_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_unpackhi_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: punpckhdq mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Unpack and interleave 32-bit integers from the high half of <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[31:0] := a[63:32]
dst[63:32] := b[63:32]</div></div></div><div class="intrinsic MMX" id="6032"><div class="instruction">punpckhbw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_unpackhi_pi8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_unpackhi_pi8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: punpckhbw mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Unpack and interleave 8-bit integers from the high half of <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE INTERLEAVE_HIGH_BYTES(src1[63:0], src2[63:0]) {
	dst[7:0] := src1[39:32]
	dst[15:8] := src2[39:32] 
	dst[23:16] := src1[47:40]
	dst[31:24] := src2[47:40]
	dst[39:32] := src1[55:48]
	dst[47:40] := src2[55:48]
	dst[55:48] := src1[63:56]
	dst[63:56] := src2[63:56]
	RETURN dst[63:0]	
}
dst[63:0] := INTERLEAVE_HIGH_BYTES(a[63:0], b[63:0])</div></div></div><div class="intrinsic SSE" id="6035"><div class="instruction">unpckhps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_unpackhi_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_unpackhi_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: unpckhps xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Unpack and interleave single-precision (32-bit) floating-point elements from the high half <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE INTERLEAVE_HIGH_DWORDS(src1[127:0], src2[127:0]) {
	dst[31:0] := src1[95:64] 
	dst[63:32] := src2[95:64] 
	dst[95:64] := src1[127:96] 
	dst[127:96] := src2[127:96] 
	RETURN dst[127:0]	
}
dst[127:0] := INTERLEAVE_HIGH_DWORDS(a[127:0], b[127:0])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="6038"><div class="instruction">vunpckhps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_unpackhi_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_unpackhi_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vunpckhps ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE INTERLEAVE_HIGH_DWORDS(src1[127:0], src2[127:0]) {
	dst[31:0] := src1[95:64] 
	dst[63:32] := src2[95:64] 
	dst[95:64] := src1[127:96] 
	dst[127:96] := src2[127:96] 
	RETURN dst[127:0]	
}
dst[127:0] := INTERLEAVE_HIGH_DWORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_HIGH_DWORDS(a[255:128], b[255:128])
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="6044"><div class="instruction">punpcklwd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_unpacklo_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_unpacklo_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: punpcklwd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Unpack and interleave 16-bit integers from the low half of <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE INTERLEAVE_WORDS(src1[127:0], src2[127:0]) {
	dst[15:0] := src1[15:0] 
	dst[31:16] := src2[15:0] 
	dst[47:32] := src1[31:16] 
	dst[63:48] := src2[31:16] 
	dst[79:64] := src1[47:32] 
	dst[95:80] := src2[47:32] 
	dst[111:96] := src1[63:48] 
	dst[127:112] := src2[63:48] 
	RETURN dst[127:0]	
}
dst[127:0] := INTERLEAVE_WORDS(a[127:0], b[127:0])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="6047"><div class="instruction">vpunpcklwd</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_unpacklo_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_unpacklo_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpunpcklwd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Unpack and interleave 16-bit integers from the low half of each 128-bit lane in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE INTERLEAVE_WORDS(src1[127:0], src2[127:0]) {
	dst[15:0] := src1[15:0] 
	dst[31:16] := src2[15:0] 
	dst[47:32] := src1[31:16] 
	dst[63:48] := src2[31:16] 
	dst[79:64] := src1[47:32] 
	dst[95:80] := src2[47:32] 
	dst[111:96] := src1[63:48] 
	dst[127:112] := src2[63:48] 
	RETURN dst[127:0]	
}
dst[127:0] := INTERLEAVE_WORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_WORDS(a[255:128], b[255:128])
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="6053"><div class="instruction">punpckldq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_unpacklo_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_unpacklo_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: punpckldq xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Unpack and interleave 32-bit integers from the low half of <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE INTERLEAVE_DWORDS(src1[127:0], src2[127:0]) {
	dst[31:0] := src1[31:0] 
	dst[63:32] := src2[31:0] 
	dst[95:64] := src1[63:32] 
	dst[127:96] := src2[63:32] 
	RETURN dst[127:0]	
}
dst[127:0] := INTERLEAVE_DWORDS(a[127:0], b[127:0])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="6056"><div class="instruction">vpunpckldq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_unpacklo_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_unpacklo_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpunpckldq ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Unpack and interleave 32-bit integers from the low half of each 128-bit lane in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE INTERLEAVE_DWORDS(src1[127:0], src2[127:0]) {
	dst[31:0] := src1[31:0] 
	dst[63:32] := src2[31:0] 
	dst[95:64] := src1[63:32] 
	dst[127:96] := src2[63:32] 
	RETURN dst[127:0]	
}
dst[127:0] := INTERLEAVE_DWORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_DWORDS(a[255:128], b[255:128])
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="6062"><div class="instruction">punpcklqdq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_unpacklo_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_unpacklo_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: punpcklqdq xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Unpack and interleave 64-bit integers from the low half of <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE INTERLEAVE_QWORDS(src1[127:0], src2[127:0]) {
	dst[63:0] := src1[63:0] 
	dst[127:64] := src2[63:0] 
	RETURN dst[127:0]
}
dst[127:0] := INTERLEAVE_QWORDS(a[127:0], b[127:0])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="6065"><div class="instruction">vpunpcklqdq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_unpacklo_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_unpacklo_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpunpcklqdq ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Unpack and interleave 64-bit integers from the low half of each 128-bit lane in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE INTERLEAVE_QWORDS(src1[127:0], src2[127:0]) {
	dst[63:0] := src1[63:0] 
	dst[127:64] := src2[63:0] 
	RETURN dst[127:0]
}
dst[127:0] := INTERLEAVE_QWORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_QWORDS(a[255:128], b[255:128])
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="6071"><div class="instruction">punpcklbw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_unpacklo_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_unpacklo_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: punpcklbw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Unpack and interleave 8-bit integers from the low half of <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE INTERLEAVE_BYTES(src1[127:0], src2[127:0]) {
	dst[7:0] := src1[7:0] 
	dst[15:8] := src2[7:0] 
	dst[23:16] := src1[15:8] 
	dst[31:24] := src2[15:8] 
	dst[39:32] := src1[23:16] 
	dst[47:40] := src2[23:16] 
	dst[55:48] := src1[31:24] 
	dst[63:56] := src2[31:24] 
	dst[71:64] := src1[39:32]
	dst[79:72] := src2[39:32] 
	dst[87:80] := src1[47:40] 
	dst[95:88] := src2[47:40] 
	dst[103:96] := src1[55:48] 
	dst[111:104] := src2[55:48] 
	dst[119:112] := src1[63:56] 
	dst[127:120] := src2[63:56] 
	RETURN dst[127:0]	
}
dst[127:0] := INTERLEAVE_BYTES(a[127:0], b[127:0])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="6074"><div class="instruction">vpunpcklbw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_unpacklo_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_unpacklo_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpunpcklbw ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Unpack and interleave 8-bit integers from the low half of each 128-bit lane in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE INTERLEAVE_BYTES(src1[127:0], src2[127:0]) {
	dst[7:0] := src1[7:0] 
	dst[15:8] := src2[7:0] 
	dst[23:16] := src1[15:8] 
	dst[31:24] := src2[15:8] 
	dst[39:32] := src1[23:16] 
	dst[47:40] := src2[23:16] 
	dst[55:48] := src1[31:24] 
	dst[63:56] := src2[31:24] 
	dst[71:64] := src1[39:32]
	dst[79:72] := src2[39:32] 
	dst[87:80] := src1[47:40] 
	dst[95:88] := src2[47:40] 
	dst[103:96] := src1[55:48] 
	dst[111:104] := src2[55:48] 
	dst[119:112] := src1[63:56] 
	dst[127:120] := src2[63:56] 
	RETURN dst[127:0]
}
dst[127:0] := INTERLEAVE_BYTES(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_BYTES(a[255:128], b[255:128])
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="6080"><div class="instruction">unpcklpd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_unpacklo_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_unpacklo_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: unpcklpd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Unpack and interleave double-precision (64-bit) floating-point elements from the low half of <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE INTERLEAVE_QWORDS(src1[127:0], src2[127:0]) {
	dst[63:0] := src1[63:0] 
	dst[127:64] := src2[63:0] 
	RETURN dst[127:0]
}
dst[127:0] := INTERLEAVE_QWORDS(a[127:0], b[127:0])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="6083"><div class="instruction">vunpcklpd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_unpacklo_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_unpacklo_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vunpcklpd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Unpack and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE INTERLEAVE_QWORDS(src1[127:0], src2[127:0]) {
	dst[63:0] := src1[63:0] 
	dst[127:64] := src2[63:0] 
	RETURN dst[127:0]
}
dst[127:0] := INTERLEAVE_QWORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_QWORDS(a[255:128], b[255:128])
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic MMX" id="6087"><div class="instruction">punpcklwd</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_unpacklo_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_unpacklo_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: punpcklwd mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Unpack and interleave 16-bit integers from the low half of <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE INTERLEAVE_WORDS(src1[63:0], src2[63:0]) {
	dst[15:0] := src1[15:0] 
	dst[31:16] := src2[15:0] 
	dst[47:32] := src1[31:16] 
	dst[63:48] := src2[31:16] 
	RETURN dst[63:0]	
}
dst[63:0] := INTERLEAVE_WORDS(a[63:0], b[63:0])</div></div></div><div class="intrinsic MMX" id="6088"><div class="instruction">punpckldq</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_unpacklo_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_unpacklo_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: punpckldq mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Unpack and interleave 32-bit integers from the low half of <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">dst[31:0] := a[31:0]
dst[63:32] := b[31:0]</div></div></div><div class="intrinsic MMX" id="6089"><div class="instruction">punpcklbw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_unpacklo_pi8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_unpacklo_pi8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: punpcklbw mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Unpack and interleave 8-bit integers from the low half of <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE INTERLEAVE_BYTES(src1[63:0], src2[63:0]) {
	dst[7:0] := src1[7:0] 
	dst[15:8] := src2[7:0] 
	dst[23:16] := src1[15:8] 
	dst[31:24] := src2[15:8] 
	dst[39:32] := src1[23:16] 
	dst[47:40] := src2[23:16] 
	dst[55:48] := src1[31:24] 
	dst[63:56] := src2[31:24] 
	RETURN dst[63:0]	
}
dst[63:0] := INTERLEAVE_BYTES(a[63:0], b[63:0])</div></div></div><div class="intrinsic SSE" id="6092"><div class="instruction">unpcklps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_unpacklo_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_unpacklo_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: unpcklps xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Unpack and interleave single-precision (32-bit) floating-point elements from the low half of <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE INTERLEAVE_DWORDS(src1[127:0], src2[127:0]) {
	dst[31:0] := src1[31:0] 
	dst[63:32] := src2[31:0] 
	dst[95:64] := src1[63:32] 
	dst[127:96] := src2[63:32] 
	RETURN dst[127:0]	
}
dst[127:0] := INTERLEAVE_DWORDS(a[127:0], b[127:0])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="6095"><div class="instruction">vunpcklps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_unpacklo_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_unpacklo_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vunpcklps ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">DEFINE INTERLEAVE_DWORDS(src1[127:0], src2[127:0]) {
	dst[31:0] := src1[31:0] 
	dst[63:32] := src2[31:0] 
	dst[95:64] := src1[63:32] 
	dst[127:96] := src2[63:32] 
	RETURN dst[127:0]	
}
dst[127:0] := INTERLEAVE_DWORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_DWORDS(a[255:128], b[255:128])
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="6135"><div class="instruction">xorpd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_xor_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_xor_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: xorpd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compute the bitwise XOR of packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := a[i+63:i] XOR b[i+63:i]
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="6138"><div class="instruction">vxorpd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_xor_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_xor_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vxorpd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compute the bitwise XOR of packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[i+63:i] XOR b[i+63:i]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="6144"><div class="instruction">xorps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_xor_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_xor_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: xorps xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compute the bitwise XOR of packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := a[i+31:i] XOR b[i+31:i]
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="6147"><div class="instruction">vxorps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_xor_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_xor_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vxorps ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compute the bitwise XOR of packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := a[i+31:i] XOR b[i+31:i]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr><tr><td>Haswell</td><td>1</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic SSE2" id="6151"><div class="instruction">pxor</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_xor_si128</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_xor_si128</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: pxor xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Compute the bitwise XOR of 128 bits (representing integer data) in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[127:0] := (a[127:0] XOR b[127:0])</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.33</td></tr><tr><td>Haswell</td><td>1</td><td>0.33</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.33</td></tr></tbody></table></div></div><div class="intrinsic AVX2" id="6152"><div class="instruction">vpxor</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_xor_si256</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_xor_si256</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpxor ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Compute the bitwise XOR of 256 bits (representing integer data) in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[255:0] := (a[255:0] XOR b[255:0])
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.33</td></tr><tr><td>Haswell</td><td>1</td><td>0.33</td></tr></tbody></table></div></div><div class="intrinsic MMX" id="6154"><div class="instruction">pxor</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_xor_si64</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_xor_si64</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: pxor mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Compute the bitwise XOR of 64 bits (representing integer data) in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := (a[63:0] XOR b[63:0])</div></div></div><div class="intrinsic AVX" id="6169"><div class="instruction">vzeroall</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_zeroall</span> (<span class="param_type">void</span>)</span></div><div class="details" style="display: block;"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_zeroall</span> (<span class="param_type">void</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vzeroall<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Zero the contents of all XMM or YMM registers.</div><h1>Operation</h1><div class="operation">YMM0[MAX:0] := 0
YMM1[MAX:0] := 0
YMM2[MAX:0] := 0
YMM3[MAX:0] := 0
YMM4[MAX:0] := 0
YMM5[MAX:0] := 0
YMM6[MAX:0] := 0
YMM7[MAX:0] := 0
IF _64_BIT_MODE
	YMM8[MAX:0] := 0
	YMM9[MAX:0] := 0
	YMM10[MAX:0] := 0
	YMM11[MAX:0] := 0
	YMM12[MAX:0] := 0
	YMM13[MAX:0] := 0
	YMM14[MAX:0] := 0
	YMM15[MAX:0] := 0
FI</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>-</td><td>12</td></tr><tr><td>Broadwell</td><td>-</td><td>8</td></tr><tr><td>Haswell</td><td>-</td><td>8</td></tr><tr><td>Ivy Bridge</td><td>-</td><td>9</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="6170"><div class="instruction">vzeroupper</div><div class="signature"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_zeroupper</span> (<span class="param_type">void</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">void</span> <span class="name">_mm256_zeroupper</span> (<span class="param_type">void</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vzeroupper<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Zero the upper 128 bits of all YMM registers; the lower 128-bits of the registers are unmodified.</div><h1>Operation</h1><div class="operation">YMM0[MAX:128] := 0
YMM1[MAX:128] := 0
YMM2[MAX:128] := 0
YMM3[MAX:128] := 0
YMM4[MAX:128] := 0
YMM5[MAX:128] := 0
YMM6[MAX:128] := 0
YMM7[MAX:128] := 0
IF _64_BIT_MODE
	YMM8[MAX:128] := 0
	YMM9[MAX:128] := 0
	YMM10[MAX:128] := 0
	YMM11[MAX:128] := 0
	YMM12[MAX:128] := 0
	YMM13[MAX:128] := 0
	YMM14[MAX:128] := 0
	YMM15[MAX:128] := 0
FI</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>0</td><td>1</td></tr><tr><td>Broadwell</td><td>0</td><td>1</td></tr><tr><td>Haswell</td><td>0</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>0</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX" id="6171"><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_zextpd128_pd256</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span></div><div class="details" style="display: block;"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_zextpd128_pd256</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Casts vector of type __m128d to type __m256d; the upper 128 bits of the result are zeroed. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.
	</div></div></div><div class="intrinsic AVX" id="6174"><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_zextps128_ps256</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details" style="display: block;"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_zextps128_ps256</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Casts vector of type __m128 to type __m256; the upper 128 bits of the result are zeroed. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.
	</div></div></div><div class="intrinsic AVX" id="6177"><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_zextsi128_si256</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details" style="display: block;"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_zextsi128_si256</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Casts vector of type __m128i to type __m256i; the upper 128 bits of the result are zeroed. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.
	</div></div></div></div>
				
			</div>
			
			<div style="clear:both;"></div>
		</div>
		
		<!-- popbox's -->
		<div class="popbox info" style="width: 250px; top: 130.627px; left: 964.981px; display: none;">Data Version: 3.4.5 - <a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/files/ReleaseNotes.html" target="_blank">Release Notes</a><br>Data Updated: 05/30/2019<br><br>
			Questions? Issues? <a href="http://software.intel.com/en-us/forums/topic/363747" target="_blank" style="color:rgb(8,114,197);">Go Here.</a>
		</div>
		<div class="popbox sequence" style="width: 250px; display: none;">
			This intrinsic generates a sequence of instructions, which may perform worse than a native instruction. Consider the performance impact of this intrinsic.
		</div>
	
	
	<script type="text/javascript" src="./Intel® Intrinsics Guide_files/intrinsicsguide.min.js.下载"></script>
	
    <script type="text/javascript" src="./Intel® Intrinsics Guide_files/perf.json"></script>

</body></html>